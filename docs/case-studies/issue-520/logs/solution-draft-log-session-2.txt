# Solve.mjs Log - 2026-02-06T20:55:15.932Z

[2026-02-06T20:55:15.933Z] [INFO] üìÅ Log file: /home/hive/solve-2026-02-06T20-55-15-932Z.log
[2026-02-06T20:55:15.934Z] [INFO]    (All output will be logged here)
[2026-02-06T20:55:16.442Z] [INFO] 
[2026-02-06T20:55:16.442Z] [INFO] üöÄ solve v1.16.0
[2026-02-06T20:55:16.443Z] [INFO] üîß Raw command executed:
[2026-02-06T20:55:16.443Z] [INFO]    /home/hive/.nvm/versions/node/v20.20.0/bin/node /home/hive/.bun/bin/solve https://github.com/Jhon-Crow/godot-topdown-MVP/pull/528 --model opus --attach-logs --verbose --no-tool-check --auto-resume-on-limit-reset --tokens-budget-stats
[2026-02-06T20:55:16.443Z] [INFO] 
[2026-02-06T20:55:16.459Z] [INFO] 
[2026-02-06T20:55:16.460Z] [WARNING] ‚ö†Ô∏è  SECURITY WARNING: --attach-logs is ENABLED
[2026-02-06T20:55:16.460Z] [INFO] 
[2026-02-06T20:55:16.460Z] [INFO]    This option will upload the complete solution draft log file to the Pull Request.
[2026-02-06T20:55:16.461Z] [INFO]    The log may contain sensitive information such as:
[2026-02-06T20:55:16.461Z] [INFO]    ‚Ä¢ API keys, tokens, or secrets
[2026-02-06T20:55:16.461Z] [INFO]    ‚Ä¢ File paths and directory structures
[2026-02-06T20:55:16.461Z] [INFO]    ‚Ä¢ Command outputs and error messages
[2026-02-06T20:55:16.461Z] [INFO]    ‚Ä¢ Internal system information
[2026-02-06T20:55:16.461Z] [INFO] 
[2026-02-06T20:55:16.462Z] [INFO]    ‚ö†Ô∏è  DO NOT use this option with public repositories or if the log
[2026-02-06T20:55:16.462Z] [INFO]        might contain sensitive data that should not be shared publicly.
[2026-02-06T20:55:16.462Z] [INFO] 
[2026-02-06T20:55:16.462Z] [INFO]    Continuing in 5 seconds... (Press Ctrl+C to abort)
[2026-02-06T20:55:16.462Z] [INFO] 
[2026-02-06T20:55:21.468Z] [INFO] 
[2026-02-06T20:55:21.493Z] [INFO] üíæ Disk space check: 29648MB available (2048MB required) ‚úÖ
[2026-02-06T20:55:21.494Z] [INFO] üß† Memory check: 9490MB available, swap: 4095MB (256MB used), total: 13329MB (256MB required) ‚úÖ
[2026-02-06T20:55:21.513Z] [INFO] ‚è© Skipping tool connection validation (dry-run mode or skip-tool-connection-check enabled)
[2026-02-06T20:55:21.514Z] [INFO] ‚è© Skipping GitHub authentication check (dry-run mode or skip-tool-connection-check enabled)
[2026-02-06T20:55:21.514Z] [INFO] üìã URL validation:
[2026-02-06T20:55:21.514Z] [INFO]    Input URL: https://github.com/Jhon-Crow/godot-topdown-MVP/pull/528
[2026-02-06T20:55:21.515Z] [INFO]    Is Issue URL: false
[2026-02-06T20:55:21.515Z] [INFO]    Is PR URL: true
[2026-02-06T20:55:21.515Z] [INFO] üîç Checking repository access for auto-fork...
[2026-02-06T20:55:22.274Z] [INFO]    Repository visibility: public
[2026-02-06T20:55:22.275Z] [INFO] ‚úÖ Auto-fork: No write access detected, enabling fork mode
[2026-02-06T20:55:22.275Z] [INFO] ‚úÖ Repository access check: Skipped (fork mode enabled)
[2026-02-06T20:55:22.845Z] [INFO]    Repository visibility: public
[2026-02-06T20:55:22.845Z] [INFO]    Auto-cleanup default: false (repository is public)
[2026-02-06T20:55:22.846Z] [INFO] üîÑ Continue mode: Working with PR #528
[2026-02-06T20:55:22.846Z] [INFO]    Continue mode activated: PR URL provided directly
[2026-02-06T20:55:22.847Z] [INFO]    PR Number set to: 528
[2026-02-06T20:55:22.847Z] [INFO]    Will fetch PR details and linked issue
[2026-02-06T20:55:23.359Z] [INFO] üç¥ Detected fork PR from konard/Jhon-Crow-godot-topdown-MVP
[2026-02-06T20:55:23.359Z] [INFO]    Fork owner: konard
[2026-02-06T20:55:23.359Z] [INFO]    Will clone fork repository for continue mode
[2026-02-06T20:55:23.359Z] [INFO] üìù PR branch: issue-520-2af4a666a08c
[2026-02-06T20:55:23.360Z] [INFO] üîó Found linked issue #520
[2026-02-06T20:55:23.361Z] [INFO] 
Creating temporary directory: /tmp/gh-issue-solver-1770411323361
[2026-02-06T20:55:23.363Z] [INFO] 
üç¥ Fork mode:                ENABLED
[2026-02-06T20:55:23.363Z] [INFO]  Checking fork status...   

[2026-02-06T20:55:23.668Z] [INFO] üîç Detecting fork conflicts... 
[2026-02-06T20:55:24.647Z] [INFO] ‚úÖ No fork conflict:         Safe to proceed
[2026-02-06T20:55:24.989Z] [INFO] ‚úÖ Fork exists:              konard/Jhon-Crow-godot-topdown-MVP
[2026-02-06T20:55:24.990Z] [INFO] üîç Validating fork parent... 
[2026-02-06T20:55:25.422Z] [INFO] ‚úÖ Fork parent validated:    Jhon-Crow/godot-topdown-MVP
[2026-02-06T20:55:25.424Z] [INFO] 
üì• Cloning repository:       konard/Jhon-Crow-godot-topdown-MVP
[2026-02-06T20:55:28.820Z] [INFO] ‚úÖ Cloned to:                /tmp/gh-issue-solver-1770411323361
[2026-02-06T20:55:28.873Z] [INFO] üîó Setting upstream:         Jhon-Crow/godot-topdown-MVP
[2026-02-06T20:55:28.922Z] [INFO] ‚ÑπÔ∏è Upstream exists:          Using existing upstream remote
[2026-02-06T20:55:28.923Z] [INFO] üîÑ Fetching upstream...      
[2026-02-06T20:55:29.249Z] [INFO] ‚úÖ Upstream fetched:         Successfully
[2026-02-06T20:55:29.249Z] [INFO] üîÑ Syncing default branch... 
[2026-02-06T20:55:29.673Z] [INFO] ‚ÑπÔ∏è Default branch:           main
[2026-02-06T20:55:30.371Z] [INFO] ‚úÖ Default branch synced:    with upstream/main
[2026-02-06T20:55:30.372Z] [INFO] üîÑ Pushing to fork:          main branch
[2026-02-06T20:55:30.815Z] [INFO] ‚úÖ Fork updated:             Default branch pushed to fork
[2026-02-06T20:55:30.816Z] [INFO] 
üîç Checking PR fork:         Determining if branch is in another fork...
[2026-02-06T20:55:31.116Z] [INFO] ‚ÑπÔ∏è PR fork owner:            Same as current user, using origin remote
[2026-02-06T20:55:31.265Z] [INFO] 
üìå Default branch:           main
[2026-02-06T20:55:31.323Z] [INFO] 
üîÑ Checking out PR branch:   issue-520-2af4a666a08c
[2026-02-06T20:55:31.324Z] [INFO] üì• Fetching branches:        From remote...
[2026-02-06T20:55:31.767Z] [INFO] üîç Verifying:                Branch checkout...
[2026-02-06T20:55:31.817Z] [INFO] ‚úÖ Branch checked out:       issue-520-2af4a666a08c
[2026-02-06T20:55:31.818Z] [INFO] ‚úÖ Current branch:           issue-520-2af4a666a08c
[2026-02-06T20:55:31.818Z] [INFO]    Branch operation: Checkout existing PR branch
[2026-02-06T20:55:31.818Z] [INFO]    Branch verification: Matches expected
[2026-02-06T20:55:31.821Z] [INFO] 
üîÑ Continue mode:            ACTIVE
[2026-02-06T20:55:31.822Z] [INFO]    Using existing PR:      #528
[2026-02-06T20:55:31.822Z] [INFO]    PR URL:                 https://github.com/Jhon-Crow/godot-topdown-MVP/pull/528
[2026-02-06T20:55:31.822Z] [INFO] 
üöÄ Starting work session:    2026-02-06T20:55:31.822Z
[2026-02-06T20:55:32.191Z] [INFO]   üìù Converting PR:          Back to draft mode...
[2026-02-06T20:55:33.315Z] [INFO]   ‚úÖ PR converted:           Now in draft mode
[2026-02-06T20:55:34.187Z] [INFO]   üí¨ Posted:                 AI Work Session Started comment
[2026-02-06T20:55:34.507Z] [INFO]   üë§ Current user:           konard
[2026-02-06T20:55:34.508Z] [INFO] 
üìä Comment counting conditions:
[2026-02-06T20:55:34.509Z] [INFO]    prNumber: 528
[2026-02-06T20:55:34.509Z] [INFO]    branchName: issue-520-2af4a666a08c
[2026-02-06T20:55:34.509Z] [INFO]    isContinueMode: true
[2026-02-06T20:55:34.509Z] [INFO]    Will count comments: true
[2026-02-06T20:55:34.510Z] [INFO] üí¨ Counting comments:        Checking for new comments since last commit...
[2026-02-06T20:55:34.510Z] [INFO]    PR #528 on branch: issue-520-2af4a666a08c
[2026-02-06T20:55:34.510Z] [INFO]    Owner/Repo: Jhon-Crow/godot-topdown-MVP
[2026-02-06T20:55:34.992Z] [INFO]   üìÖ Last commit time (from API): 2026-02-06T20:25:42.000Z
[2026-02-06T20:55:35.961Z] [INFO]   üí¨ New PR comments:        2
[2026-02-06T20:55:35.962Z] [INFO]   üí¨ New PR review comments: 0
[2026-02-06T20:55:35.963Z] [INFO]   üí¨ New issue comments:     0
[2026-02-06T20:55:35.963Z] [INFO]    Total new comments: 2
[2026-02-06T20:55:35.963Z] [INFO]    Comment lines to add: Yes
[2026-02-06T20:55:35.963Z] [INFO]    PR review comments fetched: 0
[2026-02-06T20:55:35.964Z] [INFO]    PR conversation comments fetched: 3
[2026-02-06T20:55:35.965Z] [INFO]    Total PR comments checked: 3
[2026-02-06T20:55:38.744Z] [INFO]    Feedback info will be added to prompt:
[2026-02-06T20:55:38.745Z] [INFO]      - New comments on the pull request: 2
[2026-02-06T20:55:38.745Z] [INFO]      - Pull request description was edited after last commit
[2026-02-06T20:55:38.745Z] [INFO] üìÖ Getting timestamps:       From GitHub servers...
[2026-02-06T20:55:39.112Z] [INFO]   üìù Issue updated:          2026-02-06T17:46:37.000Z
[2026-02-06T20:55:39.417Z] [INFO]   üí¨ Last comment:           2026-02-06T17:46:37.000Z
[2026-02-06T20:55:39.822Z] [INFO]   üîÄ Recent PR:              2026-02-06T20:50:25.000Z
[2026-02-06T20:55:39.822Z] [INFO] 
‚úÖ Reference time:           2026-02-06T20:50:25.000Z
[2026-02-06T20:55:39.823Z] [INFO] 
üîç Checking for uncommitted changes to include as feedback...
[2026-02-06T20:55:39.874Z] [INFO] ‚úÖ No uncommitted changes found
[2026-02-06T20:55:40.212Z] [INFO] üì¶ Fork workflows detected:  https://github.com/konard/Jhon-Crow-godot-topdown-MVP/actions?query=branch%3Aissue-520-2af4a666a08c
[2026-02-06T20:55:42.136Z] [INFO] üé≠ Playwright MCP detected - enabling browser automation hints
[2026-02-06T20:55:42.233Z] [INFO] üëÅÔ∏è  Model vision capability: supported
[2026-02-06T20:55:42.235Z] [INFO] 
üìù Final prompt structure:
[2026-02-06T20:55:42.235Z] [INFO]    Characters: 621
[2026-02-06T20:55:42.235Z] [INFO]    System prompt characters: 12741
[2026-02-06T20:55:42.235Z] [INFO]    Feedback info: Included
[2026-02-06T20:55:42.237Z] [INFO] 
ü§ñ Executing Claude:         OPUS
[2026-02-06T20:55:42.237Z] [INFO]    Model: opus
[2026-02-06T20:55:42.238Z] [INFO]    Working directory: /tmp/gh-issue-solver-1770411323361
[2026-02-06T20:55:42.238Z] [INFO]    Branch: issue-520-2af4a666a08c
[2026-02-06T20:55:42.238Z] [INFO]    Prompt length: 621 chars
[2026-02-06T20:55:42.238Z] [INFO]    System prompt length: 12741 chars
[2026-02-06T20:55:42.238Z] [INFO]    Feedback info included: Yes (2 lines)
[2026-02-06T20:55:42.297Z] [INFO] üìà System resources before execution:
[2026-02-06T20:55:42.298Z] [INFO]    Memory: MemFree:         4253620 kB
[2026-02-06T20:55:42.298Z] [INFO]    Load: 1.66 1.50 1.38 2/545 797817
[2026-02-06T20:55:42.298Z] [INFO] 
üìù Raw command:              
[2026-02-06T20:55:42.299Z] [INFO] (cd "/tmp/gh-issue-solver-1770411323361" && claude --output-format stream-json --verbose --dangerously-skip-permissions --model claude-opus-4-6 -p "Issue to solve: https://github.com/Jhon-Crow/godot-topdown-MVP/issues/520
Your prepared branch: issue-520-2af4a666a08c
Your prepared working directory: /tmp/gh-issue-solver-1770411323361
Your prepared Pull Request: https://github.com/Jhon-Crow/godot-topdown-MVP/pull/528
Your forked repository: konard/Jhon-Crow-godot-topdown-MVP
Original repository (upstream): Jhon-Crow/godot-topdown-MVP
GitHub Actions on your fork: https://github.com/konard/Jhon-Crow-godot-topdown-MVP/actions?query=branch%3Aissue-520-2af4a666a08c

New comments on the pull request: 2
Pull request description was edited after last commit

Continue.
" --append-system-prompt "You are an AI issue solver. You prefer to find the root cause of each and every issue. When you talk, you prefer to speak with facts which you have double-checked yourself or cite sources that provide evidence, like quote actual code or give references to documents or pages found on the internet. You are polite and patient, and prefer to assume good intent, trying your best to be helpful. If you are unsure or have assumptions, you prefer to test them yourself or ask questions to clarify requirements.
General guidelines.
   - When you execute commands, always save their logs to files for easier reading if the output becomes large.
   - When running commands, do not set a timeout yourself ‚Äî let them run as long as needed (default timeout - 2 minutes is more than enough), and once they finish, review the logs in the file.
   - When running sudo commands (especially package installations like apt-get, yum, npm install, etc.), always run them in the background to avoid timeout issues and permission errors when the process needs to be killed. Use the run_in_background parameter or append & to the command.
   - When CI is failing or user reports failures, consider adding a detailed investigation protocol to your todo list with these steps:
      Step 1: List recent runs with timestamps using: gh run list --repo Jhon-Crow/godot-topdown-MVP --branch issue-520-2af4a666a08c --limit 5 --json databaseId,conclusion,createdAt,headSha
      Step 2: Verify runs are after the latest commit by checking timestamps and SHA
      Step 3: For each non-passing run, download logs to preserve them: gh run view {run-id} --repo Jhon-Crow/godot-topdown-MVP --log > ci-logs/{workflow}-{run-id}.log
      Step 4: Read each downloaded log file using Read tool to understand the actual failures
      Step 5: Report findings with specific errors and line numbers from logs
      This detailed investigation is especially helpful when user mentions CI failures, asks to investigate logs, you see non-passing status, or when finalizing a PR.
      Note: If user says \"failing\" but tools show \"passing\", this might indicate stale data - consider downloading fresh logs and checking timestamps to resolve the discrepancy.
   - When a code or log file has more than 1500 lines, read it in chunks of 1500 lines.
   - When facing a complex problem, do as much tracing as possible and turn on all verbose modes.
   - When you create debug, test, or example/experiment scripts for fixing, always keep them in an ./examples and/or ./experiments folders so you can reuse them later.
   - When testing your assumptions, use the experiment scripts, and add it to ./experiments folder.
   - When your experiments can show real world use case of the software, add it to ./examples folder.
   - When you face something extremely hard, use divide and conquer ‚Äî it always helps.

Initial research.
   - When you start, make sure you create detailed plan for yourself and follow your todo list step by step, make sure that as many points from these guidelines are added to your todo list to keep track of everything that can help you solve the issue with highest possible quality.
   - When user mentions CI failures or asks to investigate logs, consider adding these todos to track the investigation: (1) List recent CI runs with timestamps, (2) Download logs from failed runs to ci-logs/ directory, (3) Analyze error messages and identify root cause, (4) Implement fix, (5) Verify fix resolves the specific errors found in logs.
   - When you read issue, read all details and comments thoroughly.
   - When you see screenshots or images in issue descriptions, pull request descriptions, comments, or discussions, use WebFetch tool (or fetch tool) to download the image first, then use Read tool to view and analyze it. IMPORTANT: Before reading downloaded images with the Read tool, verify the file is a valid image (not HTML). Use a CLI tool like 'file' command to check the actual file format. Reading corrupted or non-image files (like GitHub's HTML 404 pages saved as .png) can cause \"Could not process image\" errors and may crash the AI solver process. If the file command shows \"HTML\" or \"text\", the download failed and you should retry or skip the image.
   - When you need issue details, use gh issue view https://github.com/Jhon-Crow/godot-topdown-MVP/issues/520.
   - When you need related code, use gh search code --owner Jhon-Crow [keywords].
   - When you need repo context, read files in your working directory.
   - When you study related work, study the most recent related pull requests.
   - When issue is not defined enough, write a comment to ask clarifying questions.
   - When accessing GitHub Gists (especially private ones), use gh gist view command instead of direct URL fetching to ensure proper authentication.
   - When you are fixing a bug, please make sure you first find the actual root cause, do as many experiments as needed.
   - When you are fixing a bug and code does not have enough tracing/logs, add them and make sure they stay in the code, but are switched off by default.
   - When you need comments on a pull request, note that GitHub has THREE different comment types with different API endpoints:
      1. PR review comments (inline code comments): gh api repos/Jhon-Crow/godot-topdown-MVP/pulls/528/comments --paginate
      2. PR conversation comments (general discussion): gh api repos/Jhon-Crow/godot-topdown-MVP/issues/528/comments --paginate
      3. PR reviews (approve/request changes): gh api repos/Jhon-Crow/godot-topdown-MVP/pulls/528/reviews --paginate
      IMPORTANT: The command \"gh pr view --json comments\" ONLY returns conversation comments and misses review comments!
   - When you need latest comments on issue, use gh api repos/Jhon-Crow/godot-topdown-MVP/issues/520/comments --paginate.

Solution development and testing.
   - When issue is solvable, implement code with tests.
   - When implementing features, search for similar existing implementations in the codebase and use them as examples instead of implementing everything from scratch.
   - When coding, each atomic step that can be useful by itself should be commited to the pull request's branch, meaning if work will be interrupted by any reason parts of solution will still be kept intact and safe in pull request.
   - When you test:
      start from testing of small functions using separate scripts;
      write unit tests with mocks for easy and quick start.
   - When you test integrations, use existing framework.
   - When you test solution draft, include automated checks in pr.
   - When issue is unclear, write comment on issue asking questions.
   - When you encounter any problems that you unable to solve yourself (any human feedback or help), write a comment to the pull request asking for help.
   - When you need human help, use gh pr comment 528 --body \"your message\" to comment on existing PR.

Preparing pull request.
   - When you code, follow contributing guidelines.
   - When you commit, write clear message.
   - When you need examples of style, use gh pr list --repo Jhon-Crow/godot-topdown-MVP --state merged --search [keywords].
   - When you open pr, describe solution draft and include tests.
   - When there is a package with version and GitHub Actions workflows for automatic release, update the version (or other necessary release trigger) in your pull request to prepare for next release.
   - When you update existing pr 528, use gh pr edit to modify title and description.
   - When you are about to commit or push code, ALWAYS run local CI checks first if they are available in contributing guidelines (like ruff check, mypy, eslint, etc.) to catch errors before pushing.
   - When you finalize the pull request:
      follow style from merged prs for code, title, and description,
      make sure no uncommitted changes corresponding to the original requirements are left behind,
      make sure the default branch is merged to the pull request's branch,
      make sure all CI checks passing if they exist before you finish,
      check for latest comments on the issue and pull request to ensure no recent feedback was missed,
      double-check that all changes in the pull request answer to original requirements of the issue,
      make sure no new new bugs are introduced in pull request by carefully reading gh pr diff,
      make sure no previously existing features were removed without an explicit request from users via the issue description, issue comments, and/or pull request comments.
   - When you finish implementation, use gh pr ready 528.

Workflow and collaboration.
   - When you check branch, verify with git branch --show-current.
   - When you push, push only to branch issue-520-2af4a666a08c.
   - When you finish, create a pull request from branch issue-520-2af4a666a08c. (Note: PR 528 already exists, update it instead)
   - When you organize workflow, use pull requests instead of direct merges to default branch (main or master).
   - When you manage commits, preserve commit history for later analysis.
   - When you contribute, keep repository history forward-moving with regular commits, pushes, and reverts if needed.
   - When you face conflict that you cannot resolve yourself, ask for help.
   - When you collaborate, respect branch protections by working only on issue-520-2af4a666a08c.
   - When you mention result, include pull request url or comment url.
   - When you need to create pr, remember pr 528 already exists for this branch.

Self review.
   - When you check your solution draft, run all tests locally.
   - When you check your solution draft, verify git status shows a clean working tree with no uncommitted changes.
   - When you compare with repo style, use gh pr diff [number].
   - When you finalize, confirm code, tests, and description are consistent.

GitHub CLI command patterns.
   - IMPORTANT: Always use --paginate flag when fetching lists from GitHub API to ensure all results are returned (GitHub returns max 30 per page by default).
   - When listing PR review comments (inline code comments), use gh api repos/OWNER/REPO/pulls/NUMBER/comments --paginate.
   - When listing PR conversation comments, use gh api repos/OWNER/REPO/issues/NUMBER/comments --paginate.
   - When listing PR reviews, use gh api repos/OWNER/REPO/pulls/NUMBER/reviews --paginate.
   - When listing issue comments, use gh api repos/OWNER/REPO/issues/NUMBER/comments --paginate.
   - When adding PR comment, use gh pr comment NUMBER --body \"text\" --repo OWNER/REPO.
   - When adding issue comment, use gh issue comment NUMBER --body \"text\" --repo OWNER/REPO.
   - When viewing PR details, use gh pr view NUMBER --repo OWNER/REPO.
   - When filtering with jq, use gh api repos/\${owner}/\${repo}/pulls/\${prNumber}/comments --paginate --jq 'reverse | .[0:5]'.

Playwright MCP usage (browser automation via mcp__playwright__* tools).
   - When you develop frontend web applications (HTML, CSS, JavaScript, React, Vue, Angular, etc.), use Playwright MCP tools to test the UI in a real browser.
   - When WebFetch tool fails to retrieve expected content (e.g., returns empty content, JavaScript-rendered pages, or login-protected pages), use Playwright MCP tools (browser_navigate, browser_snapshot) as a fallback for web browsing.
   - When you need to interact with dynamic web pages that require JavaScript execution, use Playwright MCP tools.
   - When you need to visually verify how a web page looks or take screenshots, use browser_take_screenshot from Playwright MCP.
   - When you need to fill forms, click buttons, or perform user interactions on web pages, use Playwright MCP tools (browser_click, browser_type, browser_fill_form).
   - When you need to test responsive design or different viewport sizes, use browser_resize from Playwright MCP.
   - When you finish using the browser, always close it with browser_close to free resources.

Visual UI work and screenshots.
   - When you work on visual UI changes (frontend, CSS, HTML, design), include a render or screenshot of the final result in the pull request description.
   - When you need to show visual results, take a screenshot and save it to the repository (e.g., in a docs/screenshots/ or assets/ folder).
   - When you save screenshots to the repository, use permanent raw file links in the pull request description markdown (e.g., https://raw.githubusercontent.com/Jhon-Crow/godot-topdown-MVP/issue-520-2af4a666a08c/docs/screenshots/result.png).
   - When uploading images, commit them to the branch first, then reference them using the raw GitHub URL format.
   - When the visual result is important for review, mention it explicitly in the pull request description with the embedded image." | jq -c .)
[2026-02-06T20:55:42.300Z] [INFO] 
[2026-02-06T20:55:42.301Z] [INFO] üìã User prompt:
[2026-02-06T20:55:42.301Z] [INFO] ---BEGIN USER PROMPT---
[2026-02-06T20:55:42.301Z] [INFO] Issue to solve: https://github.com/Jhon-Crow/godot-topdown-MVP/issues/520
Your prepared branch: issue-520-2af4a666a08c
Your prepared working directory: /tmp/gh-issue-solver-1770411323361
Your prepared Pull Request: https://github.com/Jhon-Crow/godot-topdown-MVP/pull/528
Your forked repository: konard/Jhon-Crow-godot-topdown-MVP
Original repository (upstream): Jhon-Crow/godot-topdown-MVP
GitHub Actions on your fork: https://github.com/konard/Jhon-Crow-godot-topdown-MVP/actions?query=branch%3Aissue-520-2af4a666a08c

New comments on the pull request: 2
Pull request description was edited after last commit

Continue.

[2026-02-06T20:55:42.301Z] [INFO] ---END USER PROMPT---
[2026-02-06T20:55:42.301Z] [INFO] 
[2026-02-06T20:55:42.302Z] [INFO] üìã System prompt:
[2026-02-06T20:55:42.302Z] [INFO] ---BEGIN SYSTEM PROMPT---
[2026-02-06T20:55:42.302Z] [INFO] You are an AI issue solver. You prefer to find the root cause of each and every issue. When you talk, you prefer to speak with facts which you have double-checked yourself or cite sources that provide evidence, like quote actual code or give references to documents or pages found on the internet. You are polite and patient, and prefer to assume good intent, trying your best to be helpful. If you are unsure or have assumptions, you prefer to test them yourself or ask questions to clarify requirements.
General guidelines.
   - When you execute commands, always save their logs to files for easier reading if the output becomes large.
   - When running commands, do not set a timeout yourself ‚Äî let them run as long as needed (default timeout - 2 minutes is more than enough), and once they finish, review the logs in the file.
   - When running sudo commands (especially package installations like apt-get, yum, npm install, etc.), always run them in the background to avoid timeout issues and permission errors when the process needs to be killed. Use the run_in_background parameter or append & to the command.
   - When CI is failing or user reports failures, consider adding a detailed investigation protocol to your todo list with these steps:
      Step 1: List recent runs with timestamps using: gh run list --repo Jhon-Crow/godot-topdown-MVP --branch issue-520-2af4a666a08c --limit 5 --json databaseId,conclusion,createdAt,headSha
      Step 2: Verify runs are after the latest commit by checking timestamps and SHA
      Step 3: For each non-passing run, download logs to preserve them: gh run view {run-id} --repo Jhon-Crow/godot-topdown-MVP --log > ci-logs/{workflow}-{run-id}.log
      Step 4: Read each downloaded log file using Read tool to understand the actual failures
      Step 5: Report findings with specific errors and line numbers from logs
      This detailed investigation is especially helpful when user mentions CI failures, asks to investigate logs, you see non-passing status, or when finalizing a PR.
      Note: If user says "failing" but tools show "passing", this might indicate stale data - consider downloading fresh logs and checking timestamps to resolve the discrepancy.
   - When a code or log file has more than 1500 lines, read it in chunks of 1500 lines.
   - When facing a complex problem, do as much tracing as possible and turn on all verbose modes.
   - When you create debug, test, or example/experiment scripts for fixing, always keep them in an ./examples and/or ./experiments folders so you can reuse them later.
   - When testing your assumptions, use the experiment scripts, and add it to ./experiments folder.
   - When your experiments can show real world use case of the software, add it to ./examples folder.
   - When you face something extremely hard, use divide and conquer ‚Äî it always helps.

Initial research.
   - When you start, make sure you create detailed plan for yourself and follow your todo list step by step, make sure that as many points from these guidelines are added to your todo list to keep track of everything that can help you solve the issue with highest possible quality.
   - When user mentions CI failures or asks to investigate logs, consider adding these todos to track the investigation: (1) List recent CI runs with timestamps, (2) Download logs from failed runs to ci-logs/ directory, (3) Analyze error messages and identify root cause, (4) Implement fix, (5) Verify fix resolves the specific errors found in logs.
   - When you read issue, read all details and comments thoroughly.
   - When you see screenshots or images in issue descriptions, pull request descriptions, comments, or discussions, use WebFetch tool (or fetch tool) to download the image first, then use Read tool to view and analyze it. IMPORTANT: Before reading downloaded images with the Read tool, verify the file is a valid image (not HTML). Use a CLI tool like 'file' command to check the actual file format. Reading corrupted or non-image files (like GitHub's HTML 404 pages saved as .png) can cause "Could not process image" errors and may crash the AI solver process. If the file command shows "HTML" or "text", the download failed and you should retry or skip the image.
   - When you need issue details, use gh issue view https://github.com/Jhon-Crow/godot-topdown-MVP/issues/520.
   - When you need related code, use gh search code --owner Jhon-Crow [keywords].
   - When you need repo context, read files in your working directory.
   - When you study related work, study the most recent related pull requests.
   - When issue is not defined enough, write a comment to ask clarifying questions.
   - When accessing GitHub Gists (especially private ones), use gh gist view command instead of direct URL fetching to ensure proper authentication.
   - When you are fixing a bug, please make sure you first find the actual root cause, do as many experiments as needed.
   - When you are fixing a bug and code does not have enough tracing/logs, add them and make sure they stay in the code, but are switched off by default.
   - When you need comments on a pull request, note that GitHub has THREE different comment types with different API endpoints:
      1. PR review comments (inline code comments): gh api repos/Jhon-Crow/godot-topdown-MVP/pulls/528/comments --paginate
      2. PR conversation comments (general discussion): gh api repos/Jhon-Crow/godot-topdown-MVP/issues/528/comments --paginate
      3. PR reviews (approve/request changes): gh api repos/Jhon-Crow/godot-topdown-MVP/pulls/528/reviews --paginate
      IMPORTANT: The command "gh pr view --json comments" ONLY returns conversation comments and misses review comments!
   - When you need latest comments on issue, use gh api repos/Jhon-Crow/godot-topdown-MVP/issues/520/comments --paginate.

Solution development and testing.
   - When issue is solvable, implement code with tests.
   - When implementing features, search for similar existing implementations in the codebase and use them as examples instead of implementing everything from scratch.
   - When coding, each atomic step that can be useful by itself should be commited to the pull request's branch, meaning if work will be interrupted by any reason parts of solution will still be kept intact and safe in pull request.
   - When you test:
      start from testing of small functions using separate scripts;
      write unit tests with mocks for easy and quick start.
   - When you test integrations, use existing framework.
   - When you test solution draft, include automated checks in pr.
   - When issue is unclear, write comment on issue asking questions.
   - When you encounter any problems that you unable to solve yourself (any human feedback or help), write a comment to the pull request asking for help.
   - When you need human help, use gh pr comment 528 --body "your message" to comment on existing PR.

Preparing pull request.
   - When you code, follow contributing guidelines.
   - When you commit, write clear message.
   - When you need examples of style, use gh pr list --repo Jhon-Crow/godot-topdown-MVP --state merged --search [keywords].
   - When you open pr, describe solution draft and include tests.
   - When there is a package with version and GitHub Actions workflows for automatic release, update the version (or other necessary release trigger) in your pull request to prepare for next release.
   - When you update existing pr 528, use gh pr edit to modify title and description.
   - When you are about to commit or push code, ALWAYS run local CI checks first if they are available in contributing guidelines (like ruff check, mypy, eslint, etc.) to catch errors before pushing.
   - When you finalize the pull request:
      follow style from merged prs for code, title, and description,
      make sure no uncommitted changes corresponding to the original requirements are left behind,
      make sure the default branch is merged to the pull request's branch,
      make sure all CI checks passing if they exist before you finish,
      check for latest comments on the issue and pull request to ensure no recent feedback was missed,
      double-check that all changes in the pull request answer to original requirements of the issue,
      make sure no new new bugs are introduced in pull request by carefully reading gh pr diff,
      make sure no previously existing features were removed without an explicit request from users via the issue description, issue comments, and/or pull request comments.
   - When you finish implementation, use gh pr ready 528.

Workflow and collaboration.
   - When you check branch, verify with git branch --show-current.
   - When you push, push only to branch issue-520-2af4a666a08c.
   - When you finish, create a pull request from branch issue-520-2af4a666a08c. (Note: PR 528 already exists, update it instead)
   - When you organize workflow, use pull requests instead of direct merges to default branch (main or master).
   - When you manage commits, preserve commit history for later analysis.
   - When you contribute, keep repository history forward-moving with regular commits, pushes, and reverts if needed.
   - When you face conflict that you cannot resolve yourself, ask for help.
   - When you collaborate, respect branch protections by working only on issue-520-2af4a666a08c.
   - When you mention result, include pull request url or comment url.
   - When you need to create pr, remember pr 528 already exists for this branch.

Self review.
   - When you check your solution draft, run all tests locally.
   - When you check your solution draft, verify git status shows a clean working tree with no uncommitted changes.
   - When you compare with repo style, use gh pr diff [number].
   - When you finalize, confirm code, tests, and description are consistent.

GitHub CLI command patterns.
   - IMPORTANT: Always use --paginate flag when fetching lists from GitHub API to ensure all results are returned (GitHub returns max 30 per page by default).
   - When listing PR review comments (inline code comments), use gh api repos/OWNER/REPO/pulls/NUMBER/comments --paginate.
   - When listing PR conversation comments, use gh api repos/OWNER/REPO/issues/NUMBER/comments --paginate.
   - When listing PR reviews, use gh api repos/OWNER/REPO/pulls/NUMBER/reviews --paginate.
   - When listing issue comments, use gh api repos/OWNER/REPO/issues/NUMBER/comments --paginate.
   - When adding PR comment, use gh pr comment NUMBER --body "text" --repo OWNER/REPO.
   - When adding issue comment, use gh issue comment NUMBER --body "text" --repo OWNER/REPO.
   - When viewing PR details, use gh pr view NUMBER --repo OWNER/REPO.
   - When filtering with jq, use gh api repos/${owner}/${repo}/pulls/${prNumber}/comments --paginate --jq 'reverse | .[0:5]'.

Playwright MCP usage (browser automation via mcp__playwright__* tools).
   - When you develop frontend web applications (HTML, CSS, JavaScript, React, Vue, Angular, etc.), use Playwright MCP tools to test the UI in a real browser.
   - When WebFetch tool fails to retrieve expected content (e.g., returns empty content, JavaScript-rendered pages, or login-protected pages), use Playwright MCP tools (browser_navigate, browser_snapshot) as a fallback for web browsing.
   - When you need to interact with dynamic web pages that require JavaScript execution, use Playwright MCP tools.
   - When you need to visually verify how a web page looks or take screenshots, use browser_take_screenshot from Playwright MCP.
   - When you need to fill forms, click buttons, or perform user interactions on web pages, use Playwright MCP tools (browser_click, browser_type, browser_fill_form).
   - When you need to test responsive design or different viewport sizes, use browser_resize from Playwright MCP.
   - When you finish using the browser, always close it with browser_close to free resources.

Visual UI work and screenshots.
   - When you work on visual UI changes (frontend, CSS, HTML, design), include a render or screenshot of the final result in the pull request description.
   - When you need to show visual results, take a screenshot and save it to the repository (e.g., in a docs/screenshots/ or assets/ folder).
   - When you save screenshots to the repository, use permanent raw file links in the pull request description markdown (e.g., https://raw.githubusercontent.com/Jhon-Crow/godot-topdown-MVP/issue-520-2af4a666a08c/docs/screenshots/result.png).
   - When uploading images, commit them to the branch first, then reference them using the raw GitHub URL format.
   - When the visual result is important for review, mention it explicitly in the pull request description with the embedded image.
[2026-02-06T20:55:42.302Z] [INFO] ---END SYSTEM PROMPT---
[2026-02-06T20:55:42.303Z] [INFO] 
[2026-02-06T20:55:42.304Z] [INFO] üìä CLAUDE_CODE_MAX_OUTPUT_TOKENS: 128000
[2026-02-06T20:55:42.304Z] [INFO] üìä MCP_TIMEOUT: 900000ms (server startup)
[2026-02-06T20:55:42.305Z] [INFO] üìä MCP_TOOL_TIMEOUT: 900000ms (tool execution)
[2026-02-06T20:55:42.306Z] [INFO] üìã Command details:          
[2026-02-06T20:55:42.306Z] [INFO]   üìÇ Working directory:      /tmp/gh-issue-solver-1770411323361
[2026-02-06T20:55:42.306Z] [INFO]   üåø Branch:                 issue-520-2af4a666a08c
[2026-02-06T20:55:42.307Z] [INFO]   ü§ñ Model:                  Claude OPUS
[2026-02-06T20:55:42.307Z] [INFO]   üç¥ Fork:                   konard/Jhon-Crow-godot-topdown-MVP
[2026-02-06T20:55:42.307Z] [INFO] 
‚ñ∂Ô∏è Streaming output:         

[2026-02-06T20:55:44.722Z] [INFO] {
  "type": "system",
  "subtype": "init",
  "cwd": "/tmp/gh-issue-solver-1770411323361",
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "tools": [
    "Task",
    "TaskOutput",
    "Bash",
    "Glob",
    "Grep",
    "ExitPlanMode",
    "Read",
    "Edit",
    "Write",
    "NotebookEdit",
    "WebFetch",
    "TodoWrite",
    "WebSearch",
    "TaskStop",
    "AskUserQuestion",
    "Skill",
    "EnterPlanMode",
    "ToolSearch",
    "mcp__playwright__browser_close",
    "mcp__playwright__browser_resize",
    "mcp__playwright__browser_console_messages",
    "mcp__playwright__browser_handle_dialog",
    "mcp__playwright__browser_evaluate",
    "mcp__playwright__browser_file_upload",
    "mcp__playwright__browser_fill_form",
    "mcp__playwright__browser_install",
    "mcp__playwright__browser_press_key",
    "mcp__playwright__browser_type",
    "mcp__playwright__browser_navigate",
    "mcp__playwright__browser_navigate_back",
    "mcp__playwright__browser_network_requests",
    "mcp__playwright__browser_run_code",
    "mcp__playwright__browser_take_screenshot",
    "mcp__playwright__browser_snapshot",
    "mcp__playwright__browser_click",
    "mcp__playwright__browser_drag",
    "mcp__playwright__browser_hover",
    "mcp__playwright__browser_select_option",
    "mcp__playwright__browser_tabs",
    "mcp__playwright__browser_wait_for"
  ],
  "mcp_servers": [
    {
      "name": "playwright",
      "status": "connected"
    }
  ],
  "model": "claude-opus-4-6",
  "permissionMode": "bypassPermissions",
  "slash_commands": [
    "keybindings-help",
    "debug",
    "compact",
    "context",
    "cost",
    "init",
    "pr-comments",
    "release-notes",
    "review",
    "security-review",
    "insights"
  ],
  "apiKeySource": "none",
  "claude_code_version": "2.1.33",
  "output_style": "default",
  "agents": [
    "Bash",
    "general-purpose",
    "statusline-setup",
    "Explore",
    "Plan"
  ],
  "skills": [
    "keybindings-help",
    "debug"
  ],
  "plugins": [],
  "uuid": "7a894235-9d22-45e4-ba3d-97f4f08a5c65"
}
[2026-02-06T20:55:44.723Z] [INFO] üìå Session ID: 72695659-de5b-4772-8d20-a0317ff84485
[2026-02-06T20:55:44.724Z] [INFO] üìÅ Log renamed to: /home/hive/72695659-de5b-4772-8d20-a0317ff84485.log
[2026-02-06T20:55:47.709Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01EDhFoKxqhWb9HUrZkYCsYv",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "\n\nI'll start by reviewing the current state of the issue, PR, and any new comments to understand what needs to be done."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 2,
      "cache_creation_input_tokens": 7120,
      "cache_read_input_tokens": 18845,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 7120
      },
      "output_tokens": 4,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "390ca85e-834d-4d37-bc89-4f90d8767d09"
}
[2026-02-06T20:55:48.564Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01EDhFoKxqhWb9HUrZkYCsYv",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_014dP3FdNAH1CxbR7vxpGG53",
        "name": "Bash",
        "input": {
          "command": "gh issue view 520 --repo Jhon-Crow/godot-topdown-MVP",
          "description": "View issue details"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 2,
      "cache_creation_input_tokens": 7120,
      "cache_read_input_tokens": 18845,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 7120
      },
      "output_tokens": 4,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "d1cb26e1-0f95-4b80-85e4-0192596efe88"
}
[2026-02-06T20:55:49.163Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01EDhFoKxqhWb9HUrZkYCsYv",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_014ZUMUpi8t573vP1Zd268Qy",
        "name": "Bash",
        "input": {
          "command": "gh pr view 528 --repo Jhon-Crow/godot-topdown-MVP",
          "description": "View PR details"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 2,
      "cache_creation_input_tokens": 7120,
      "cache_read_input_tokens": 18845,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 7120
      },
      "output_tokens": 4,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "59952dea-5372-4c52-93a9-520b6a866711"
}
[2026-02-06T20:55:49.910Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01EDhFoKxqhWb9HUrZkYCsYv",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_012VKKSw4EcSqCVDmKja7BUz",
        "name": "Bash",
        "input": {
          "command": "gh api repos/Jhon-Crow/godot-topdown-MVP/issues/528/comments --paginate",
          "description": "Get PR conversation comments"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 2,
      "cache_creation_input_tokens": 7120,
      "cache_read_input_tokens": 18845,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 7120
      },
      "output_tokens": 4,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "5ce3f813-6fa5-4e20-a532-f08a48bb5f76"
}
[2026-02-06T20:55:50.242Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_014dP3FdNAH1CxbR7vxpGG53",
        "type": "tool_result",
        "content": "title:\t–¥–æ–±–∞–≤—å —Å–Ω–∞–π–ø–µ—Ä—Å–∫—É—é –≤–∏–Ω—Ç–æ–≤–∫—É\nstate:\tOPEN\nauthor:\tJhon-Crow\nlabels:\t\ncomments:\t2\nassignees:\t\nprojects:\t\nmilestone:\t\nnumber:\t520\n--\n–Ω–∞–∑–≤–∞–Ω–∏–µ –≤–∏–Ω—Ç–æ–≤–∫–∏ –ê–°–í–ö \n—Ä–µ—Ñ–µ—Ä–µ–Ω—Å –º–æ–¥–µ–ª–∏:\n<img width=\"400\" height=\"151\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/a8c7db80-8709-43ee-b5bf-3df39d297cb7\" />\n\n–ø–∞—Ç—Ä–æ–Ω—ã 12,7√ó108 –º–º - –¥–æ–ª–∂–Ω—ã –Ω–∞–Ω–æ—Å–∏—Ç—å 50 —É—Ä–æ–Ω–∞ –∏ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å 2 —Å—Ç–µ–Ω—ã, –ø—Ä–æ–±–∏–≤–∞—Ç—å –Ω–∞—Å–∫–≤–æ–∑—å –≤—Ä–∞–≥–æ–≤, –≤—ã—Å—Ç—Ä–µ–ª - —Ä–∞—Å—Å–µ–∏–≤–∞—é—â–∏–π—Å—è –¥—ã–º–Ω—ã–π —Ç—Ä–∞—Å—Å–µ—Ä (–∫–∞–∫ –æ—Ç —Å–∞–º–æ–ª—ë—Ç–∞) –¥–æ –∫–æ–Ω—Ü–∞ –∫–∞—Ä—Ç—ã, —Ç–æ –µ—Å—Ç—å —Å–∫–æ—Ä–æ—Å—Ç—å –ø—É–ª–∏ –±–µ—Å–∫–æ–Ω–µ—á–Ω–∞—è.\n—á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø–æ–≤–æ—Ä–æ—Ç–∞ - –æ—á–µ–Ω—å –≤—ã—Å–æ–∫–∞—è.\n–º–∞–≥–∞–∑–∏–Ω = 5 –ø–∞—Ç—Ä–æ–Ω–æ–≤.\n—Ä–µ–∂–∏–º —Å—Ç—Ä–µ–ª—å–±—ã - –æ–¥–Ω–æ–∑–∞—Ä—è–¥–Ω–∞—è.\n–ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∞ - –Ω–æ–≤—ã–π –º–∞–≥–∞–∑–∏–Ω –∑–∞—Ä—è–∂–∞–µ—Ç—Å—è —Ç–∞–∫ –∂–µ, –∫–∞–∫ —É m16, –Ω–æ –µ—Å—Ç—å –∑–∞—Ä—è–¥–∫–∞ –ø–µ—Ä–µ–¥ –∫–∞–∂–¥—ã–º –≤—ã—Å—Ç—Ä–µ–ª–æ–º.\n–∑–∞—Ä—è–¥–∫–∞ –ø–µ—Ä–µ–¥ –≤—ã—Å—Ç—Ä–µ–ª–æ–º = —Å—Ç—Ä–µ–ª–∫–∞ –≤–Ω–∏–∑ (–æ—Ç–≤–µ—Å—Ç–∏ –∑–∞—Ç–≤–æ—Ä) -> —Å—Ç—Ä–µ–ª–∫–∞ –≤–ª–µ–≤–æ (–æ—Ç–∫—Ä—ã—Ç—å –∑–∞—Ç–≤–æ—Ä) -> —Å—Ç—Ä–µ–ª–∫–∞ –≤–Ω–∏–∑ (–∑–∞–∫—Ä—ã—Ç—å –∑–∞—Ç–≤–æ—Ä) -> —Å—Ç—Ä–µ–ª–∫–∞ –≤–≤–µ—Ä—Ö (–¥–æ—Å–ª–∞—Ç—å –ø–∞—Ç—Ä–æ–Ω)\n\n–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –ø—É–Ω–∫—Ç:\n—Ç–∞–∫ –∂–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏–µ –Ω–∞ RMB - –ø—Ä–∏ –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏–∏ –Ω–∞ —ç–∫—Ä–∞–Ω –Ω–∞–∫–ª–∞–¥—ã–≤–∞–µ—Ç—Å—è \"–ø—Ä–∏—Ü–µ–ª\":\n<img width=\"820\" height=\"654\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/a1228111-e4f4-4e3c-8457-9d1a1ae3bd29\" />\n–ø—Ä–∏ —ç—Ç–æ–º –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏–µ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –ø–æ –∑–æ–Ω–µ –∑–∞ –≤—å—é–ø–æ—Ä—Ç–æ–º –≤ —Ç–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏, –∫—É–¥–∞ —Å–º–æ—Ç—Ä–µ–ª –∏–≥—Ä–æ–∫ (–ø–æ–∑–≤–æ–ª—è–µ—Ç –∑–∞–≥–ª—è–Ω—É—Ç—å –¥–∞–ª—å—à–µ, –Ω–æ –Ω–µ –ø–æ–∑–≤–æ–ª—è–µ—Ç —Ü–µ–ª–∏—Ç—å—Å—è –±–ª–∏–∑–∫–æ).\n–ø—Ä–∏ –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏–∏ –º–æ–∂–Ω–æ —Ü–µ–ª–∏—Ç—å—Å—è –≤ —Ä–∞–º–∫–∞—Ö –≤—å—é–ø–æ—Ä—Ç–∞ –∏ –≤—Ä–∞—â–µ–Ω–∏–µ–º –∫–æ–ª—ë—Å–∏–∫–∞ –¥–≤–∏–≥–∞—Ç—å –∑–æ–Ω—É –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è (–µ—â—ë –¥–∞–ª—å—à–µ —á–µ–º –∑–∞ –≤—å—é–ø–æ—Ä—Ç).\n—á–µ–º –¥–∞–ª—å—à–µ –æ—Ç –∏–≥—Ä–æ–∫–∞ –∑–æ–Ω–∞ –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è - —Ç–µ–º —Å–∏–ª—å–Ω–µ–µ —Ä–∞—Å–∫–∞—á–∏–≤–∞–µ—Ç—Å—è –ø—Ä–∏—Ü–µ–ª (–Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏ –æ–¥–Ω–æ–≥–æ –≤—å—é–ø–æ—Ä—Ç–∞ - –Ω–µ —Å–∏–ª—å–Ω–æ, –Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏ 2 –≤ 2 —Ä–∞–∑–∞ —Å–∏–ª—å–Ω–µ–µ).",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "da284257-e4d0-4d9b-a343-89bc9b510a6e",
  "tool_use_result": {
    "stdout": "title:\t–¥–æ–±–∞–≤—å —Å–Ω–∞–π–ø–µ—Ä—Å–∫—É—é –≤–∏–Ω—Ç–æ–≤–∫—É\nstate:\tOPEN\nauthor:\tJhon-Crow\nlabels:\t\ncomments:\t2\nassignees:\t\nprojects:\t\nmilestone:\t\nnumber:\t520\n--\n–Ω–∞–∑–≤–∞–Ω–∏–µ –≤–∏–Ω—Ç–æ–≤–∫–∏ –ê–°–í–ö \n—Ä–µ—Ñ–µ—Ä–µ–Ω—Å –º–æ–¥–µ–ª–∏:\n<img width=\"400\" height=\"151\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/a8c7db80-8709-43ee-b5bf-3df39d297cb7\" />\n\n–ø–∞—Ç—Ä–æ–Ω—ã 12,7√ó108 –º–º - –¥–æ–ª–∂–Ω—ã –Ω–∞–Ω–æ—Å–∏—Ç—å 50 —É—Ä–æ–Ω–∞ –∏ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å 2 —Å—Ç–µ–Ω—ã, –ø—Ä–æ–±–∏–≤–∞—Ç—å –Ω–∞—Å–∫–≤–æ–∑—å –≤—Ä–∞–≥–æ–≤, –≤—ã—Å—Ç—Ä–µ–ª - —Ä–∞—Å—Å–µ–∏–≤–∞—é—â–∏–π—Å—è –¥—ã–º–Ω—ã–π —Ç—Ä–∞—Å—Å–µ—Ä (–∫–∞–∫ –æ—Ç —Å–∞–º–æ–ª—ë—Ç–∞) –¥–æ –∫–æ–Ω—Ü–∞ –∫–∞—Ä—Ç—ã, —Ç–æ –µ—Å—Ç—å —Å–∫–æ—Ä–æ—Å—Ç—å –ø—É–ª–∏ –±–µ—Å–∫–æ–Ω–µ—á–Ω–∞—è.\n—á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø–æ–≤–æ—Ä–æ—Ç–∞ - –æ—á–µ–Ω—å –≤—ã—Å–æ–∫–∞—è.\n–º–∞–≥–∞–∑–∏–Ω = 5 –ø–∞—Ç—Ä–æ–Ω–æ–≤.\n—Ä–µ–∂–∏–º —Å—Ç—Ä–µ–ª—å–±—ã - –æ–¥–Ω–æ–∑–∞—Ä—è–¥–Ω–∞—è.\n–ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∞ - –Ω–æ–≤—ã–π –º–∞–≥–∞–∑–∏–Ω –∑–∞—Ä—è–∂–∞–µ—Ç—Å—è —Ç–∞–∫ –∂–µ, –∫–∞–∫ —É m16, –Ω–æ –µ—Å—Ç—å –∑–∞—Ä—è–¥–∫–∞ –ø–µ—Ä–µ–¥ –∫–∞–∂–¥—ã–º –≤—ã—Å—Ç—Ä–µ–ª–æ–º.\n–∑–∞—Ä—è–¥–∫–∞ –ø–µ—Ä–µ–¥ –≤—ã—Å—Ç—Ä–µ–ª–æ–º = —Å—Ç—Ä–µ–ª–∫–∞ –≤–Ω–∏–∑ (–æ—Ç–≤–µ—Å—Ç–∏ –∑–∞—Ç–≤–æ—Ä) -> —Å—Ç—Ä–µ–ª–∫–∞ –≤–ª–µ–≤–æ (–æ—Ç–∫—Ä—ã—Ç—å –∑–∞—Ç–≤–æ—Ä) -> —Å—Ç—Ä–µ–ª–∫–∞ –≤–Ω–∏–∑ (–∑–∞–∫—Ä—ã—Ç—å –∑–∞—Ç–≤–æ—Ä) -> —Å—Ç—Ä–µ–ª–∫–∞ –≤–≤–µ—Ä—Ö (–¥–æ—Å–ª–∞—Ç—å –ø–∞—Ç—Ä–æ–Ω)\n\n–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –ø—É–Ω–∫—Ç:\n—Ç–∞–∫ –∂–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏–µ –Ω–∞ RMB - –ø—Ä–∏ –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏–∏ –Ω–∞ —ç–∫—Ä–∞–Ω –Ω–∞–∫–ª–∞–¥—ã–≤–∞–µ—Ç—Å—è \"–ø—Ä–∏—Ü–µ–ª\":\n<img width=\"820\" height=\"654\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/a1228111-e4f4-4e3c-8457-9d1a1ae3bd29\" />\n–ø—Ä–∏ —ç—Ç–æ–º –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏–µ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –ø–æ –∑–æ–Ω–µ –∑–∞ –≤—å—é–ø–æ—Ä—Ç–æ–º –≤ —Ç–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏, –∫—É–¥–∞ —Å–º–æ—Ç—Ä–µ–ª –∏–≥—Ä–æ–∫ (–ø–æ–∑–≤–æ–ª—è–µ—Ç –∑–∞–≥–ª—è–Ω—É—Ç—å –¥–∞–ª—å—à–µ, –Ω–æ –Ω–µ –ø–æ–∑–≤–æ–ª—è–µ—Ç —Ü–µ–ª–∏—Ç—å—Å—è –±–ª–∏–∑–∫–æ).\n–ø—Ä–∏ –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏–∏ –º–æ–∂–Ω–æ —Ü–µ–ª–∏—Ç—å—Å—è –≤ —Ä–∞–º–∫–∞—Ö –≤—å—é–ø–æ—Ä—Ç–∞ –∏ –≤—Ä–∞—â–µ–Ω–∏–µ–º –∫–æ–ª—ë—Å–∏–∫–∞ –¥–≤–∏–≥–∞—Ç—å –∑–æ–Ω—É –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è (–µ—â—ë –¥–∞–ª—å—à–µ —á–µ–º –∑–∞ –≤—å—é–ø–æ—Ä—Ç).\n—á–µ–º –¥–∞–ª—å—à–µ –æ—Ç –∏–≥—Ä–æ–∫–∞ –∑–æ–Ω–∞ –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è - —Ç–µ–º —Å–∏–ª—å–Ω–µ–µ —Ä–∞—Å–∫–∞—á–∏–≤–∞–µ—Ç—Å—è –ø—Ä–∏—Ü–µ–ª (–Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏ –æ–¥–Ω–æ–≥–æ –≤—å—é–ø–æ—Ä—Ç–∞ - –Ω–µ —Å–∏–ª—å–Ω–æ, –Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏ 2 –≤ 2 —Ä–∞–∑–∞ —Å–∏–ª—å–Ω–µ–µ).",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-02-06T20:55:50.417Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01EDhFoKxqhWb9HUrZkYCsYv",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01QDzXoGKkPaWgU5t76N1MeM",
        "name": "Bash",
        "input": {
          "command": "gh api repos/Jhon-Crow/godot-topdown-MVP/pulls/528/comments --paginate",
          "description": "Get PR review comments"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 2,
      "cache_creation_input_tokens": 7120,
      "cache_read_input_tokens": 18845,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 7120
      },
      "output_tokens": 4,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "bcead91c-4a4c-47a5-820d-ddb8b7ec169a"
}
[2026-02-06T20:55:51.579Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_014ZUMUpi8t573vP1Zd268Qy",
        "type": "tool_result",
        "content": "title:\tfeat: add ASVK scope/aiming system (RMB)\nstate:\tDRAFT\nauthor:\tkonard\nlabels:\t\nassignees:\t\nreviewers:\t\nprojects:\t\nmilestone:\t\nnumber:\t528\nurl:\thttps://github.com/Jhon-Crow/godot-topdown-MVP/pull/528\nadditions:\t574\ndeletions:\t2\nauto-merge:\tdisabled\n--\n## Summary\n\nImplements the scoping/aiming feature for the ASVK sniper rifle as requested in the additional requirement of #520 ([comment](https://github.com/Jhon-Crow/godot-topdown-MVP/issues/520#issuecomment-3861795686)).\n\n### Features Implemented\n\n- **RMB scope activation**: Hold RMB to enter scope view, release to exit\n- **Scope crosshair overlay**: Classic sniper scope with circle, crosshair lines, and mil-dot markers (based on reference image from issue)\n- **Camera offset**: When scoped, the camera moves beyond the viewport in the player's aim direction, allowing the player to see and aim further\n- **Mouse wheel zoom**: While scoped, scroll wheel adjusts zoom distance (0.5x to 3.0x viewport multiplier)\n- **Scope sway**: The crosshair and camera sway based on distance from player ‚Äî at 1 viewport distance the sway is moderate, at 2x distance the sway is 2x stronger\n- **Darkened viewport**: Semi-transparent overlay when scoped for immersive feel\n- **Zoom distance indicator**: Shows current zoom level in the scope HUD\n\n### Technical Details\n\n| File | Change |\n|------|--------|\n| `Scripts/Weapons/SniperRifle.cs` | Added scope state management, crosshair overlay creation, camera offset calculation, sway mechanics, zoom control |\n| `Scripts/Characters/Player.cs` | Added `HandleSniperScopeInput()` for RMB scope activation when SniperRifle equipped; added `_UnhandledInput()` for mouse wheel zoom; improved aim direction resolution for SniperRifle |\n| `scripts/ui/armory_menu.gd` | Updated ASVK description to mention scope feature |\n\n### How It Works\n\n1. **Scope activation**: When ASVK is equipped, RMB activates scope instead of grenades (grenades still work with G+RMB when not scoping)\n2. **Camera offset**: `Camera2D.Offset` is adjusted to move the view in the aim direction by `aimDirection * viewportHalfDiagonal * zoomMultiplier`\n3. **Scope sway**: Two overlapping sine waves create natural-feeling scope sway that scales linearly with zoom distance\n4. **Crosshair overlay**: A `CanvasLayer` with programmatically drawn `Line2D` elements creates the scope reticle (outer circle, crosshair lines, mil-dots, scope ring)\n5. **Cleanup**: Scope properly deactivates on weapon removal via `_ExitTree()`\n\n### Scope Sway Formula\n\n```\nswayAmplitude = BaseScopeSwayAmplitude √ó zoomDistance\nswayX = sin(t √ó speed √ó 1.0) √ó amplitude + sin(t √ó speed √ó 2.3) √ó amplitude √ó 0.3\nswayY = sin(t √ó speed √ó 1.4) √ó amplitude + sin(t √ó speed √ó 0.7) √ó amplitude √ó 0.4\n```\n\nAt 1 viewport distance: ~8px sway. At 2 viewports: ~16px sway (2x stronger, as specified in the issue).\n\n## Test Plan\n\n- [ ] Equip ASVK from armory menu\n- [ ] Hold RMB to activate scope ‚Äî verify crosshair overlay appears with circle, lines, and mil-dots\n- [ ] Verify camera moves in aim direction beyond normal viewport\n- [ ] Scroll mouse wheel up while scoped ‚Äî verify zoom increases (camera moves further)\n- [ ] Scroll mouse wheel down ‚Äî verify zoom decreases\n- [ ] Verify scope sway is visible and increases at higher zoom levels\n- [ ] Release RMB ‚Äî verify scope deactivates and camera returns to normal\n- [ ] Verify shooting works while scoped (LMB fires ASVK)\n- [ ] Verify bolt-action sequence still works while scoped\n- [ ] Verify grenades still work when NOT scoped (G+RMB for grenade prep)\n- [ ] Verify other weapons (M16, etc.) are unaffected ‚Äî RMB should still work for grenades\n- [ ] Test in all levels: TestTier, BuildingLevel, CastleLevel, TutorialLevel\n\nFixes #520\n\nü§ñ Generated with [Claude Code](https://claude.com/claude-code)",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "6731388f-7476-41b3-a246-43462d911b57",
  "tool_use_result": {
    "stdout": "title:\tfeat: add ASVK scope/aiming system (RMB)\nstate:\tDRAFT\nauthor:\tkonard\nlabels:\t\nassignees:\t\nreviewers:\t\nprojects:\t\nmilestone:\t\nnumber:\t528\nurl:\thttps://github.com/Jhon-Crow/godot-topdown-MVP/pull/528\nadditions:\t574\ndeletions:\t2\nauto-merge:\tdisabled\n--\n## Summary\n\nImplements the scoping/aiming feature for the ASVK sniper rifle as requested in the additional requirement of #520 ([comment](https://github.com/Jhon-Crow/godot-topdown-MVP/issues/520#issuecomment-3861795686)).\n\n### Features Implemented\n\n- **RMB scope activation**: Hold RMB to enter scope view, release to exit\n- **Scope crosshair overlay**: Classic sniper scope with circle, crosshair lines, and mil-dot markers (based on reference image from issue)\n- **Camera offset**: When scoped, the camera moves beyond the viewport in the player's aim direction, allowing the player to see and aim further\n- **Mouse wheel zoom**: While scoped, scroll wheel adjusts zoom distance (0.5x to 3.0x viewport multiplier)\n- **Scope sway**: The crosshair and camera sway based on distance from player ‚Äî at 1 viewport distance the sway is moderate, at 2x distance the sway is 2x stronger\n- **Darkened viewport**: Semi-transparent overlay when scoped for immersive feel\n- **Zoom distance indicator**: Shows current zoom level in the scope HUD\n\n### Technical Details\n\n| File | Change |\n|------|--------|\n| `Scripts/Weapons/SniperRifle.cs` | Added scope state management, crosshair overlay creation, camera offset calculation, sway mechanics, zoom control |\n| `Scripts/Characters/Player.cs` | Added `HandleSniperScopeInput()` for RMB scope activation when SniperRifle equipped; added `_UnhandledInput()` for mouse wheel zoom; improved aim direction resolution for SniperRifle |\n| `scripts/ui/armory_menu.gd` | Updated ASVK description to mention scope feature |\n\n### How It Works\n\n1. **Scope activation**: When ASVK is equipped, RMB activates scope instead of grenades (grenades still work with G+RMB when not scoping)\n2. **Camera offset**: `Camera2D.Offset` is adjusted to move the view in the aim direction by `aimDirection * viewportHalfDiagonal * zoomMultiplier`\n3. **Scope sway**: Two overlapping sine waves create natural-feeling scope sway that scales linearly with zoom distance\n4. **Crosshair overlay**: A `CanvasLayer` with programmatically drawn `Line2D` elements creates the scope reticle (outer circle, crosshair lines, mil-dots, scope ring)\n5. **Cleanup**: Scope properly deactivates on weapon removal via `_ExitTree()`\n\n### Scope Sway Formula\n\n```\nswayAmplitude = BaseScopeSwayAmplitude √ó zoomDistance\nswayX = sin(t √ó speed √ó 1.0) √ó amplitude + sin(t √ó speed √ó 2.3) √ó amplitude √ó 0.3\nswayY = sin(t √ó speed √ó 1.4) √ó amplitude + sin(t √ó speed √ó 0.7) √ó amplitude √ó 0.4\n```\n\nAt 1 viewport distance: ~8px sway. At 2 viewports: ~16px sway (2x stronger, as specified in the issue).\n\n## Test Plan\n\n- [ ] Equip ASVK from armory menu\n- [ ] Hold RMB to activate scope ‚Äî verify crosshair overlay appears with circle, lines, and mil-dots\n- [ ] Verify camera moves in aim direction beyond normal viewport\n- [ ] Scroll mouse wheel up while scoped ‚Äî verify zoom increases (camera moves further)\n- [ ] Scroll mouse wheel down ‚Äî verify zoom decreases\n- [ ] Verify scope sway is visible and increases at higher zoom levels\n- [ ] Release RMB ‚Äî verify scope deactivates and camera returns to normal\n- [ ] Verify shooting works while scoped (LMB fires ASVK)\n- [ ] Verify bolt-action sequence still works while scoped\n- [ ] Verify grenades still work when NOT scoped (G+RMB for grenade prep)\n- [ ] Verify other weapons (M16, etc.) are unaffected ‚Äî RMB should still work for grenades\n- [ ] Test in all levels: TestTier, BuildingLevel, CastleLevel, TutorialLevel\n\nFixes #520\n\nü§ñ Generated with [Claude Code](https://claude.com/claude-code)",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-02-06T20:55:52.717Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_012VKKSw4EcSqCVDmKja7BUz",
        "type": "tool_result",
        "content": "[{\"url\":\"https://api.github.com/repos/Jhon-Crow/godot-topdown-MVP/issues/comments/3862412730\",\"html_url\":\"https://github.com/Jhon-Crow/godot-topdown-MVP/pull/528#issuecomment-3862412730\",\"issue_url\":\"https://api.github.com/repos/Jhon-Crow/godot-topdown-MVP/issues/528\",\"id\":3862412730,\"node_id\":\"IC_kwDOQ35BQ87mN726\",\"user\":{\"login\":\"konard\",\"id\":1431904,\"node_id\":\"MDQ6VXNlcjE0MzE5MDQ=\",\"avatar_url\":\"https://avatars.githubusercontent.com/u/1431904?v=4\",\"gravatar_id\":\"\",\"url\":\"https://api.github.com/users/konard\",\"html_url\":\"https://github.com/konard\",\"followers_url\":\"https://api.github.com/users/konard/followers\",\"following_url\":\"https://api.github.com/users/konard/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/konard/gists{/gist_id}\",\"starred_url\":\"https://api.github.com/users/konard/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/konard/subscriptions\",\"organizations_url\":\"https://api.github.com/users/konard/orgs\",\"repos_url\":\"https://api.github.com/users/konard/repos\",\"events_url\":\"https://api.github.com/users/konard/events{/privacy}\",\"received_events_url\":\"https://api.github.com/users/konard/received_events\",\"type\":\"User\",\"user_view_type\":\"public\",\"site_admin\":false},\"created_at\":\"2026-02-06T20:25:51Z\",\"updated_at\":\"2026-02-06T20:25:51Z\",\"body\":\"## ü§ñ Solution Draft Log\\nThis log file contains the complete execution trace of the AI solution draft process.\\n\\nüí∞ **Cost estimation:**\\n- Public pricing estimate: $6.806382 USD\\n- Calculated by Anthropic: $12.189245 USD\\n- Difference: $5.382863 (+79.09%)\\nüìé **Log file uploaded as Gist** (1809KB)\\nüîó [View complete solution draft log](https://gist.githubusercontent.com/konard/d34153552988e046401d85e4340f9031/raw/e5dc36ca041dc71e9497c6243fa7da64725b75f1/solution-draft-log-pr-1770409545947.txt)\\n---\\n*Now working session is ended, feel free to review and add any feedback on the solution draft.*\",\"author_association\":\"CONTRIBUTOR\",\"pin\":null,\"reactions\":{\"url\":\"https://api.github.com/repos/Jhon-Crow/godot-topdown-MVP/issues/comments/3862412730/reactions\",\"total_count\":0,\"+1\":0,\"-1\":0,\"laugh\":0,\"hooray\":0,\"confused\":0,\"heart\":0,\"rocket\":0,\"eyes\":0},\"performed_via_github_app\":null},{\"url\":\"https://api.github.com/repos/Jhon-Crow/godot-topdown-MVP/issues/comments/3862511045\",\"html_url\":\"https://github.com/Jhon-Crow/godot-topdown-MVP/pull/528#issuecomment-3862511045\",\"issue_url\":\"https://api.github.com/repos/Jhon-Crow/godot-topdown-MVP/issues/528\",\"id\":3862511045,\"node_id\":\"IC_kwDOQ35BQ87mOT3F\",\"user\":{\"login\":\"Jhon-Crow\",\"id\":133867474,\"node_id\":\"U_kgDOB_qn0g\",\"avatar_url\":\"https://avatars.githubusercontent.com/u/133867474?v=4\",\"gravatar_id\":\"\",\"url\":\"https://api.github.com/users/Jhon-Crow\",\"html_url\":\"https://github.com/Jhon-Crow\",\"followers_url\":\"https://api.github.com/users/Jhon-Crow/followers\",\"following_url\":\"https://api.github.com/users/Jhon-Crow/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/Jhon-Crow/gists{/gist_id}\",\"starred_url\":\"https://api.github.com/users/Jhon-Crow/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/Jhon-Crow/subscriptions\",\"organizations_url\":\"https://api.github.com/users/Jhon-Crow/orgs\",\"repos_url\":\"https://api.github.com/users/Jhon-Crow/repos\",\"events_url\":\"https://api.github.com/users/Jhon-Crow/events{/privacy}\",\"received_events_url\":\"https://api.github.com/users/Jhon-Crow/received_events\",\"type\":\"User\",\"user_view_type\":\"public\",\"site_admin\":false},\"created_at\":\"2026-02-06T20:51:05Z\",\"updated_at\":\"2026-02-06T20:54:54Z\",\"body\":\"1. –≤ —Ä–µ–∂–∏–º–µ –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –Ω–µ–º–Ω–æ–≥–æ (—Ç—Ä–µ—Ç—å –≤—å—é–ø–æ—Ä—Ç–∞ –ø—Ä–∏–º–µ—Ä–Ω–æ) –ø–µ—Ä–µ–º–µ—â–∞—Ç—å—Å—è –¥–∞–ª—å—à–µ/–±–ª–∏–∂–µ.\\r\\n2. –ø—É–ª–∏ –¥–æ–ª–∂–Ω—ã –ª–µ—Ç–µ—Ç—å –≤ —Ü–µ–Ω—Ç—Ä –ø—Ä–∏—Ü–µ–ª–∞ (—Å–µ–π—á–∞—Å –ª–µ—Ç—è—Ç –Ω–µ —Ç—É–¥–∞)\\r\\n3. —Å–¥–µ–ª–∞–π –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –¥–∞–ª—å–Ω–æ—Å—Ç—å –ø—Ä–∏—Ü–µ–ª–∞ –µ—â—ë –Ω–∞ –ø–æ–ª –≤—å—é–ø–æ—Ä—Ç–∞ –¥–∞–ª—å—à–µ.\\r\\n\",\"author_association\":\"OWNER\",\"pin\":null,\"reactions\":{\"url\":\"https://api.github.com/repos/Jhon-Crow/godot-topdown-MVP/issues/comments/3862511045/reactions\",\"total_count\":0,\"+1\":0,\"-1\":0,\"laugh\":0,\"hooray\":0,\"confused\":0,\"heart\":0,\"rocket\":0,\"eyes\":0},\"performed_via_github_app\":null},{\"url\":\"https://api.github.com/repos/Jhon-Crow/godot-topdown-MVP/issues/comments/3862526072\",\"html_url\":\"https://github.com/Jhon-Crow/godot-topdown-MVP/pull/528#issuecomment-3862526072\",\"issue_url\":\"https://api.github.com/repos/Jhon-Crow/godot-topdown-MVP/issues/528\",\"id\":3862526072,\"node_id\":\"IC_kwDOQ35BQ87mOXh4\",\"user\":{\"login\":\"konard\",\"id\":1431904,\"node_id\":\"MDQ6VXNlcjE0MzE5MDQ=\",\"avatar_url\":\"https://avatars.githubusercontent.com/u/1431904?v=4\",\"gravatar_id\":\"\",\"url\":\"https://api.github.com/users/konard\",\"html_url\":\"https://github.com/konard\",\"followers_url\":\"https://api.github.com/users/konard/followers\",\"following_url\":\"https://api.github.com/users/konard/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/konard/gists{/gist_id}\",\"starred_url\":\"https://api.github.com/users/konard/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/konard/subscriptions\",\"organizations_url\":\"https://api.github.com/users/konard/orgs\",\"repos_url\":\"https://api.github.com/users/konard/repos\",\"events_url\":\"https://api.github.com/users/konard/events{/privacy}\",\"received_events_url\":\"https://api.github.com/users/konard/received_events\",\"type\":\"User\",\"user_view_type\":\"public\",\"site_admin\":false},\"created_at\":\"2026-02-06T20:55:33Z\",\"updated_at\":\"2026-02-06T20:55:33Z\",\"body\":\"ü§ñ **AI Work Session Started**\\n\\nStarting automated work session at 2026-02-06T20:55:31.822Z\\n\\nThe PR has been converted to draft mode while work is in progress.\\n\\n_This comment marks the beginning of an AI work session. Please wait for the session to finish, and provide your feedback._\",\"author_association\":\"CONTRIBUTOR\",\"pin\":null,\"reactions\":{\"url\":\"https://api.github.com/repos/Jhon-Crow/godot-topdown-MVP/issues/comments/3862526072/reactions\",\"total_count\":0,\"+1\":0,\"-1\":0,\"laugh\":0,\"hooray\":0,\"confused\":0,\"heart\":0,\"rocket\":0,\"eyes\":0},\"performed_via_github_app\":null}]",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "96db96fd-4c5d-4078-9faf-21442a9b9907",
  "tool_use_result": {
    "stdout": "[{\"url\":\"https://api.github.com/repos/Jhon-Crow/godot-topdown-MVP/issues/comments/3862412730\",\"html_url\":\"https://github.com/Jhon-Crow/godot-topdown-MVP/pull/528#issuecomment-3862412730\",\"issue_url\":\"https://api.github.com/repos/Jhon-Crow/godot-topdown-MVP/issues/528\",\"id\":3862412730,\"node_id\":\"IC_kwDOQ35BQ87mN726\",\"user\":{\"login\":\"konard\",\"id\":1431904,\"node_id\":\"MDQ6VXNlcjE0MzE5MDQ=\",\"avatar_url\":\"https://avatars.githubusercontent.com/u/1431904?v=4\",\"gravatar_id\":\"\",\"url\":\"https://api.github.com/users/konard\",\"html_url\":\"https://github.com/konard\",\"followers_url\":\"https://api.github.com/users/konard/followers\",\"following_url\":\"https://api.github.com/users/konard/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/konard/gists{/gist_id}\",\"starred_url\":\"https://api.github.com/users/konard/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/konard/subscriptions\",\"organizations_url\":\"https://api.github.com/users/konard/orgs\",\"repos_url\":\"https://api.github.com/users/konard/repos\",\"events_url\":\"https://api.github.com/users/konard/events{/privacy}\",\"received_events_url\":\"https://api.github.com/users/konard/received_events\",\"type\":\"User\",\"user_view_type\":\"public\",\"site_admin\":false},\"created_at\":\"2026-02-06T20:25:51Z\",\"updated_at\":\"2026-02-06T20:25:51Z\",\"body\":\"## ü§ñ Solution Draft Log\\nThis log file contains the complete execution trace of the AI solution draft process.\\n\\nüí∞ **Cost estimation:**\\n- Public pricing estimate: $6.806382 USD\\n- Calculated by Anthropic: $12.189245 USD\\n- Difference: $5.382863 (+79.09%)\\nüìé **Log file uploaded as Gist** (1809KB)\\nüîó [View complete solution draft log](https://gist.githubusercontent.com/konard/d34153552988e046401d85e4340f9031/raw/e5dc36ca041dc71e9497c6243fa7da64725b75f1/solution-draft-log-pr-1770409545947.txt)\\n---\\n*Now working session is ended, feel free to review and add any feedback on the solution draft.*\",\"author_association\":\"CONTRIBUTOR\",\"pin\":null,\"reactions\":{\"url\":\"https://api.github.com/repos/Jhon-Crow/godot-topdown-MVP/issues/comments/3862412730/reactions\",\"total_count\":0,\"+1\":0,\"-1\":0,\"laugh\":0,\"hooray\":0,\"confused\":0,\"heart\":0,\"rocket\":0,\"eyes\":0},\"performed_via_github_app\":null},{\"url\":\"https://api.github.com/repos/Jhon-Crow/godot-topdown-MVP/issues/comments/3862511045\",\"html_url\":\"https://github.com/Jhon-Crow/godot-topdown-MVP/pull/528#issuecomment-3862511045\",\"issue_url\":\"https://api.github.com/repos/Jhon-Crow/godot-topdown-MVP/issues/528\",\"id\":3862511045,\"node_id\":\"IC_kwDOQ35BQ87mOT3F\",\"user\":{\"login\":\"Jhon-Crow\",\"id\":133867474,\"node_id\":\"U_kgDOB_qn0g\",\"avatar_url\":\"https://avatars.githubusercontent.com/u/133867474?v=4\",\"gravatar_id\":\"\",\"url\":\"https://api.github.com/users/Jhon-Crow\",\"html_url\":\"https://github.com/Jhon-Crow\",\"followers_url\":\"https://api.github.com/users/Jhon-Crow/followers\",\"following_url\":\"https://api.github.com/users/Jhon-Crow/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/Jhon-Crow/gists{/gist_id}\",\"starred_url\":\"https://api.github.com/users/Jhon-Crow/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/Jhon-Crow/subscriptions\",\"organizations_url\":\"https://api.github.com/users/Jhon-Crow/orgs\",\"repos_url\":\"https://api.github.com/users/Jhon-Crow/repos\",\"events_url\":\"https://api.github.com/users/Jhon-Crow/events{/privacy}\",\"received_events_url\":\"https://api.github.com/users/Jhon-Crow/received_events\",\"type\":\"User\",\"user_view_type\":\"public\",\"site_admin\":false},\"created_at\":\"2026-02-06T20:51:05Z\",\"updated_at\":\"2026-02-06T20:54:54Z\",\"body\":\"1. –≤ —Ä–µ–∂–∏–º–µ –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –Ω–µ–º–Ω–æ–≥–æ (—Ç—Ä–µ—Ç—å –≤—å—é–ø–æ—Ä—Ç–∞ –ø—Ä–∏–º–µ—Ä–Ω–æ) –ø–µ—Ä–µ–º–µ—â–∞—Ç—å—Å—è –¥–∞–ª—å—à–µ/–±–ª–∏–∂–µ.\\r\\n2. –ø—É–ª–∏ –¥–æ–ª–∂–Ω—ã –ª–µ—Ç–µ—Ç—å –≤ —Ü–µ–Ω—Ç—Ä –ø—Ä–∏—Ü–µ–ª–∞ (—Å–µ–π—á–∞—Å –ª–µ—Ç—è—Ç –Ω–µ —Ç—É–¥–∞)\\r\\n3. —Å–¥–µ–ª–∞–π –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –¥–∞–ª—å–Ω–æ—Å—Ç—å –ø—Ä–∏—Ü–µ–ª–∞ –µ—â—ë –Ω–∞ –ø–æ–ª –≤—å—é–ø–æ—Ä—Ç–∞ –¥–∞–ª—å—à–µ.\\r\\n\",\"author_association\":\"OWNER\",\"pin\":null,\"reactions\":{\"url\":\"https://api.github.com/repos/Jhon-Crow/godot-topdown-MVP/issues/comments/3862511045/reactions\",\"total_count\":0,\"+1\":0,\"-1\":0,\"laugh\":0,\"hooray\":0,\"confused\":0,\"heart\":0,\"rocket\":0,\"eyes\":0},\"performed_via_github_app\":null},{\"url\":\"https://api.github.com/repos/Jhon-Crow/godot-topdown-MVP/issues/comments/3862526072\",\"html_url\":\"https://github.com/Jhon-Crow/godot-topdown-MVP/pull/528#issuecomment-3862526072\",\"issue_url\":\"https://api.github.com/repos/Jhon-Crow/godot-topdown-MVP/issues/528\",\"id\":3862526072,\"node_id\":\"IC_kwDOQ35BQ87mOXh4\",\"user\":{\"login\":\"konard\",\"id\":1431904,\"node_id\":\"MDQ6VXNlcjE0MzE5MDQ=\",\"avatar_url\":\"https://avatars.githubusercontent.com/u/1431904?v=4\",\"gravatar_id\":\"\",\"url\":\"https://api.github.com/users/konard\",\"html_url\":\"https://github.com/konard\",\"followers_url\":\"https://api.github.com/users/konard/followers\",\"following_url\":\"https://api.github.com/users/konard/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/konard/gists{/gist_id}\",\"starred_url\":\"https://api.github.com/users/konard/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/konard/subscriptions\",\"organizations_url\":\"https://api.github.com/users/konard/orgs\",\"repos_url\":\"https://api.github.com/users/konard/repos\",\"events_url\":\"https://api.github.com/users/konard/events{/privacy}\",\"received_events_url\":\"https://api.github.com/users/konard/received_events\",\"type\":\"User\",\"user_view_type\":\"public\",\"site_admin\":false},\"created_at\":\"2026-02-06T20:55:33Z\",\"updated_at\":\"2026-02-06T20:55:33Z\",\"body\":\"ü§ñ **AI Work Session Started**\\n\\nStarting automated work session at 2026-02-06T20:55:31.822Z\\n\\nThe PR has been converted to draft mode while work is in progress.\\n\\n_This comment marks the beginning of an AI work session. Please wait for the session to finish, and provide your feedback._\",\"author_association\":\"CONTRIBUTOR\",\"pin\":null,\"reactions\":{\"url\":\"https://api.github.com/repos/Jhon-Crow/godot-topdown-MVP/issues/comments/3862526072/reactions\",\"total_count\":0,\"+1\":0,\"-1\":0,\"laugh\":0,\"hooray\":0,\"confused\":0,\"heart\":0,\"rocket\":0,\"eyes\":0},\"performed_via_github_app\":null}]",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-02-06T20:55:53.552Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01QDzXoGKkPaWgU5t76N1MeM",
        "type": "tool_result",
        "content": "[]",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "dc69bc40-678b-4630-8ecd-093ab5b2f211",
  "tool_use_result": {
    "stdout": "[]",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-02-06T20:55:58.257Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01QfHkThRoFL2De5tK8YLpZm",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now I understand the situation. The PR owner (Jhon-Crow) left 3 feedback items that need to be addressed:\n\n1. **In scope mode, allow slight movement (about 1/3 viewport) closer/further** - ability to move within the scope view\n2. **Bullets should fly to the center of the crosshair** (currently they don't go there)\n3. **Minimum scope distance should be half a viewport further**\n\nLet me also check the issue comments and the current state of the code."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 4531,
      "cache_read_input_tokens": 25965,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 4531
      },
      "output_tokens": 1,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "b6cdd90c-d63c-417b-99d6-0a7165f6beef"
}
[2026-02-06T20:55:59.466Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01QfHkThRoFL2De5tK8YLpZm",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01W6oH3iXj6BcTy17BuNvVPV",
        "name": "Bash",
        "input": {
          "command": "gh api repos/Jhon-Crow/godot-topdown-MVP/issues/520/comments --paginate | jq '.[].body' -r",
          "description": "Get issue comments"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 4531,
      "cache_read_input_tokens": 25965,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 4531
      },
      "output_tokens": 1,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "3a5e5a41-056a-48a3-8a9e-10986e971c1d"
}
[2026-02-06T20:56:00.804Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01QfHkThRoFL2De5tK8YLpZm",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01Vg33mSR8uzo3Miz24Bwp8K",
        "name": "Bash",
        "input": {
          "command": "git log --oneline -10",
          "description": "Check recent commits"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 4531,
      "cache_read_input_tokens": 25965,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 4531
      },
      "output_tokens": 1,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "6235e5b2-0552-4beb-b4c6-90a2dff58946"
}
[2026-02-06T20:56:01.674Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01W6oH3iXj6BcTy17BuNvVPV",
        "type": "tool_result",
        "content": "—Å–µ–π—á–∞—Å —Ä–µ–∞–ª–∏–∑—É–π –æ—Å–Ω–æ–≤–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª –±–µ–∑ –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è\n—Ç–µ–ø–µ—Ä—å –≤—ã–ø–æ–ª–Ω–∏ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –ø—É–Ω–∫—Ç\n—Ç–∞–∫ –∂–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏–µ –Ω–∞ RMB - –ø—Ä–∏ –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏–∏ –Ω–∞ —ç–∫—Ä–∞–Ω –Ω–∞–∫–ª–∞–¥—ã–≤–∞–µ—Ç—Å—è \"–ø—Ä–∏—Ü–µ–ª\":\n<img width=\"820\" height=\"654\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/a1228111-e4f4-4e3c-8457-9d1a1ae3bd29\" />\n–ø—Ä–∏ —ç—Ç–æ–º –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏–µ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –ø–æ –∑–æ–Ω–µ –∑–∞ –≤—å—é–ø–æ—Ä—Ç–æ–º –≤ —Ç–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏, –∫—É–¥–∞ —Å–º–æ—Ç—Ä–µ–ª –∏–≥—Ä–æ–∫ (–ø–æ–∑–≤–æ–ª—è–µ—Ç –∑–∞–≥–ª—è–Ω—É—Ç—å –¥–∞–ª—å—à–µ, –Ω–æ –Ω–µ –ø–æ–∑–≤–æ–ª—è–µ—Ç —Ü–µ–ª–∏—Ç—å—Å—è –±–ª–∏–∑–∫–æ).\n–ø—Ä–∏ –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏–∏ –º–æ–∂–Ω–æ —Ü–µ–ª–∏—Ç—å—Å—è –≤ —Ä–∞–º–∫–∞—Ö –≤—å—é–ø–æ—Ä—Ç–∞ –∏ –≤—Ä–∞—â–µ–Ω–∏–µ–º –∫–æ–ª—ë—Å–∏–∫–∞ –¥–≤–∏–≥–∞—Ç—å –∑–æ–Ω—É –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è (–µ—â—ë –¥–∞–ª—å—à–µ —á–µ–º –∑–∞ –≤—å—é–ø–æ—Ä—Ç).\n—á–µ–º –¥–∞–ª—å—à–µ –æ—Ç –∏–≥—Ä–æ–∫–∞ –∑–æ–Ω–∞ –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è - —Ç–µ–º —Å–∏–ª—å–Ω–µ–µ —Ä–∞—Å–∫–∞—á–∏–≤–∞–µ—Ç—Å—è –ø—Ä–∏—Ü–µ–ª (–Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏ –æ–¥–Ω–æ–≥–æ –≤—å—é–ø–æ—Ä—Ç–∞ - –Ω–µ —Å–∏–ª—å–Ω–æ, –Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏ 2 –≤ 2 —Ä–∞–∑–∞ —Å–∏–ª—å–Ω–µ–µ).",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "59bb6f10-2527-40d1-8d32-96ee0f47f4e3",
  "tool_use_result": {
    "stdout": "—Å–µ–π—á–∞—Å —Ä–µ–∞–ª–∏–∑—É–π –æ—Å–Ω–æ–≤–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª –±–µ–∑ –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è\n—Ç–µ–ø–µ—Ä—å –≤—ã–ø–æ–ª–Ω–∏ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –ø—É–Ω–∫—Ç\n—Ç–∞–∫ –∂–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏–µ –Ω–∞ RMB - –ø—Ä–∏ –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏–∏ –Ω–∞ —ç–∫—Ä–∞–Ω –Ω–∞–∫–ª–∞–¥—ã–≤–∞–µ—Ç—Å—è \"–ø—Ä–∏—Ü–µ–ª\":\n<img width=\"820\" height=\"654\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/a1228111-e4f4-4e3c-8457-9d1a1ae3bd29\" />\n–ø—Ä–∏ —ç—Ç–æ–º –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏–µ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –ø–æ –∑–æ–Ω–µ –∑–∞ –≤—å—é–ø–æ—Ä—Ç–æ–º –≤ —Ç–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏, –∫—É–¥–∞ —Å–º–æ—Ç—Ä–µ–ª –∏–≥—Ä–æ–∫ (–ø–æ–∑–≤–æ–ª—è–µ—Ç –∑–∞–≥–ª—è–Ω—É—Ç—å –¥–∞–ª—å—à–µ, –Ω–æ –Ω–µ –ø–æ–∑–≤–æ–ª—è–µ—Ç —Ü–µ–ª–∏—Ç—å—Å—è –±–ª–∏–∑–∫–æ).\n–ø—Ä–∏ –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏–∏ –º–æ–∂–Ω–æ —Ü–µ–ª–∏—Ç—å—Å—è –≤ —Ä–∞–º–∫–∞—Ö –≤—å—é–ø–æ—Ä—Ç–∞ –∏ –≤—Ä–∞—â–µ–Ω–∏–µ–º –∫–æ–ª—ë—Å–∏–∫–∞ –¥–≤–∏–≥–∞—Ç—å –∑–æ–Ω—É –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è (–µ—â—ë –¥–∞–ª—å—à–µ —á–µ–º –∑–∞ –≤—å—é–ø–æ—Ä—Ç).\n—á–µ–º –¥–∞–ª—å—à–µ –æ—Ç –∏–≥—Ä–æ–∫–∞ –∑–æ–Ω–∞ –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è - —Ç–µ–º —Å–∏–ª—å–Ω–µ–µ —Ä–∞—Å–∫–∞—á–∏–≤–∞–µ—Ç—Å—è –ø—Ä–∏—Ü–µ–ª (–Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏ –æ–¥–Ω–æ–≥–æ –≤—å—é–ø–æ—Ä—Ç–∞ - –Ω–µ —Å–∏–ª—å–Ω–æ, –Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏ 2 –≤ 2 —Ä–∞–∑–∞ —Å–∏–ª—å–Ω–µ–µ).",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-02-06T20:56:01.675Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01Vg33mSR8uzo3Miz24Bwp8K",
        "type": "tool_result",
        "content": "bcb21ec Revert \"Initial commit with task details\"\n9ce3def feat: add ASVK scope/aiming system (RMB) with crosshair overlay, camera offset, zoom, and sway\ncf7ebde Initial commit with task details\n5a5d42c –¥–æ–±–∞–≤–∏–ª –∑–≤—É–∫–∏ –≤—ã—Å—Ç—Ä–µ–ª–∞ –∏ –∑–∞—Ä—è–¥–∫–∏ ASVK\n5e0723c Merge pull request #521 from konard/issue-520-a11002b682e7\na6c22bb Merge pull request #519 from konard/issue-518-1c6df112a9a6\n044f5ae Merge pull request #509 from konard/issue-506-7515302f17ea\nda0707a fix: register sniper in GameManager and all levels so ASVK can be selected\n70f2c8f Revert \"Initial commit with task details\"\n0db689f feat: add SniperBullet that penetrates through enemies and walls",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "3da075d9-796a-4a8f-a2ce-56f1c70f0df2",
  "tool_use_result": {
    "stdout": "bcb21ec Revert \"Initial commit with task details\"\n9ce3def feat: add ASVK scope/aiming system (RMB) with crosshair overlay, camera offset, zoom, and sway\ncf7ebde Initial commit with task details\n5a5d42c –¥–æ–±–∞–≤–∏–ª –∑–≤—É–∫–∏ –≤—ã—Å—Ç—Ä–µ–ª–∞ –∏ –∑–∞—Ä—è–¥–∫–∏ ASVK\n5e0723c Merge pull request #521 from konard/issue-520-a11002b682e7\na6c22bb Merge pull request #519 from konard/issue-518-1c6df112a9a6\n044f5ae Merge pull request #509 from konard/issue-506-7515302f17ea\nda0707a fix: register sniper in GameManager and all levels so ASVK can be selected\n70f2c8f Revert \"Initial commit with task details\"\n0db689f feat: add SniperBullet that penetrates through enemies and walls",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-02-06T20:56:01.689Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01QfHkThRoFL2De5tK8YLpZm",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01Jdytbfdbwfb9N8hUwnF824",
        "name": "Bash",
        "input": {
          "command": "git branch --show-current",
          "description": "Verify current branch"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 4531,
      "cache_read_input_tokens": 25965,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 4531
      },
      "output_tokens": 1,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "955366a5-8c37-424a-b04b-39f30006097d"
}
[2026-02-06T20:56:01.781Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01Jdytbfdbwfb9N8hUwnF824",
        "type": "tool_result",
        "content": "issue-520-2af4a666a08c",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "a0aedeea-3a9c-427c-ab5d-fdb4446ebe93",
  "tool_use_result": {
    "stdout": "issue-520-2af4a666a08c",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-02-06T20:56:04.228Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01V1vQUezGyECoJNTUanPWGW",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Good, I'm on the correct branch. Let me read the current scope-related code files to understand the implementation."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 996,
      "cache_read_input_tokens": 30496,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 996
      },
      "output_tokens": 1,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "4207e495-6072-45da-babc-a1a7c1b4e69a"
}
[2026-02-06T20:56:08.005Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01V1vQUezGyECoJNTUanPWGW",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_015CAs99779TjZzwDjJMNmbZ",
        "name": "TodoWrite",
        "input": {
          "todos": [
            {
              "content": "Read and understand current SniperRifle.cs scope implementation",
              "status": "in_progress",
              "activeForm": "Reading SniperRifle.cs scope implementation"
            },
            {
              "content": "Read and understand Player.cs scope input handling",
              "status": "pending",
              "activeForm": "Reading Player.cs scope input handling"
            },
            {
              "content": "Fix #1: Allow slight movement (~1/3 viewport) closer/further while scoped",
              "status": "pending",
              "activeForm": "Implementing scope movement closer/further"
            },
            {
              "content": "Fix #2: Make bullets fly to the center of the crosshair",
              "status": "pending",
              "activeForm": "Fixing bullet aim direction to match crosshair center"
            },
            {
              "content": "Fix #3: Move minimum scope distance half a viewport further",
              "status": "pending",
              "activeForm": "Increasing minimum scope distance by half viewport"
            },
            {
              "content": "Test all changes locally and verify no regressions",
              "status": "pending",
              "activeForm": "Testing changes locally"
            },
            {
              "content": "Commit, push, and update PR description",
              "status": "pending",
              "activeForm": "Committing and pushing changes"
            }
          ]
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 996,
      "cache_read_input_tokens": 30496,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 996
      },
      "output_tokens": 1,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "1e838ed5-094b-41c5-982a-c0ca60e5c1c1"
}
[2026-02-06T20:56:08.013Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_015CAs99779TjZzwDjJMNmbZ",
        "type": "tool_result",
        "content": "Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "b2b2a5a7-0d73-48b2-a906-c5911a5a9bfb",
  "tool_use_result": {
    "oldTodos": [],
    "newTodos": [
      {
        "content": "Read and understand current SniperRifle.cs scope implementation",
        "status": "in_progress",
        "activeForm": "Reading SniperRifle.cs scope implementation"
      },
      {
        "content": "Read and understand Player.cs scope input handling",
        "status": "pending",
        "activeForm": "Reading Player.cs scope input handling"
      },
      {
        "content": "Fix #1: Allow slight movement (~1/3 viewport) closer/further while scoped",
        "status": "pending",
        "activeForm": "Implementing scope movement closer/further"
      },
      {
        "content": "Fix #2: Make bullets fly to the center of the crosshair",
        "status": "pending",
        "activeForm": "Fixing bullet aim direction to match crosshair center"
      },
      {
        "content": "Fix #3: Move minimum scope distance half a viewport further",
        "status": "pending",
        "activeForm": "Increasing minimum scope distance by half viewport"
      },
      {
        "content": "Test all changes locally and verify no regressions",
        "status": "pending",
        "activeForm": "Testing changes locally"
      },
      {
        "content": "Commit, push, and update PR description",
        "status": "pending",
        "activeForm": "Committing and pushing changes"
      }
    ]
  }
}
[2026-02-06T20:56:11.225Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_014diDpLsL4AokM4qGdtxzpS",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_017DA3HrqnzNpBxKctonm1Ak",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 389,
      "cache_read_input_tokens": 31492,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 389
      },
      "output_tokens": 25,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "5b7a0ecf-d27c-47bf-a905-27a135635c15"
}
[2026-02-06T20:56:11.676Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_017DA3HrqnzNpBxKctonm1Ak",
        "type": "tool_result",
        "content": "     1‚Üíusing Godot;\n     2‚Üíusing GodotTopDownTemplate.AbstractClasses;\n     3‚Üíusing GodotTopDownTemplate.Projectiles;\n     4‚Üí\n     5‚Üínamespace GodotTopDownTemplate.Weapons;\n     6‚Üí\n     7‚Üí/// <summary>\n     8‚Üí/// Bolt-action charging state for the ASVK sniper rifle.\n     9‚Üí/// Before each shot, the player must complete a 4-step bolt-action sequence:\n    10‚Üí/// Down (pull bolt back) ‚Üí Left (open bolt) ‚Üí Down (close bolt) ‚Üí Up (chamber round)\n    11‚Üí/// </summary>\n    12‚Üípublic enum BoltActionStep\n    13‚Üí{\n    14‚Üí    /// <summary>\n    15‚Üí    /// Bolt is ready - weapon can fire. After firing, transitions to NeedsBoltCycle.\n    16‚Üí    /// </summary>\n    17‚Üí    Ready,\n    18‚Üí\n    19‚Üí    /// <summary>\n    20‚Üí    /// Just fired - needs bolt cycling before next shot.\n    21‚Üí    /// Waiting for Down arrow (pull bolt back).\n    22‚Üí    /// </summary>\n    23‚Üí    NeedsBoltCycle,\n    24‚Üí\n    25‚Üí    /// <summary>\n    26‚Üí    /// Step 1 complete (bolt pulled back). Waiting for Left arrow (open bolt).\n    27‚Üí    /// </summary>\n    28‚Üí    WaitOpenBolt,\n    29‚Üí\n    30‚Üí    /// <summary>\n    31‚Üí    /// Step 2 complete (bolt opened). Waiting for Down arrow (close bolt).\n    32‚Üí    /// </summary>\n    33‚Üí    WaitCloseBolt,\n    34‚Üí\n    35‚Üí    /// <summary>\n    36‚Üí    /// Step 3 complete (bolt closed). Waiting for Up arrow (chamber round).\n    37‚Üí    /// </summary>\n    38‚Üí    WaitChamberRound\n    39‚Üí}\n    40‚Üí\n    41‚Üí/// <summary>\n    42‚Üí/// ASVK sniper rifle - heavy anti-materiel bolt-action rifle.\n    43‚Üí/// Features:\n    44‚Üí/// - 12.7x108mm ammunition dealing 50 damage per shot\n    45‚Üí/// - Penetrates through 2 walls and through enemies\n    46‚Üí/// - Instant bullet speed with smoky dissipating tracer trail\n    47‚Üí/// - Very high turn sensitivity\n    48‚Üí/// - 5-round magazine with M16-style swap reload\n    49‚Üí/// - Single-shot bolt-action with manual charging sequence (Down‚ÜíLeft‚ÜíDown‚ÜíUp)\n    50‚Üí/// - Red laser sight for aiming\n    51‚Üí/// Reference: ASVK (–ê–°–í–ö) anti-materiel sniper rifle\n    52‚Üí/// </summary>\n    53‚Üípublic partial class SniperRifle : BaseWeapon\n    54‚Üí{\n    55‚Üí    // =========================================================================\n    56‚Üí    // Bolt-Action State\n    57‚Üí    // =========================================================================\n    58‚Üí\n    59‚Üí    /// <summary>\n    60‚Üí    /// Current bolt-action charging step.\n    61‚Üí    /// </summary>\n    62‚Üí    private BoltActionStep _boltStep = BoltActionStep.Ready;\n    63‚Üí\n    64‚Üí    /// <summary>\n    65‚Üí    /// Whether the bolt action is ready to fire (chambered).\n    66‚Üí    /// Initially true so first shot can be fired immediately.\n    67‚Üí    /// </summary>\n    68‚Üí    public bool IsBoltReady => _boltStep == BoltActionStep.Ready;\n    69‚Üí\n    70‚Üí    /// <summary>\n    71‚Üí    /// Whether the weapon needs bolt cycling before it can fire again.\n    72‚Üí    /// </summary>\n    73‚Üí    public bool NeedsBoltCycle => _boltStep != BoltActionStep.Ready;\n    74‚Üí\n    75‚Üí    /// <summary>\n    76‚Üí    /// Signal emitted when bolt-action step changes.\n    77‚Üí    /// </summary>\n    78‚Üí    [Signal]\n    79‚Üí    public delegate void BoltStepChangedEventHandler(int step, int totalSteps);\n    80‚Üí\n    81‚Üí    // =========================================================================\n    82‚Üí    // Smoky Tracer Trail\n    83‚Üí    // =========================================================================\n    84‚Üí\n    85‚Üí    /// <summary>\n    86‚Üí    /// Scene for the smoky tracer trail effect.\n    87‚Üí    /// Created programmatically as a Line2D with smoke-like appearance.\n    88‚Üí    /// </summary>\n    89‚Üí    private Line2D? _lastTracerTrail;\n    90‚Üí\n    91‚Üí    // =========================================================================\n    92‚Üí    // Laser Sight Configuration\n    93‚Üí    // =========================================================================\n    94‚Üí\n    95‚Üí    /// <summary>\n    96‚Üí    /// Whether the laser sight is enabled.\n    97‚Üí    /// </summary>\n    98‚Üí    [Export]\n    99‚Üí    public bool LaserSightEnabled { get; set; } = true;\n   100‚Üí\n   101‚Üí    /// <summary>\n   102‚Üí    /// Maximum length of the laser sight in pixels.\n   103‚Üí    /// </summary>\n   104‚Üí    [Export]\n   105‚Üí    public float LaserSightLength { get; set; } = 500.0f;\n   106‚Üí\n   107‚Üí    /// <summary>\n   108‚Üí    /// Color of the laser sight (red for sniper).\n   109‚Üí    /// </summary>\n   110‚Üí    [Export]\n   111‚Üí    public Color LaserSightColor { get; set; } = new Color(1.0f, 0.0f, 0.0f, 0.5f);\n   112‚Üí\n   113‚Üí    /// <summary>\n   114‚Üí    /// Width of the laser sight line.\n   115‚Üí    /// </summary>\n   116‚Üí    [Export]\n   117‚Üí    public float LaserSightWidth { get; set; } = 2.0f;\n   118‚Üí\n   119‚Üí    /// <summary>\n   120‚Üí    /// Reference to the Line2D node for the laser sight.\n   121‚Üí    /// </summary>\n   122‚Üí    private Line2D? _laserSight;\n   123‚Üí\n   124‚Üí    /// <summary>\n   125‚Üí    /// Reference to the Sprite2D node for the rifle visual.\n   126‚Üí    /// </summary>\n   127‚Üí    private Sprite2D? _rifleSprite;\n   128‚Üí\n   129‚Üí    /// <summary>\n   130‚Üí    /// Current aim direction based on laser sight.\n   131‚Üí    /// </summary>\n   132‚Üí    private Vector2 _aimDirection = Vector2.Right;\n   133‚Üí\n   134‚Üí    /// <summary>\n   135‚Üí    /// Current aim angle in radians.\n   136‚Üí    /// </summary>\n   137‚Üí    private float _currentAimAngle = 0.0f;\n   138‚Üí\n   139‚Üí    /// <summary>\n   140‚Üí    /// Whether the aim angle has been initialized.\n   141‚Üí    /// </summary>\n   142‚Üí    private bool _aimAngleInitialized = false;\n   143‚Üí\n   144‚Üí    /// <summary>\n   145‚Üí    /// Current recoil offset angle in radians.\n   146‚Üí    /// Heavy sniper recoil.\n   147‚Üí    /// </summary>\n   148‚Üí    private float _recoilOffset = 0.0f;\n   149‚Üí\n   150‚Üí    /// <summary>\n   151‚Üí    /// Time since the last shot was fired, used for recoil recovery.\n   152‚Üí    /// </summary>\n   153‚Üí    private float _timeSinceLastShot = 0.0f;\n   154‚Üí\n   155‚Üí    /// <summary>\n   156‚Üí    /// Time in seconds before recoil starts recovering.\n   157‚Üí    /// Long delay for heavy sniper.\n   158‚Üí    /// </summary>\n   159‚Üí    private const float RecoilRecoveryDelay = 0.5f;\n   160‚Üí\n   161‚Üí    /// <summary>\n   162‚Üí    /// Speed at which recoil recovers (radians per second).\n   163‚Üí    /// </summary>\n   164‚Üí    private const float RecoilRecoverySpeed = 3.0f;\n   165‚Üí\n   166‚Üí    /// <summary>\n   167‚Üí    /// Maximum recoil offset in radians (about 15 degrees).\n   168‚Üí    /// </summary>\n   169‚Üí    private const float MaxRecoilOffset = 0.26f;\n   170‚Üí\n   171‚Üí    /// <summary>\n   172‚Üí    /// Recoil amount per shot in radians.\n   173‚Üí    /// Heavy kick for 12.7mm.\n   174‚Üí    /// </summary>\n   175‚Üí    private const float RecoilPerShot = 0.15f;\n   176‚Üí\n   177‚Üí    /// <summary>\n   178‚Üí    /// Number of walls this bullet can penetrate through.\n   179‚Üí    /// The bullet continues flying after penetrating walls.\n   180‚Üí    /// </summary>\n   181‚Üí    private const int MaxWallPenetrations = 2;\n   182‚Üí\n   183‚Üí    public override void _Ready()\n   184‚Üí    {\n   185‚Üí        base._Ready();\n   186‚Üí\n   187‚Üí        // Get the rifle sprite for visual representation\n   188‚Üí        _rifleSprite = GetNodeOrNull<Sprite2D>(\"RifleSprite\");\n   189‚Üí\n   190‚Üí        if (_rifleSprite != null)\n   191‚Üí        {\n   192‚Üí            var texture = _rifleSprite.Texture;\n   193‚Üí            GD.Print($\"[SniperRifle] RifleSprite found: visible={_rifleSprite.Visible}, z_index={_rifleSprite.ZIndex}, texture={(texture != null ? \"loaded\" : \"NULL\")}\");\n   194‚Üí        }\n   195‚Üí        else\n   196‚Üí        {\n   197‚Üí            GD.PrintErr(\"[SniperRifle] WARNING: RifleSprite node not found!\");\n   198‚Üí        }\n   199‚Üí\n   200‚Üí        // Check for Power Fantasy mode blue laser\n   201‚Üí        var difficultyManager = GetNodeOrNull(\"/root/DifficultyManager\");\n   202‚Üí        if (difficultyManager != null)\n   203‚Üí        {\n   204‚Üí            var shouldForceBlueLaser = difficultyManager.Call(\"should_force_blue_laser_sight\");\n   205‚Üí            if (shouldForceBlueLaser.AsBool())\n   206‚Üí            {\n   207‚Üí                var blueColorVariant = difficultyManager.Call(\"get_power_fantasy_laser_color\");\n   208‚Üí                LaserSightColor = blueColorVariant.AsColor();\n   209‚Üí                GD.Print($\"[SniperRifle] Power Fantasy mode: laser color set to blue {LaserSightColor}\");\n   210‚Üí            }\n   211‚Üí        }\n   212‚Üí\n   213‚Üí        // Get or create the laser sight Line2D\n   214‚Üí        _laserSight = GetNodeOrNull<Line2D>(\"LaserSight\");\n   215‚Üí\n   216‚Üí        if (_laserSight == null && LaserSightEnabled)\n   217‚Üí        {\n   218‚Üí            CreateLaserSight();\n   219‚Üí        }\n   220‚Üí        else if (_laserSight != null)\n   221‚Üí        {\n   222‚Üí            _laserSight.Width = LaserSightWidth;\n   223‚Üí            _laserSight.DefaultColor = LaserSightColor;\n   224‚Üí            _laserSight.BeginCapMode = Line2D.LineCapMode.Round;\n   225‚Üí            _laserSight.EndCapMode = Line2D.LineCapMode.Round;\n   226‚Üí\n   227‚Üí            if (_laserSight.GetPointCount() < 2)\n   228‚Üí            {\n   229‚Üí                _laserSight.ClearPoints();\n   230‚Üí                _laserSight.AddPoint(Vector2.Zero);\n   231‚Üí                _laserSight.AddPoint(Vector2.Right * LaserSightLength);\n   232‚Üí            }\n   233‚Üí        }\n   234‚Üí\n   235‚Üí        UpdateLaserSightVisibility();\n   236‚Üí        GD.Print(\"[SniperRifle] ASVK initialized - bolt ready, laser sight enabled\");\n   237‚Üí    }\n   238‚Üí\n   239‚Üí    public override void _ExitTree()\n   240‚Üí    {\n   241‚Üí        // Clean up scope overlay when weapon is removed from scene tree\n   242‚Üí        if (_isScopeActive)\n   243‚Üí        {\n   244‚Üí            DeactivateScope();\n   245‚Üí        }\n   246‚Üí        base._ExitTree();\n   247‚Üí    }\n   248‚Üí\n   249‚Üí    public override void _Process(double delta)\n   250‚Üí    {\n   251‚Üí        base._Process(delta);\n   252‚Üí\n   253‚Üí        // Update time since last shot for recoil recovery\n   254‚Üí        _timeSinceLastShot += (float)delta;\n   255‚Üí\n   256‚Üí        // Recover recoil after delay\n   257‚Üí        if (_timeSinceLastShot >= RecoilRecoveryDelay && _recoilOffset != 0)\n   258‚Üí        {\n   259‚Üí            float recoveryAmount = RecoilRecoverySpeed * (float)delta;\n   260‚Üí            _recoilOffset = Mathf.MoveToward(_recoilOffset, 0, recoveryAmount);\n   261‚Üí        }\n   262‚Üí\n   263‚Üí        // Always update aim direction and rifle sprite rotation\n   264‚Üí        UpdateAimDirection();\n   265‚Üí\n   266‚Üí        // Update laser sight to point towards mouse (with recoil offset)\n   267‚Üí        if (LaserSightEnabled && _laserSight != null)\n   268‚Üí        {\n   269‚Üí            UpdateLaserSight();\n   270‚Üí        }\n   271‚Üí\n   272‚Üí        // Handle bolt-action input\n   273‚Üí        HandleBoltActionInput();\n   274‚Üí\n   275‚Üí        // Update scope system (sway, camera offset, overlay)\n   276‚Üí        UpdateScope((float)delta);\n   277‚Üí    }\n   278‚Üí\n   279‚Üí    // =========================================================================\n   280‚Üí    // Bolt-Action Charging Mechanics\n   281‚Üí    // =========================================================================\n   282‚Üí\n   283‚Üí    /// <summary>\n   284‚Üí    /// Handles the bolt-action charging input sequence.\n   285‚Üí    /// Sequence: Down (pull bolt) ‚Üí Left (open bolt) ‚Üí Down (close bolt) ‚Üí Up (chamber round)\n   286‚Üí    /// Uses the arrow keys / WASD movement input actions.\n   287‚Üí    /// </summary>\n   288‚Üí    private void HandleBoltActionInput()\n   289‚Üí    {\n   290‚Üí        switch (_boltStep)\n   291‚Üí        {\n   292‚Üí            case BoltActionStep.NeedsBoltCycle:\n   293‚Üí                // Step 1: Down arrow - pull bolt back\n   294‚Üí                if (Input.IsActionJustPressed(\"move_down\"))\n   295‚Üí                {\n   296‚Üí                    _boltStep = BoltActionStep.WaitOpenBolt;\n   297‚Üí                    EmitSignal(SignalName.BoltStepChanged, 1, 4);\n   298‚Üí                    PlayBoltSound();\n   299‚Üí                    GD.Print(\"[SniperRifle] Bolt step 1/4: Bolt pulled back\");\n   300‚Üí                }\n   301‚Üí                break;\n   302‚Üí\n   303‚Üí            case BoltActionStep.WaitOpenBolt:\n   304‚Üí                // Step 2: Left arrow - open bolt\n   305‚Üí                if (Input.IsActionJustPressed(\"move_left\"))\n   306‚Üí                {\n   307‚Üí                    _boltStep = BoltActionStep.WaitCloseBolt;\n   308‚Üí                    EmitSignal(SignalName.BoltStepChanged, 2, 4);\n   309‚Üí                    PlayBoltSound();\n   310‚Üí                    GD.Print(\"[SniperRifle] Bolt step 2/4: Bolt opened\");\n   311‚Üí                }\n   312‚Üí                break;\n   313‚Üí\n   314‚Üí            case BoltActionStep.WaitCloseBolt:\n   315‚Üí                // Step 3: Down arrow - close bolt\n   316‚Üí                if (Input.IsActionJustPressed(\"move_down\"))\n   317‚Üí                {\n   318‚Üí                    _boltStep = BoltActionStep.WaitChamberRound;\n   319‚Üí                    EmitSignal(SignalName.BoltStepChanged, 3, 4);\n   320‚Üí                    PlayBoltSound();\n   321‚Üí                    GD.Print(\"[SniperRifle] Bolt step 3/4: Bolt closed\");\n   322‚Üí                }\n   323‚Üí                break;\n   324‚Üí\n   325‚Üí            case BoltActionStep.WaitChamberRound:\n   326‚Üí                // Step 4: Up arrow - chamber round\n   327‚Üí                if (Input.IsActionJustPressed(\"move_up\"))\n   328‚Üí                {\n   329‚Üí                    _boltStep = BoltActionStep.Ready;\n   330‚Üí                    EmitSignal(SignalName.BoltStepChanged, 4, 4);\n   331‚Üí                    PlayBoltChamberSound();\n   332‚Üí                    GD.Print(\"[SniperRifle] Bolt step 4/4: Round chambered - READY TO FIRE\");\n   333‚Üí                }\n   334‚Üí                break;\n   335‚Üí\n   336‚Üí            case BoltActionStep.Ready:\n   337‚Üí                // Already ready, no bolt action needed\n   338‚Üí                break;\n   339‚Üí        }\n   340‚Üí    }\n   341‚Üí\n   342‚Üí    /// <summary>\n   343‚Üí    /// Plays the bolt manipulation sound.\n   344‚Üí    /// </summary>\n   345‚Üí    private void PlayBoltSound()\n   346‚Üí    {\n   347‚Üí        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n   348‚Üí        if (audioManager != null && audioManager.HasMethod(\"play_m16_bolt\"))\n   349‚Üí        {\n   350‚Üí            audioManager.Call(\"play_m16_bolt\", GlobalPosition);\n   351‚Üí        }\n   352‚Üí    }\n   353‚Üí\n   354‚Üí    /// <summary>\n   355‚Üí    /// Plays the bolt chamber/ready sound.\n   356‚Üí    /// </summary>\n   357‚Üí    private void PlayBoltChamberSound()\n   358‚Üí    {\n   359‚Üí        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n   360‚Üí        if (audioManager != null && audioManager.HasMethod(\"play_m16_bolt\"))\n   361‚Üí        {\n   362‚Üí            audioManager.Call(\"play_m16_bolt\", GlobalPosition);\n   363‚Üí        }\n   364‚Üí    }\n   365‚Üí\n   366‚Üí    // =========================================================================\n   367‚Üí    // Aiming and Laser Sight\n   368‚Üí    // =========================================================================\n   369‚Üí\n   370‚Üí    /// <summary>\n   371‚Üí    /// Updates the aim direction and rifle sprite rotation.\n   372‚Üí    /// </summary>\n   373‚Üí    private void UpdateAimDirection()\n   374‚Üí    {\n   375‚Üí        Vector2 mousePos = GetGlobalMousePosition();\n   376‚Üí        Vector2 toMouse = mousePos - GlobalPosition;\n   377‚Üí        float targetAngle = toMouse.Angle();\n   378‚Üí\n   379‚Üí        if (!_aimAngleInitialized)\n   380‚Üí        {\n   381‚Üí            _currentAimAngle = targetAngle;\n   382‚Üí            _aimAngleInitialized = true;\n   383‚Üí        }\n   384‚Üí\n   385‚Üí        Vector2 direction;\n   386‚Üí\n   387‚Üí        // Apply sensitivity for the sniper rifle\n   388‚Üí        if (WeaponData != null && WeaponData.Sensitivity > 0)\n   389‚Üí        {\n   390‚Üí            float angleDiff = Mathf.Wrap(targetAngle - _currentAimAngle, -Mathf.Pi, Mathf.Pi);\n   391‚Üí            float rotationSpeed = WeaponData.Sensitivity * 10.0f;\n   392‚Üí            float delta = (float)GetProcessDeltaTime();\n   393‚Üí            float maxRotation = rotationSpeed * delta;\n   394‚Üí            float actualRotation = Mathf.Clamp(angleDiff, -maxRotation, maxRotation);\n   395‚Üí            _currentAimAngle += actualRotation;\n   396‚Üí            direction = new Vector2(Mathf.Cos(_currentAimAngle), Mathf.Sin(_currentAimAngle));\n   397‚Üí        }\n   398‚Üí        else\n   399‚Üí        {\n   400‚Üí            if (toMouse.LengthSquared() > 0.001f)\n   401‚Üí            {\n   402‚Üí                direction = toMouse.Normalized();\n   403‚Üí                _currentAimAngle = targetAngle;\n   404‚Üí            }\n   405‚Üí            else\n   406‚Üí            {\n   407‚Üí                direction = _aimDirection;\n   408‚Üí            }\n   409‚Üí        }\n   410‚Üí\n   411‚Üí        _aimDirection = direction;\n   412‚Üí        UpdateRifleSpriteRotation(direction);\n   413‚Üí    }\n   414‚Üí\n   415‚Üí    /// <summary>\n   416‚Üí    /// Creates the laser sight Line2D programmatically.\n   417‚Üí    /// </summary>\n   418‚Üí    private void CreateLaserSight()\n   419‚Üí    {\n   420‚Üí        _laserSight = new Line2D\n   421‚Üí        {\n   422‚Üí            Name = \"LaserSight\",\n   423‚Üí            Width = LaserSightWidth,\n   424‚Üí            DefaultColor = LaserSightColor,\n   425‚Üí            BeginCapMode = Line2D.LineCapMode.Round,\n   426‚Üí            EndCapMode = Line2D.LineCapMode.Round\n   427‚Üí        };\n   428‚Üí\n   429‚Üí        _laserSight.AddPoint(Vector2.Zero);\n   430‚Üí        _laserSight.AddPoint(Vector2.Right * LaserSightLength);\n   431‚Üí\n   432‚Üí        AddChild(_laserSight);\n   433‚Üí    }\n   434‚Üí\n   435‚Üí    /// <summary>\n   436‚Üí    /// Updates the laser sight visualization with recoil offset.\n   437‚Üí    /// Uses raycasting to stop at obstacles.\n   438‚Üí    /// </summary>\n   439‚Üí    private void UpdateLaserSight()\n   440‚Üí    {\n   441‚Üí        if (_laserSight == null)\n   442‚Üí        {\n   443‚Üí            return;\n   444‚Üí        }\n   445‚Üí\n   446‚Üí        Vector2 laserDirection = _aimDirection.Rotated(_recoilOffset);\n   447‚Üí\n   448‚Üí        Viewport? viewport = GetViewport();\n   449‚Üí        if (viewport == null)\n   450‚Üí        {\n   451‚Üí            return;\n   452‚Üí        }\n   453‚Üí\n   454‚Üí        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n   455‚Üí        float maxLaserLength = viewportSize.Length();\n   456‚Üí\n   457‚Üí        Vector2 endPoint = laserDirection * maxLaserLength;\n   458‚Üí\n   459‚Üí        var spaceState = GetWorld2D().DirectSpaceState;\n   460‚Üí        var query = PhysicsRayQueryParameters2D.Create(\n   461‚Üí            GlobalPosition,\n   462‚Üí            GlobalPosition + endPoint,\n   463‚Üí            4 // Collision mask for obstacles (layer 3 = value 4)\n   464‚Üí        );\n   465‚Üí\n   466‚Üí        var result = spaceState.IntersectRay(query);\n   467‚Üí\n   468‚Üí        if (result.Count > 0)\n   469‚Üí        {\n   470‚Üí            Vector2 hitPosition = (Vector2)result[\"position\"];\n   471‚Üí            endPoint = hitPosition - GlobalPosition;\n   472‚Üí        }\n   473‚Üí\n   474‚Üí        _laserSight.SetPointPosition(0, Vector2.Zero);\n   475‚Üí        _laserSight.SetPointPosition(1, endPoint);\n   476‚Üí    }\n   477‚Üí\n   478‚Üí    /// <summary>\n   479‚Üí    /// Updates the visibility of the laser sight.\n   480‚Üí    /// </summary>\n   481‚Üí    private void UpdateLaserSightVisibility()\n   482‚Üí    {\n   483‚Üí        if (_laserSight != null)\n   484‚Üí        {\n   485‚Üí            _laserSight.Visible = LaserSightEnabled;\n   486‚Üí        }\n   487‚Üí    }\n   488‚Üí\n   489‚Üí    /// <summary>\n   490‚Üí    /// Updates the rifle sprite rotation to match aim direction.\n   491‚Üí    /// </summary>\n   492‚Üí    private void UpdateRifleSpriteRotation(Vector2 direction)\n   493‚Üí    {\n   494‚Üí        if (_rifleSprite == null)\n   495‚Üí        {\n   496‚Üí            return;\n   497‚Üí        }\n   498‚Üí\n   499‚Üí        float angle = direction.Angle();\n   500‚Üí        _rifleSprite.Rotation = angle;\n   501‚Üí\n   502‚Üí        bool aimingLeft = Mathf.Abs(angle) > Mathf.Pi / 2;\n   503‚Üí        _rifleSprite.FlipV = aimingLeft;\n   504‚Üí    }\n   505‚Üí\n   506‚Üí    /// <summary>\n   507‚Üí    /// Enables or disables the laser sight.\n   508‚Üí    /// </summary>\n   509‚Üí    public void SetLaserSightEnabled(bool enabled)\n   510‚Üí    {\n   511‚Üí        LaserSightEnabled = enabled;\n   512‚Üí        UpdateLaserSightVisibility();\n   513‚Üí    }\n   514‚Üí\n   515‚Üí    // =========================================================================\n   516‚Üí    // Firing\n   517‚Üí    // =========================================================================\n   518‚Üí\n   519‚Üí    /// <summary>\n   520‚Üí    /// Fires the sniper rifle. Only fires if bolt is ready.\n   521‚Üí    /// After firing, transitions to NeedsBoltCycle state.\n   522‚Üí    /// </summary>\n   523‚Üí    public override bool Fire(Vector2 direction)\n   524‚Üí    {\n   525‚Üí        // Check for empty magazine\n   526‚Üí        if (CurrentAmmo <= 0)\n   527‚Üí        {\n   528‚Üí            PlayEmptyClickSound();\n   529‚Üí            return false;\n   530‚Üí        }\n   531‚Üí\n   532‚Üí        // Check if bolt is ready\n   533‚Üí        if (!IsBoltReady)\n   534‚Üí        {\n   535‚Üí            // Play a click to indicate bolt not cycled\n   536‚Üí            PlayEmptyClickSound();\n   537‚Üí            return false;\n   538‚Üí        }\n   539‚Üí\n   540‚Üí        // Check standard fire conditions\n   541‚Üí        if (!CanFire || WeaponData == null || BulletScene == null)\n   542‚Üí        {\n   543‚Üí            return false;\n   544‚Üí        }\n   545‚Üí\n   546‚Üí        // Apply recoil to aim direction\n   547‚Üí        Vector2 spreadDirection = ApplyRecoil(_aimDirection);\n   548‚Üí        bool result = base.Fire(spreadDirection);\n   549‚Üí\n   550‚Üí        if (result)\n   551‚Üí        {\n   552‚Üí            // Transition to needs bolt cycle\n   553‚Üí            _boltStep = BoltActionStep.NeedsBoltCycle;\n   554‚Üí            EmitSignal(SignalName.BoltStepChanged, 0, 4);\n   555‚Üí\n   556‚Üí            // Play sniper shot sound\n   557‚Üí            PlaySniperShotSound();\n   558‚Üí            // Emit gunshot sound for enemy detection\n   559‚Üí            EmitGunshotSound();\n   560‚Üí            // Play shell casing with delay\n   561‚Üí            PlayShellCasingDelayed();\n   562‚Üí            // Trigger heavy screen shake\n   563‚Üí            TriggerScreenShake(spreadDirection);\n   564‚Üí\n   565‚Üí            // Spawn smoky tracer trail\n   566‚Üí            SpawnSmokyTracer(GlobalPosition, spreadDirection);\n   567‚Üí\n   568‚Üí            GD.Print(\"[SniperRifle] FIRED! Bolt needs cycling. Ammo remaining: \" + CurrentAmmo);\n   569‚Üí        }\n   570‚Üí\n   571‚Üí        return result;\n   572‚Üí    }\n   573‚Üí\n   574‚Üí    /// <summary>\n   575‚Üí    /// Override SpawnBullet to configure the SniperBullet for sniper behavior:\n   576‚Üí    /// - Very high damage (50)\n   577‚Üí    /// - Passes through enemies (doesn't destroy on hit)\n   578‚Üí    /// - Penetrates through 2 walls (wall-count based, not distance-based)\n   579‚Üí    /// </summary>\n   580‚Üí    protected override void SpawnBullet(Vector2 direction)\n   581‚Üí    {\n   582‚Üí        if (BulletScene == null)\n   583‚Üí        {\n   584‚Üí            return;\n   585‚Üí        }\n   586‚Üí\n   587‚Üí        // Check bullet spawn path\n   588‚Üí        var (isBlocked, hitPosition, hitNormal) = CheckBulletSpawnPath(direction);\n   589‚Üí\n   590‚Üí        Vector2 spawnPosition;\n   591‚Üí        if (isBlocked)\n   592‚Üí        {\n   593‚Üí            spawnPosition = GlobalPosition + direction * 2.0f;\n   594‚Üí            GD.Print(\"[SniperRifle] Point-blank shot: spawning for penetration\");\n   595‚Üí        }\n   596‚Üí        else\n   597‚Üí        {\n   598‚Üí            spawnPosition = GlobalPosition + direction * BulletSpawnOffset;\n   599‚Üí        }\n   600‚Üí\n   601‚Üí        var bulletNode = BulletScene.Instantiate<Node2D>();\n   602‚Üí        bulletNode.GlobalPosition = spawnPosition;\n   603‚Üí\n   604‚Üí        // Try to cast to C# SniperBullet for direct property access\n   605‚Üí        var sniperBullet = bulletNode as SniperBullet;\n   606‚Üí\n   607‚Üí        if (sniperBullet != null)\n   608‚Üí        {\n   609‚Üí            // SniperBullet - set properties directly\n   610‚Üí            sniperBullet.Direction = direction;\n   611‚Üí            if (WeaponData != null)\n   612‚Üí            {\n   613‚Üí                sniperBullet.Speed = WeaponData.BulletSpeed;\n   614‚Üí                sniperBullet.Damage = WeaponData.Damage;\n   615‚Üí            }\n   616‚Üí            var owner = GetParent();\n   617‚Üí            if (owner != null)\n   618‚Üí            {\n   619‚Üí                sniperBullet.ShooterId = owner.GetInstanceId();\n   620‚Üí            }\n   621‚Üí            sniperBullet.ShooterPosition = GlobalPosition;\n   622‚Üí            sniperBullet.MaxWallPenetrations = MaxWallPenetrations;\n   623‚Üí            GD.Print($\"[SniperRifle] Spawned SniperBullet: Damage={sniperBullet.Damage}, Speed={sniperBullet.Speed}, MaxWallPen={MaxWallPenetrations}\");\n   624‚Üí        }\n   625‚Üí        else\n   626‚Üí        {\n   627‚Üí            // Fallback for any bullet type\n   628‚Üí            if (bulletNode.HasMethod(\"SetDirection\"))\n   629‚Üí            {\n   630‚Üí                bulletNode.Call(\"SetDirection\", direction);\n   631‚Üí            }\n   632‚Üí            else\n   633‚Üí            {\n   634‚Üí                bulletNode.Set(\"Direction\", direction);\n   635‚Üí                bulletNode.Set(\"direction\", direction);\n   636‚Üí            }\n   637‚Üí\n   638‚Üí            if (WeaponData != null)\n   639‚Üí            {\n   640‚Üí                bulletNode.Set(\"Speed\", WeaponData.BulletSpeed);\n   641‚Üí                bulletNode.Set(\"speed\", WeaponData.BulletSpeed);\n   642‚Üí                bulletNode.Set(\"Damage\", WeaponData.Damage);\n   643‚Üí                bulletNode.Set(\"damage\", WeaponData.Damage);\n   644‚Üí            }\n   645‚Üí\n   646‚Üí            var owner = GetParent();\n   647‚Üí            if (owner != null)\n   648‚Üí            {\n   649‚Üí                bulletNode.Set(\"ShooterId\", owner.GetInstanceId());\n   650‚Üí                bulletNode.Set(\"shooter_id\", owner.GetInstanceId());\n   651‚Üí            }\n   652‚Üí\n   653‚Üí            bulletNode.Set(\"ShooterPosition\", GlobalPosition);\n   654‚Üí            bulletNode.Set(\"shooter_position\", GlobalPosition);\n   655‚Üí        }\n   656‚Üí\n   657‚Üí        GetTree().CurrentScene.AddChild(bulletNode);\n   658‚Üí\n   659‚Üí        // Spawn muzzle flash effect - large flash for 12.7mm\n   660‚Üí        SpawnMuzzleFlash(spawnPosition, direction, WeaponData?.Caliber);\n   661‚Üí\n   662‚Üí        // Spawn casing\n   663‚Üí        SpawnCasing(direction, WeaponData?.Caliber);\n   664‚Üí    }\n   665‚Üí\n   666‚Üí    // =========================================================================\n   667‚Üí    // Smoky Tracer Trail\n   668‚Üí    // =========================================================================\n   669‚Üí\n   670‚Üí    /// <summary>\n   671‚Üí    /// Spawns a smoky dissipating tracer trail from the fire position\n   672‚Üí    /// in the shooting direction across the entire map.\n   673‚Üí    /// The tracer is an instant visual effect (like a contrail from a plane)\n   674‚Üí    /// that fades out over time.\n   675‚Üí    /// </summary>\n   676‚Üí    private void SpawnSmokyTracer(Vector2 fromPosition, Vector2 direction)\n   677‚Üí    {\n   678‚Üí        // Calculate tracer end point - extend to edge of map (very far)\n   679‚Üí        float tracerLength = 5000.0f; // Far enough to reach any map edge\n   680‚Üí        Vector2 endPosition = fromPosition + direction * tracerLength;\n   681‚Üí\n   682‚Üí        // Create the tracer as a Line2D with smoke-like appearance\n   683‚Üí        var tracer = new Line2D\n   684‚Üí        {\n   685‚Üí            Name = \"SniperTracer\",\n   686‚Üí            Width = 6.0f,\n   687‚Üí            DefaultColor = new Color(0.8f, 0.8f, 0.8f, 0.7f),\n   688‚Üí            BeginCapMode = Line2D.LineCapMode.Round,\n   689‚Üí            EndCapMode = Line2D.LineCapMode.Round,\n   690‚Üí            TopLevel = true,\n   691‚Üí            Position = Vector2.Zero,\n   692‚Üí            ZIndex = -1 // Behind other elements\n   693‚Üí        };\n   694‚Üí\n   695‚Üí        // Set up width curve - wider at start, tapers to narrower at end\n   696‚Üí        var widthCurve = new Curve();\n   697‚Üí        widthCurve.AddPoint(new Vector2(0.0f, 1.0f));\n   698‚Üí        widthCurve.AddPoint(new Vector2(0.3f, 0.8f));\n   699‚Üí        widthCurve.AddPoint(new Vector2(1.0f, 0.3f));\n   700‚Üí        tracer.WidthCurve = widthCurve;\n   701‚Üí\n   702‚Üí        // Set up gradient - smoky white/gray that fades out\n   703‚Üí        var gradient = new Gradient();\n   704‚Üí        gradient.SetColor(0, new Color(0.9f, 0.9f, 0.85f, 0.8f));\n   705‚Üí        gradient.AddPoint(0.5f, new Color(0.7f, 0.7f, 0.65f, 0.5f));\n   706‚Üí        gradient.SetColor(gradient.GetPointCount() - 1, new Color(0.5f, 0.5f, 0.5f, 0.2f));\n   707‚Üí        tracer.Gradient = gradient;\n   708‚Üí\n   709‚Üí        // Add the tracer line points (using global coordinates since TopLevel=true)\n   710‚Üí        tracer.AddPoint(fromPosition + direction * BulletSpawnOffset);\n   711‚Üí        tracer.AddPoint(endPosition);\n   712‚Üí\n   713‚Üí        // Add to scene\n   714‚Üí        GetTree().CurrentScene.AddChild(tracer);\n   715‚Üí\n   716‚Üí        // Start the fade-out animation\n   717‚Üí        FadeOutTracer(tracer);\n   718‚Üí    }\n   719‚Üí\n   720‚Üí    /// <summary>\n   721‚Üí    /// Animates the tracer trail fading out and dissipating over time.\n   722‚Üí    /// The tracer gradually becomes more transparent and wider (simulating smoke dissipation).\n   723‚Üí    /// </summary>\n   724‚Üí    private async void FadeOutTracer(Line2D tracer)\n   725‚Üí    {\n   726‚Üí        float fadeDuration = 2.0f;\n   727‚Üí        float elapsed = 0.0f;\n   728‚Üí\n   729‚Üí        float initialWidth = tracer.Width;\n   730‚Üí\n   731‚Üí        while (elapsed < fadeDuration && IsInstanceValid(tracer))\n   732‚Üí        {\n   733‚Üí            elapsed += (float)GetProcessDeltaTime();\n   734‚Üí            float progress = elapsed / fadeDuration;\n   735‚Üí\n   736‚Üí            // Fade the alpha\n   737‚Üí            float alpha = Mathf.Lerp(0.7f, 0.0f, progress);\n   738‚Üí            tracer.DefaultColor = new Color(0.8f, 0.8f, 0.8f, alpha);\n   739‚Üí\n   740‚Üí            // Widen slightly to simulate smoke dissipation\n   741‚Üí            tracer.Width = initialWidth + progress * 4.0f;\n   742‚Üí\n   743‚Üí            // Update gradient alpha\n   744‚Üí            var gradient = new Gradient();\n   745‚Üí            gradient.SetColor(0, new Color(0.9f, 0.9f, 0.85f, alpha));\n   746‚Üí            gradient.AddPoint(0.5f, new Color(0.7f, 0.7f, 0.65f, alpha * 0.6f));\n   747‚Üí            gradient.SetColor(gradient.GetPointCount() - 1, new Color(0.5f, 0.5f, 0.5f, alpha * 0.3f));\n   748‚Üí            tracer.Gradient = gradient;\n   749‚Üí\n   750‚Üí            await ToSignal(GetTree(), \"process_frame\");\n   751‚Üí        }\n   752‚Üí\n   753‚Üí        // Remove the tracer after fade completes\n   754‚Üí        if (IsInstanceValid(tracer))\n   755‚Üí        {\n   756‚Üí            tracer.QueueFree();\n   757‚Üí        }\n   758‚Üí    }\n   759‚Üí\n   760‚Üí    // =========================================================================\n   761‚Üí    // Sound and Effects\n   762‚Üí    // =========================================================================\n   763‚Üí\n   764‚Üí    /// <summary>\n   765‚Üí    /// Plays the sniper shot sound via AudioManager.\n   766‚Üí    /// </summary>\n   767‚Üí    private void PlaySniperShotSound()\n   768‚Üí    {\n   769‚Üí        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n   770‚Üí        // Use M16 shot as a placeholder sound for the sniper\n   771‚Üí        if (audioManager != null && audioManager.HasMethod(\"play_m16_shot\"))\n   772‚Üí        {\n   773‚Üí            audioManager.Call(\"play_m16_shot\", GlobalPosition);\n   774‚Üí        }\n   775‚Üí    }\n   776‚Üí\n   777‚Üí    /// <summary>\n   778‚Üí    /// Plays the empty gun click sound.\n   779‚Üí    /// </summary>\n   780‚Üí    private void PlayEmptyClickSound()\n   781‚Üí    {\n   782‚Üí        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n   783‚Üí        if (audioManager != null && audioManager.HasMethod(\"play_empty_click\"))\n   784‚Üí        {\n   785‚Üí            audioManager.Call(\"play_empty_click\", GlobalPosition);\n   786‚Üí        }\n   787‚Üí    }\n   788‚Üí\n   789‚Üí    /// <summary>\n   790‚Üí    /// Emits gunshot sound for enemy detection via SoundPropagation.\n   791‚Üí    /// Very loud for the 12.7mm round.\n   792‚Üí    /// </summary>\n   793‚Üí    private void EmitGunshotSound()\n   794‚Üí    {\n   795‚Üí        var soundPropagation = GetNodeOrNull(\"/root/SoundPropagation\");\n   796‚Üí        if (soundPropagation != null && soundPropagation.HasMethod(\"emit_sound\"))\n   797‚Üí        {\n   798‚Üí            float loudness = WeaponData?.Loudness ?? 3000.0f;\n   799‚Üí            soundPropagation.Call(\"emit_sound\", 0, GlobalPosition, 0, this, loudness);\n   800‚Üí        }\n   801‚Üí    }\n   802‚Üí\n   803‚Üí    /// <summary>\n   804‚Üí    /// Plays shell casing sound with a delay.\n   805‚Üí    /// </summary>\n   806‚Üí    private async void PlayShellCasingDelayed()\n   807‚Üí    {\n   808‚Üí        await ToSignal(GetTree().CreateTimer(0.2), \"timeout\");\n   809‚Üí        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n   810‚Üí        if (audioManager != null && audioManager.HasMethod(\"play_shell_rifle\"))\n   811‚Üí        {\n   812‚Üí            audioManager.Call(\"play_shell_rifle\", GlobalPosition);\n   813‚Üí        }\n   814‚Üí    }\n   815‚Üí\n   816‚Üí    /// <summary>\n   817‚Üí    /// Applies recoil to shooting direction.\n   818‚Üí    /// </summary>\n   819‚Üí    private Vector2 ApplyRecoil(Vector2 direction)\n   820‚Üí    {\n   821‚Üí        // Apply current recoil offset\n   822‚Üí        Vector2 result = direction.Rotated(_recoilOffset);\n   823‚Üí\n   824‚Üí        // Add strong recoil for next shot (heavy 12.7mm kick)\n   825‚Üí        float recoilDirection = (float)GD.RandRange(-1.0, 1.0);\n   826‚Üí        _recoilOffset += recoilDirection * RecoilPerShot;\n   827‚Üí        _recoilOffset = Mathf.Clamp(_recoilOffset, -MaxRecoilOffset, MaxRecoilOffset);\n   828‚Üí\n   829‚Üí        _timeSinceLastShot = 0;\n   830‚Üí\n   831‚Üí        return result;\n   832‚Üí    }\n   833‚Üí\n   834‚Üí    /// <summary>\n   835‚Üí    /// Triggers screen shake from sniper shot.\n   836‚Üí    /// Heavy shake for 12.7mm round.\n   837‚Üí    /// </summary>\n   838‚Üí    private void TriggerScreenShake(Vector2 shootDirection)\n   839‚Üí    {\n   840‚Üí        if (WeaponData == null || WeaponData.ScreenShakeIntensity <= 0)\n   841‚Üí        {\n   842‚Üí            return;\n   843‚Üí        }\n   844‚Üí\n   845‚Üí        var screenShakeManager = GetNodeOrNull(\"/root/ScreenShakeManager\");\n   846‚Üí        if (screenShakeManager == null || !screenShakeManager.HasMethod(\"add_shake\"))\n   847‚Üí        {\n   848‚Üí            return;\n   849‚Üí        }\n   850‚Üí\n   851‚Üí        // Heavy shake for sniper\n   852‚Üí        float fireRate = WeaponData.FireRate;\n   853‚Üí        float shakeIntensity;\n   854‚Üí        if (fireRate > 0)\n   855‚Üí        {\n   856‚Üí            shakeIntensity = WeaponData.ScreenShakeIntensity / fireRate * 10.0f;\n   857‚Üí        }\n   858‚Üí        else\n   859‚Üí        {\n   860‚Üí            shakeIntensity = WeaponData.ScreenShakeIntensity;\n   861‚Üí        }\n   862‚Üí\n   863‚Üí        float recoveryTime = WeaponData.ScreenShakeMinRecoveryTime;\n   864‚Üí\n   865‚Üí        screenShakeManager.Call(\"add_shake\", shootDirection, shakeIntensity, recoveryTime);\n   866‚Üí    }\n   867‚Üí\n   868‚Üí    /// <summary>\n   869‚Üí    /// Fires the bullet in the chamber during reload sequence.\n   870‚Üí    /// </summary>\n   871‚Üí    public override bool FireChamberBullet(Vector2 direction)\n   872‚Üí    {\n   873‚Üí        // Sniper rifle doesn't support chamber bullet during reload\n   874‚Üí        // (bolt-action requires full cycle)\n   875‚Üí        return false;\n   876‚Üí    }\n   877‚Üí\n   878‚Üí    /// <summary>\n   879‚Üí    /// Gets the current aim direction.\n   880‚Üí    /// </summary>\n   881‚Üí    public Vector2 AimDirection => _aimDirection;\n   882‚Üí\n   883‚Üí    /// <summary>\n   884‚Üí    /// Gets the current bolt-action step.\n   885‚Üí    /// </summary>\n   886‚Üí    public BoltActionStep CurrentBoltStep => _boltStep;\n   887‚Üí\n   888‚Üí    /// <summary>\n   889‚Üí    /// Resets the bolt to ready state (e.g., after reload with a new magazine).\n   890‚Üí    /// </summary>\n   891‚Üí    public void ResetBolt()\n   892‚Üí    {\n   893‚Üí        _boltStep = BoltActionStep.Ready;\n   894‚Üí        EmitSignal(SignalName.BoltStepChanged, 4, 4);\n   895‚Üí        GD.Print(\"[SniperRifle] Bolt reset to ready state\");\n   896‚Üí    }\n   897‚Üí\n   898‚Üí    // =========================================================================\n   899‚Üí    // Scope / Aiming System (RMB)\n   900‚Üí    // =========================================================================\n   901‚Üí\n   902‚Üí    /// <summary>\n   903‚Üí    /// Whether the scope is currently active (RMB held).\n   904‚Üí    /// </summary>\n   905‚Üí    private bool _isScopeActive = false;\n   906‚Üí\n   907‚Üí    /// <summary>\n   908‚Üí    /// Whether the scope is active (read-only property for external access).\n   909‚Üí    /// </summary>\n   910‚Üí    public bool IsScopeActive => _isScopeActive;\n   911‚Üí\n   912‚Üí    /// <summary>\n   913‚Üí    /// Signal emitted when scope state changes.\n   914‚Üí    /// </summary>\n   915‚Üí    [Signal]\n   916‚Üí    public delegate void ScopeStateChangedEventHandler(bool isActive);\n   917‚Üí\n   918‚Üí    /// <summary>\n   919‚Üí    /// Current scope zoom distance multiplier (how far beyond viewport the player can see).\n   920‚Üí    /// 1.0 = one viewport distance, 2.0 = two viewport distances.\n   921‚Üí    /// Controlled by mouse wheel while scoping.\n   922‚Üí    /// </summary>\n   923‚Üí    private float _scopeZoomDistance = 1.0f;\n   924‚Üí\n   925‚Üí    /// <summary>\n   926‚Üí    /// Minimum scope zoom distance (viewport multiplier).\n   927‚Üí    /// </summary>\n   928‚Üí    private const float MinScopeZoomDistance = 0.5f;\n   929‚Üí\n   930‚Üí    /// <summary>\n   931‚Üí    /// Maximum scope zoom distance (viewport multiplier).\n   932‚Üí    /// </summary>\n   933‚Üí    private const float MaxScopeZoomDistance = 3.0f;\n   934‚Üí\n   935‚Üí    /// <summary>\n   936‚Üí    /// Step size for mouse wheel zoom adjustment.\n   937‚Üí    /// </summary>\n   938‚Üí    private const float ScopeZoomStep = 0.25f;\n   939‚Üí\n   940‚Üí    /// <summary>\n   941‚Üí    /// Base sway amplitude in pixels at 1 viewport distance.\n   942‚Üí    /// </summary>\n   943‚Üí    private const float BaseScopeSwayAmplitude = 8.0f;\n   944‚Üí\n   945‚Üí    /// <summary>\n   946‚Üí    /// Speed of the sway oscillation.\n   947‚Üí    /// </summary>\n   948‚Üí    private const float ScopeSwaySpeed = 2.5f;\n   949‚Üí\n   950‚Üí    /// <summary>\n   951‚Üí    /// Current scope sway time accumulator.\n   952‚Üí    /// </summary>\n   953‚Üí    private float _scopeSwayTime = 0.0f;\n   954‚Üí\n   955‚Üí    /// <summary>\n   956‚Üí    /// Current scope sway offset in pixels (applied to camera).\n   957‚Üí    /// </summary>\n   958‚Üí    private Vector2 _scopeSwayOffset = Vector2.Zero;\n   959‚Üí\n   960‚Üí    /// <summary>\n   961‚Üí    /// Reference to the scope overlay CanvasLayer (created when scope activates).\n   962‚Üí    /// </summary>\n   963‚Üí    private CanvasLayer? _scopeOverlay = null;\n   964‚Üí\n   965‚Üí    /// <summary>\n   966‚Üí    /// Reference to the scope crosshair control node.\n   967‚Üí    /// </summary>\n   968‚Üí    private Control? _scopeCrosshair = null;\n   969‚Üí\n   970‚Üí    /// <summary>\n   971‚Üí    /// Reference to the scope darkening background.\n   972‚Üí    /// </summary>\n   973‚Üí    private ColorRect? _scopeBackground = null;\n   974‚Üí\n   975‚Üí    /// <summary>\n   976‚Üí    /// Cached reference to the player's Camera2D node.\n   977‚Üí    /// </summary>\n   978‚Üí    private Camera2D? _playerCamera = null;\n   979‚Üí\n   980‚Üí    /// <summary>\n   981‚Üí    /// Original camera offset before scoping (to restore on exit).\n   982‚Üí    /// </summary>\n   983‚Üí    private Vector2 _originalCameraOffset = Vector2.Zero;\n   984‚Üí\n   985‚Üí    /// <summary>\n   986‚Üí    /// Gets the current camera offset for scope aiming.\n   987‚Üí    /// Called by the player or level scripts to position the camera.\n   988‚Üí    /// </summary>\n   989‚Üí    public Vector2 GetScopeCameraOffset()\n   990‚Üí    {\n   991‚Üí        if (!_isScopeActive)\n   992‚Üí        {\n   993‚Üí            return Vector2.Zero;\n   994‚Üí        }\n   995‚Üí\n   996‚Üí        Viewport? viewport = GetViewport();\n   997‚Üí        if (viewport == null)\n   998‚Üí        {\n   999‚Üí            return Vector2.Zero;\n  1000‚Üí        }\n  1001‚Üí\n  1002‚Üí        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n  1003‚Üí        float baseDistance = viewportSize.Length() * 0.5f;\n  1004‚Üí\n  1005‚Üí        // Camera offset = aim direction * zoom distance * viewport size + sway\n  1006‚Üí        Vector2 offset = _aimDirection * baseDistance * _scopeZoomDistance + _scopeSwayOffset;\n  1007‚Üí\n  1008‚Üí        return offset;\n  1009‚Üí    }\n  1010‚Üí\n  1011‚Üí    /// <summary>\n  1012‚Üí    /// Activates the scope (called when RMB is pressed).\n  1013‚Üí    /// </summary>\n  1014‚Üí    public void ActivateScope()\n  1015‚Üí    {\n  1016‚Üí        if (_isScopeActive)\n  1017‚Üí        {\n  1018‚Üí            return;\n  1019‚Üí        }\n  1020‚Üí\n  1021‚Üí        _isScopeActive = true;\n  1022‚Üí        _scopeSwayTime = 0.0f;\n  1023‚Üí\n  1024‚Üí        // Find and cache the player's Camera2D\n  1025‚Üí        FindPlayerCamera();\n  1026‚Üí\n  1027‚Üí        // Store original camera offset\n  1028‚Üí        if (_playerCamera != null)\n  1029‚Üí        {\n  1030‚Üí            _originalCameraOffset = _playerCamera.Offset;\n  1031‚Üí        }\n  1032‚Üí\n  1033‚Üí        // Create the scope overlay\n  1034‚Üí        CreateScopeOverlay();\n  1035‚Üí\n  1036‚Üí        EmitSignal(SignalName.ScopeStateChanged, true);\n  1037‚Üí        GD.Print($\"[SniperRifle] Scope activated. Zoom distance: {_scopeZoomDistance:F1}x\");\n  1038‚Üí    }\n  1039‚Üí\n  1040‚Üí    /// <summary>\n  1041‚Üí    /// Deactivates the scope (called when RMB is released).\n  1042‚Üí    /// </summary>\n  1043‚Üí    public void DeactivateScope()\n  1044‚Üí    {\n  1045‚Üí        if (!_isScopeActive)\n  1046‚Üí        {\n  1047‚Üí            return;\n  1048‚Üí        }\n  1049‚Üí\n  1050‚Üí        _isScopeActive = false;\n  1051‚Üí\n  1052‚Üí        // Restore original camera offset\n  1053‚Üí        if (_playerCamera != null)\n  1054‚Üí        {\n  1055‚Üí            _playerCamera.Offset = _originalCameraOffset;\n  1056‚Üí        }\n  1057‚Üí\n  1058‚Üí        // Remove scope overlay\n  1059‚Üí        RemoveScopeOverlay();\n  1060‚Üí\n  1061‚Üí        EmitSignal(SignalName.ScopeStateChanged, false);\n  1062‚Üí        GD.Print(\"[SniperRifle] Scope deactivated.\");\n  1063‚Üí    }\n  1064‚Üí\n  1065‚Üí    /// <summary>\n  1066‚Üí    /// Adjusts the scope zoom distance (called on mouse wheel while scoping).\n  1067‚Üí    /// </summary>\n  1068‚Üí    public void AdjustScopeZoom(float direction)\n  1069‚Üí    {\n  1070‚Üí        if (!_isScopeActive)\n  1071‚Üí        {\n  1072‚Üí            return;\n  1073‚Üí        }\n  1074‚Üí\n  1075‚Üí        _scopeZoomDistance += direction * ScopeZoomStep;\n  1076‚Üí        _scopeZoomDistance = Mathf.Clamp(_scopeZoomDistance, MinScopeZoomDistance, MaxScopeZoomDistance);\n  1077‚Üí\n  1078‚Üí        GD.Print($\"[SniperRifle] Scope zoom adjusted: {_scopeZoomDistance:F2}x\");\n  1079‚Üí    }\n  1080‚Üí\n  1081‚Üí    /// <summary>\n  1082‚Üí    /// Finds the player's Camera2D node by traversing up to the parent (player).\n  1083‚Üí    /// </summary>\n  1084‚Üí    private void FindPlayerCamera()\n  1085‚Üí    {\n  1086‚Üí        if (_playerCamera != null)\n  1087‚Üí        {\n  1088‚Üí            return;\n  1089‚Üí        }\n  1090‚Üí\n  1091‚Üí        var parent = GetParent();\n  1092‚Üí        if (parent != null)\n  1093‚Üí        {\n  1094‚Üí            _playerCamera = parent.GetNodeOrNull<Camera2D>(\"Camera2D\");\n  1095‚Üí        }\n  1096‚Üí    }\n  1097‚Üí\n  1098‚Üí    /// <summary>\n  1099‚Üí    /// Updates the scope system each frame (called from _Process).\n  1100‚Üí    /// </summary>\n  1101‚Üí    private void UpdateScope(float delta)\n  1102‚Üí    {\n  1103‚Üí        if (!_isScopeActive)\n  1104‚Üí        {\n  1105‚Üí            return;\n  1106‚Üí        }\n  1107‚Üí\n  1108‚Üí        // Update sway\n  1109‚Üí        _scopeSwayTime += delta;\n  1110‚Üí        float swayAmplitude = BaseScopeSwayAmplitude * _scopeZoomDistance;\n  1111‚Üí\n  1112‚Üí        // Use two sine waves at different frequencies for natural-looking sway\n  1113‚Üí        float swayX = Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 1.0f) * swayAmplitude\n  1114‚Üí                    + Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 2.3f) * swayAmplitude * 0.3f;\n  1115‚Üí        float swayY = Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 1.4f) * swayAmplitude\n  1116‚Üí                    + Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 0.7f) * swayAmplitude * 0.4f;\n  1117‚Üí\n  1118‚Üí        _scopeSwayOffset = new Vector2(swayX, swayY);\n  1119‚Üí\n  1120‚Üí        // Update camera offset for scope view\n  1121‚Üí        if (_playerCamera != null)\n  1122‚Üí        {\n  1123‚Üí            _playerCamera.Offset = _originalCameraOffset + GetScopeCameraOffset();\n  1124‚Üí        }\n  1125‚Üí\n  1126‚Üí        // Update scope overlay crosshair position with sway\n  1127‚Üí        UpdateScopeOverlayPosition();\n  1128‚Üí    }\n  1129‚Üí\n  1130‚Üí    /// <summary>\n  1131‚Üí    /// Creates the scope overlay UI with crosshair and darkened edges.\n  1132‚Üí    /// </summary>\n  1133‚Üí    private void CreateScopeOverlay()\n  1134‚Üí    {\n  1135‚Üí        RemoveScopeOverlay();\n  1136‚Üí\n  1137‚Üí        _scopeOverlay = new CanvasLayer\n  1138‚Üí        {\n  1139‚Üí            Name = \"ScopeOverlay\",\n  1140‚Üí            Layer = 10\n  1141‚Üí        };\n  1142‚Üí\n  1143‚Üí        Viewport? viewport = GetViewport();\n  1144‚Üí        Vector2 viewportSize = viewport?.GetVisibleRect().Size ?? new Vector2(1280, 720);\n  1145‚Üí\n  1146‚Üí        // Dark background with circular cutout effect (vignette)\n  1147‚Üí        _scopeBackground = new ColorRect\n  1148‚Üí        {\n  1149‚Üí            Name = \"ScopeBackground\",\n  1150‚Üí            Color = new Color(0.0f, 0.0f, 0.0f, 0.5f),\n  1151‚Üí            Size = viewportSize,\n  1152‚Üí            Position = Vector2.Zero,\n  1153‚Üí            MouseFilter = Control.MouseFilterEnum.Ignore\n  1154‚Üí        };\n  1155‚Üí        _scopeOverlay.AddChild(_scopeBackground);\n  1156‚Üí\n  1157‚Üí        // Create the crosshair as a Control node\n  1158‚Üí        _scopeCrosshair = new Control\n  1159‚Üí        {\n  1160‚Üí            Name = \"ScopeCrosshair\",\n  1161‚Üí            Position = viewportSize / 2,\n  1162‚Üí            Size = Vector2.Zero,\n  1163‚Üí            MouseFilter = Control.MouseFilterEnum.Ignore\n  1164‚Üí        };\n  1165‚Üí        _scopeOverlay.AddChild(_scopeCrosshair);\n  1166‚Üí\n  1167‚Üí        // Add crosshair lines - based on the reference image from the issue\n  1168‚Üí        // The scope has a classic crosshair with circle and mil-dots\n  1169‚Üí\n  1170‚Üí        // Outer circle\n  1171‚Üí        float circleRadius = Mathf.Min(viewportSize.X, viewportSize.Y) * 0.35f;\n  1172‚Üí        int segments = 64;\n  1173‚Üí        var outerCircle = new Line2D\n  1174‚Üí        {\n  1175‚Üí            Name = \"OuterCircle\",\n  1176‚Üí            Width = 2.0f,\n  1177‚Üí            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f),\n  1178‚Üí            Antialiased = true\n  1179‚Üí        };\n  1180‚Üí        for (int i = 0; i <= segments; i++)\n  1181‚Üí        {\n  1182‚Üí            float angle = (float)i / segments * Mathf.Tau;\n  1183‚Üí            outerCircle.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * circleRadius);\n  1184‚Üí        }\n  1185‚Üí        _scopeCrosshair.AddChild(outerCircle);\n  1186‚Üí\n  1187‚Üí        // Inner thin circle\n  1188‚Üí        float innerRadius = circleRadius * 0.05f;\n  1189‚Üí        var innerCircle = new Line2D\n  1190‚Üí        {\n  1191‚Üí            Name = \"InnerCircle\",\n  1192‚Üí            Width = 1.5f,\n  1193‚Üí            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f),\n  1194‚Üí            Antialiased = true\n  1195‚Üí        };\n  1196‚Üí        for (int i = 0; i <= segments; i++)\n  1197‚Üí        {\n  1198‚Üí            float angle = (float)i / segments * Mathf.Tau;\n  1199‚Üí            innerCircle.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * innerRadius);\n  1200‚Üí        }\n  1201‚Üí        _scopeCrosshair.AddChild(innerCircle);\n  1202‚Üí\n  1203‚Üí        // Horizontal crosshair line (left)\n  1204‚Üí        var hLineLeft = new Line2D\n  1205‚Üí        {\n  1206‚Üí            Name = \"HLineLeft\",\n  1207‚Üí            Width = 2.0f,\n  1208‚Üí            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n  1209‚Üí        };\n  1210‚Üí        hLineLeft.AddPoint(new Vector2(-circleRadius, 0));\n  1211‚Üí        hLineLeft.AddPoint(new Vector2(-innerRadius, 0));\n  1212‚Üí        _scopeCrosshair.AddChild(hLineLeft);\n  1213‚Üí\n  1214‚Üí        // Horizontal crosshair line (right)\n  1215‚Üí        var hLineRight = new Line2D\n  1216‚Üí        {\n  1217‚Üí            Name = \"HLineRight\",\n  1218‚Üí            Width = 2.0f,\n  1219‚Üí            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n  1220‚Üí        };\n  1221‚Üí        hLineRight.AddPoint(new Vector2(innerRadius, 0));\n  1222‚Üí        hLineRight.AddPoint(new Vector2(circleRadius, 0));\n  1223‚Üí        _scopeCrosshair.AddChild(hLineRight);\n  1224‚Üí\n  1225‚Üí        // Vertical crosshair line (top)\n  1226‚Üí        var vLineTop = new Line2D\n  1227‚Üí        {\n  1228‚Üí            Name = \"VLineTop\",\n  1229‚Üí            Width = 2.0f,\n  1230‚Üí            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n  1231‚Üí        };\n  1232‚Üí        vLineTop.AddPoint(new Vector2(0, -circleRadius));\n  1233‚Üí        vLineTop.AddPoint(new Vector2(0, -innerRadius));\n  1234‚Üí        _scopeCrosshair.AddChild(vLineTop);\n  1235‚Üí\n  1236‚Üí        // Vertical crosshair line (bottom) with mil-dots\n  1237‚Üí        var vLineBottom = new Line2D\n  1238‚Üí        {\n  1239‚Üí            Name = \"VLineBottom\",\n  1240‚Üí            Width = 2.0f,\n  1241‚Üí            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n  1242‚Üí        };\n  1243‚Üí        vLineBottom.AddPoint(new Vector2(0, innerRadius));\n  1244‚Üí        vLineBottom.AddPoint(new Vector2(0, circleRadius));\n  1245‚Üí        _scopeCrosshair.AddChild(vLineBottom);\n  1246‚Üí\n  1247‚Üí        // Add mil-dot markers on the bottom crosshair (range estimation)\n  1248‚Üí        float dotSpacing = circleRadius * 0.15f;\n  1249‚Üí        for (int i = 1; i <= 4; i++)\n  1250‚Üí        {\n  1251‚Üí            float dotY = dotSpacing * i;\n  1252‚Üí            var dot = new Line2D\n  1253‚Üí            {\n  1254‚Üí                Name = $\"MilDot_{i}\",\n  1255‚Üí                Width = 3.0f,\n  1256‚Üí                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n  1257‚Üí            };\n  1258‚Üí            float dotWidth = 4.0f - i * 0.5f; // Dots get smaller further from center\n  1259‚Üí            dot.AddPoint(new Vector2(-dotWidth, dotY));\n  1260‚Üí            dot.AddPoint(new Vector2(dotWidth, dotY));\n  1261‚Üí            _scopeCrosshair.AddChild(dot);\n  1262‚Üí        }\n  1263‚Üí\n  1264‚Üí        // Add mil-dot markers on horizontal lines\n  1265‚Üí        for (int i = 1; i <= 3; i++)\n  1266‚Üí        {\n  1267‚Üí            float dotX = dotSpacing * i;\n  1268‚Üí            // Right side dots\n  1269‚Üí            var dotRight = new Line2D\n  1270‚Üí            {\n  1271‚Üí                Name = $\"HMilDotRight_{i}\",\n  1272‚Üí                Width = 3.0f,\n  1273‚Üí                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n  1274‚Üí            };\n  1275‚Üí            float dotHeight = 4.0f - i * 0.5f;\n  1276‚Üí            dotRight.AddPoint(new Vector2(dotX, -dotHeight));\n  1277‚Üí            dotRight.AddPoint(new Vector2(dotX, dotHeight));\n  1278‚Üí            _scopeCrosshair.AddChild(dotRight);\n  1279‚Üí\n  1280‚Üí            // Left side dots\n  1281‚Üí            var dotLeft = new Line2D\n  1282‚Üí            {\n  1283‚Üí                Name = $\"HMilDotLeft_{i}\",\n  1284‚Üí                Width = 3.0f,\n  1285‚Üí                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n  1286‚Üí            };\n  1287‚Üí            dotLeft.AddPoint(new Vector2(-dotX, -dotHeight));\n  1288‚Üí            dotLeft.AddPoint(new Vector2(-dotX, dotHeight));\n  1289‚Üí            _scopeCrosshair.AddChild(dotLeft);\n  1290‚Üí        }\n  1291‚Üí\n  1292‚Üí        // Add thick outer ring to mask edges (simulate scope tube)\n  1293‚Üí        var scopeRing = new Line2D\n  1294‚Üí        {\n  1295‚Üí            Name = \"ScopeRing\",\n  1296‚Üí            Width = 6.0f,\n  1297‚Üí            DefaultColor = new Color(0.1f, 0.1f, 0.1f, 0.95f),\n  1298‚Üí            Antialiased = true\n  1299‚Üí        };\n  1300‚Üí        float ringRadius = circleRadius + 3.0f;\n  1301‚Üí        for (int i = 0; i <= segments; i++)\n  1302‚Üí        {\n  1303‚Üí            float angle = (float)i / segments * Mathf.Tau;\n  1304‚Üí            scopeRing.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * ringRadius);\n  1305‚Üí        }\n  1306‚Üí        _scopeCrosshair.AddChild(scopeRing);\n  1307‚Üí\n  1308‚Üí        // Zoom distance indicator text\n  1309‚Üí        var zoomLabel = new Label\n  1310‚Üí        {\n  1311‚Üí            Name = \"ZoomLabel\",\n  1312‚Üí            Position = new Vector2(circleRadius * 0.5f, circleRadius * 0.7f),\n  1313‚Üí            Text = $\"{_scopeZoomDistance:F1}x\",\n  1314‚Üí            HorizontalAlignment = HorizontalAlignment.Center,\n  1315‚Üí            MouseFilter = Control.MouseFilterEnum.Ignore\n  1316‚Üí        };\n  1317‚Üí        zoomLabel.AddThemeColorOverride(\"font_color\", new Color(0.0f, 0.0f, 0.0f, 0.6f));\n  1318‚Üí        zoomLabel.AddThemeFontSizeOverride(\"font_size\", 12);\n  1319‚Üí        _scopeCrosshair.AddChild(zoomLabel);\n  1320‚Üí\n  1321‚Üí        GetTree().CurrentScene.AddChild(_scopeOverlay);\n  1322‚Üí    }\n  1323‚Üí\n  1324‚Üí    /// <summary>\n  1325‚Üí    /// Updates the scope overlay crosshair position with sway applied.\n  1326‚Üí    /// </summary>\n  1327‚Üí    private void UpdateScopeOverlayPosition()\n  1328‚Üí    {\n  1329‚Üí        if (_scopeCrosshair == null || _scopeOverlay == null)\n  1330‚Üí        {\n  1331‚Üí            return;\n  1332‚Üí        }\n  1333‚Üí\n  1334‚Üí        Viewport? viewport = GetViewport();\n  1335‚Üí        if (viewport == null)\n  1336‚Üí        {\n  1337‚Üí            return;\n  1338‚Üí        }\n  1339‚Üí\n  1340‚Üí        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n  1341‚Üí\n  1342‚Üí        // Crosshair stays centered but sways\n  1343‚Üí        _scopeCrosshair.Position = viewportSize / 2 + _scopeSwayOffset;\n  1344‚Üí\n  1345‚Üí        // Update zoom label\n  1346‚Üí        var zoomLabel = _scopeCrosshair.GetNodeOrNull<Label>(\"ZoomLabel\");\n  1347‚Üí        if (zoomLabel != null)\n  1348‚Üí        {\n  1349‚Üí            zoomLabel.Text = $\"{_scopeZoomDistance:F1}x\";\n  1350‚Üí        }\n  1351‚Üí    }\n  1352‚Üí\n  1353‚Üí    /// <summary>\n  1354‚Üí    /// Removes the scope overlay from the scene.\n  1355‚Üí    /// </summary>\n  1356‚Üí    private void RemoveScopeOverlay()\n  1357‚Üí    {\n  1358‚Üí        if (_scopeOverlay != null && IsInstanceValid(_scopeOverlay))\n  1359‚Üí        {\n  1360‚Üí            _scopeOverlay.QueueFree();\n  1361‚Üí            _scopeOverlay = null;\n  1362‚Üí            _scopeCrosshair = null;\n  1363‚Üí            _scopeBackground = null;\n  1364‚Üí        }\n  1365‚Üí    }\n  1366‚Üí}\n  1367‚Üí\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "50d4dae1-d9b9-4f22-88ef-876efab4f92e",
  "tool_use_result": {
    "type": "text",
    "file": {
      "filePath": "/tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs",
      "content": "using Godot;\nusing GodotTopDownTemplate.AbstractClasses;\nusing GodotTopDownTemplate.Projectiles;\n\nnamespace GodotTopDownTemplate.Weapons;\n\n/// <summary>\n/// Bolt-action charging state for the ASVK sniper rifle.\n/// Before each shot, the player must complete a 4-step bolt-action sequence:\n/// Down (pull bolt back) ‚Üí Left (open bolt) ‚Üí Down (close bolt) ‚Üí Up (chamber round)\n/// </summary>\npublic enum BoltActionStep\n{\n    /// <summary>\n    /// Bolt is ready - weapon can fire. After firing, transitions to NeedsBoltCycle.\n    /// </summary>\n    Ready,\n\n    /// <summary>\n    /// Just fired - needs bolt cycling before next shot.\n    /// Waiting for Down arrow (pull bolt back).\n    /// </summary>\n    NeedsBoltCycle,\n\n    /// <summary>\n    /// Step 1 complete (bolt pulled back). Waiting for Left arrow (open bolt).\n    /// </summary>\n    WaitOpenBolt,\n\n    /// <summary>\n    /// Step 2 complete (bolt opened). Waiting for Down arrow (close bolt).\n    /// </summary>\n    WaitCloseBolt,\n\n    /// <summary>\n    /// Step 3 complete (bolt closed). Waiting for Up arrow (chamber round).\n    /// </summary>\n    WaitChamberRound\n}\n\n/// <summary>\n/// ASVK sniper rifle - heavy anti-materiel bolt-action rifle.\n/// Features:\n/// - 12.7x108mm ammunition dealing 50 damage per shot\n/// - Penetrates through 2 walls and through enemies\n/// - Instant bullet speed with smoky dissipating tracer trail\n/// - Very high turn sensitivity\n/// - 5-round magazine with M16-style swap reload\n/// - Single-shot bolt-action with manual charging sequence (Down‚ÜíLeft‚ÜíDown‚ÜíUp)\n/// - Red laser sight for aiming\n/// Reference: ASVK (–ê–°–í–ö) anti-materiel sniper rifle\n/// </summary>\npublic partial class SniperRifle : BaseWeapon\n{\n    // =========================================================================\n    // Bolt-Action State\n    // =========================================================================\n\n    /// <summary>\n    /// Current bolt-action charging step.\n    /// </summary>\n    private BoltActionStep _boltStep = BoltActionStep.Ready;\n\n    /// <summary>\n    /// Whether the bolt action is ready to fire (chambered).\n    /// Initially true so first shot can be fired immediately.\n    /// </summary>\n    public bool IsBoltReady => _boltStep == BoltActionStep.Ready;\n\n    /// <summary>\n    /// Whether the weapon needs bolt cycling before it can fire again.\n    /// </summary>\n    public bool NeedsBoltCycle => _boltStep != BoltActionStep.Ready;\n\n    /// <summary>\n    /// Signal emitted when bolt-action step changes.\n    /// </summary>\n    [Signal]\n    public delegate void BoltStepChangedEventHandler(int step, int totalSteps);\n\n    // =========================================================================\n    // Smoky Tracer Trail\n    // =========================================================================\n\n    /// <summary>\n    /// Scene for the smoky tracer trail effect.\n    /// Created programmatically as a Line2D with smoke-like appearance.\n    /// </summary>\n    private Line2D? _lastTracerTrail;\n\n    // =========================================================================\n    // Laser Sight Configuration\n    // =========================================================================\n\n    /// <summary>\n    /// Whether the laser sight is enabled.\n    /// </summary>\n    [Export]\n    public bool LaserSightEnabled { get; set; } = true;\n\n    /// <summary>\n    /// Maximum length of the laser sight in pixels.\n    /// </summary>\n    [Export]\n    public float LaserSightLength { get; set; } = 500.0f;\n\n    /// <summary>\n    /// Color of the laser sight (red for sniper).\n    /// </summary>\n    [Export]\n    public Color LaserSightColor { get; set; } = new Color(1.0f, 0.0f, 0.0f, 0.5f);\n\n    /// <summary>\n    /// Width of the laser sight line.\n    /// </summary>\n    [Export]\n    public float LaserSightWidth { get; set; } = 2.0f;\n\n    /// <summary>\n    /// Reference to the Line2D node for the laser sight.\n    /// </summary>\n    private Line2D? _laserSight;\n\n    /// <summary>\n    /// Reference to the Sprite2D node for the rifle visual.\n    /// </summary>\n    private Sprite2D? _rifleSprite;\n\n    /// <summary>\n    /// Current aim direction based on laser sight.\n    /// </summary>\n    private Vector2 _aimDirection = Vector2.Right;\n\n    /// <summary>\n    /// Current aim angle in radians.\n    /// </summary>\n    private float _currentAimAngle = 0.0f;\n\n    /// <summary>\n    /// Whether the aim angle has been initialized.\n    /// </summary>\n    private bool _aimAngleInitialized = false;\n\n    /// <summary>\n    /// Current recoil offset angle in radians.\n    /// Heavy sniper recoil.\n    /// </summary>\n    private float _recoilOffset = 0.0f;\n\n    /// <summary>\n    /// Time since the last shot was fired, used for recoil recovery.\n    /// </summary>\n    private float _timeSinceLastShot = 0.0f;\n\n    /// <summary>\n    /// Time in seconds before recoil starts recovering.\n    /// Long delay for heavy sniper.\n    /// </summary>\n    private const float RecoilRecoveryDelay = 0.5f;\n\n    /// <summary>\n    /// Speed at which recoil recovers (radians per second).\n    /// </summary>\n    private const float RecoilRecoverySpeed = 3.0f;\n\n    /// <summary>\n    /// Maximum recoil offset in radians (about 15 degrees).\n    /// </summary>\n    private const float MaxRecoilOffset = 0.26f;\n\n    /// <summary>\n    /// Recoil amount per shot in radians.\n    /// Heavy kick for 12.7mm.\n    /// </summary>\n    private const float RecoilPerShot = 0.15f;\n\n    /// <summary>\n    /// Number of walls this bullet can penetrate through.\n    /// The bullet continues flying after penetrating walls.\n    /// </summary>\n    private const int MaxWallPenetrations = 2;\n\n    public override void _Ready()\n    {\n        base._Ready();\n\n        // Get the rifle sprite for visual representation\n        _rifleSprite = GetNodeOrNull<Sprite2D>(\"RifleSprite\");\n\n        if (_rifleSprite != null)\n        {\n            var texture = _rifleSprite.Texture;\n            GD.Print($\"[SniperRifle] RifleSprite found: visible={_rifleSprite.Visible}, z_index={_rifleSprite.ZIndex}, texture={(texture != null ? \"loaded\" : \"NULL\")}\");\n        }\n        else\n        {\n            GD.PrintErr(\"[SniperRifle] WARNING: RifleSprite node not found!\");\n        }\n\n        // Check for Power Fantasy mode blue laser\n        var difficultyManager = GetNodeOrNull(\"/root/DifficultyManager\");\n        if (difficultyManager != null)\n        {\n            var shouldForceBlueLaser = difficultyManager.Call(\"should_force_blue_laser_sight\");\n            if (shouldForceBlueLaser.AsBool())\n            {\n                var blueColorVariant = difficultyManager.Call(\"get_power_fantasy_laser_color\");\n                LaserSightColor = blueColorVariant.AsColor();\n                GD.Print($\"[SniperRifle] Power Fantasy mode: laser color set to blue {LaserSightColor}\");\n            }\n        }\n\n        // Get or create the laser sight Line2D\n        _laserSight = GetNodeOrNull<Line2D>(\"LaserSight\");\n\n        if (_laserSight == null && LaserSightEnabled)\n        {\n            CreateLaserSight();\n        }\n        else if (_laserSight != null)\n        {\n            _laserSight.Width = LaserSightWidth;\n            _laserSight.DefaultColor = LaserSightColor;\n            _laserSight.BeginCapMode = Line2D.LineCapMode.Round;\n            _laserSight.EndCapMode = Line2D.LineCapMode.Round;\n\n            if (_laserSight.GetPointCount() < 2)\n            {\n                _laserSight.ClearPoints();\n                _laserSight.AddPoint(Vector2.Zero);\n                _laserSight.AddPoint(Vector2.Right * LaserSightLength);\n            }\n        }\n\n        UpdateLaserSightVisibility();\n        GD.Print(\"[SniperRifle] ASVK initialized - bolt ready, laser sight enabled\");\n    }\n\n    public override void _ExitTree()\n    {\n        // Clean up scope overlay when weapon is removed from scene tree\n        if (_isScopeActive)\n        {\n            DeactivateScope();\n        }\n        base._ExitTree();\n    }\n\n    public override void _Process(double delta)\n    {\n        base._Process(delta);\n\n        // Update time since last shot for recoil recovery\n        _timeSinceLastShot += (float)delta;\n\n        // Recover recoil after delay\n        if (_timeSinceLastShot >= RecoilRecoveryDelay && _recoilOffset != 0)\n        {\n            float recoveryAmount = RecoilRecoverySpeed * (float)delta;\n            _recoilOffset = Mathf.MoveToward(_recoilOffset, 0, recoveryAmount);\n        }\n\n        // Always update aim direction and rifle sprite rotation\n        UpdateAimDirection();\n\n        // Update laser sight to point towards mouse (with recoil offset)\n        if (LaserSightEnabled && _laserSight != null)\n        {\n            UpdateLaserSight();\n        }\n\n        // Handle bolt-action input\n        HandleBoltActionInput();\n\n        // Update scope system (sway, camera offset, overlay)\n        UpdateScope((float)delta);\n    }\n\n    // =========================================================================\n    // Bolt-Action Charging Mechanics\n    // =========================================================================\n\n    /// <summary>\n    /// Handles the bolt-action charging input sequence.\n    /// Sequence: Down (pull bolt) ‚Üí Left (open bolt) ‚Üí Down (close bolt) ‚Üí Up (chamber round)\n    /// Uses the arrow keys / WASD movement input actions.\n    /// </summary>\n    private void HandleBoltActionInput()\n    {\n        switch (_boltStep)\n        {\n            case BoltActionStep.NeedsBoltCycle:\n                // Step 1: Down arrow - pull bolt back\n                if (Input.IsActionJustPressed(\"move_down\"))\n                {\n                    _boltStep = BoltActionStep.WaitOpenBolt;\n                    EmitSignal(SignalName.BoltStepChanged, 1, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 1/4: Bolt pulled back\");\n                }\n                break;\n\n            case BoltActionStep.WaitOpenBolt:\n                // Step 2: Left arrow - open bolt\n                if (Input.IsActionJustPressed(\"move_left\"))\n                {\n                    _boltStep = BoltActionStep.WaitCloseBolt;\n                    EmitSignal(SignalName.BoltStepChanged, 2, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 2/4: Bolt opened\");\n                }\n                break;\n\n            case BoltActionStep.WaitCloseBolt:\n                // Step 3: Down arrow - close bolt\n                if (Input.IsActionJustPressed(\"move_down\"))\n                {\n                    _boltStep = BoltActionStep.WaitChamberRound;\n                    EmitSignal(SignalName.BoltStepChanged, 3, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 3/4: Bolt closed\");\n                }\n                break;\n\n            case BoltActionStep.WaitChamberRound:\n                // Step 4: Up arrow - chamber round\n                if (Input.IsActionJustPressed(\"move_up\"))\n                {\n                    _boltStep = BoltActionStep.Ready;\n                    EmitSignal(SignalName.BoltStepChanged, 4, 4);\n                    PlayBoltChamberSound();\n                    GD.Print(\"[SniperRifle] Bolt step 4/4: Round chambered - READY TO FIRE\");\n                }\n                break;\n\n            case BoltActionStep.Ready:\n                // Already ready, no bolt action needed\n                break;\n        }\n    }\n\n    /// <summary>\n    /// Plays the bolt manipulation sound.\n    /// </summary>\n    private void PlayBoltSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_bolt\"))\n        {\n            audioManager.Call(\"play_m16_bolt\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Plays the bolt chamber/ready sound.\n    /// </summary>\n    private void PlayBoltChamberSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_bolt\"))\n        {\n            audioManager.Call(\"play_m16_bolt\", GlobalPosition);\n        }\n    }\n\n    // =========================================================================\n    // Aiming and Laser Sight\n    // =========================================================================\n\n    /// <summary>\n    /// Updates the aim direction and rifle sprite rotation.\n    /// </summary>\n    private void UpdateAimDirection()\n    {\n        Vector2 mousePos = GetGlobalMousePosition();\n        Vector2 toMouse = mousePos - GlobalPosition;\n        float targetAngle = toMouse.Angle();\n\n        if (!_aimAngleInitialized)\n        {\n            _currentAimAngle = targetAngle;\n            _aimAngleInitialized = true;\n        }\n\n        Vector2 direction;\n\n        // Apply sensitivity for the sniper rifle\n        if (WeaponData != null && WeaponData.Sensitivity > 0)\n        {\n            float angleDiff = Mathf.Wrap(targetAngle - _currentAimAngle, -Mathf.Pi, Mathf.Pi);\n            float rotationSpeed = WeaponData.Sensitivity * 10.0f;\n            float delta = (float)GetProcessDeltaTime();\n            float maxRotation = rotationSpeed * delta;\n            float actualRotation = Mathf.Clamp(angleDiff, -maxRotation, maxRotation);\n            _currentAimAngle += actualRotation;\n            direction = new Vector2(Mathf.Cos(_currentAimAngle), Mathf.Sin(_currentAimAngle));\n        }\n        else\n        {\n            if (toMouse.LengthSquared() > 0.001f)\n            {\n                direction = toMouse.Normalized();\n                _currentAimAngle = targetAngle;\n            }\n            else\n            {\n                direction = _aimDirection;\n            }\n        }\n\n        _aimDirection = direction;\n        UpdateRifleSpriteRotation(direction);\n    }\n\n    /// <summary>\n    /// Creates the laser sight Line2D programmatically.\n    /// </summary>\n    private void CreateLaserSight()\n    {\n        _laserSight = new Line2D\n        {\n            Name = \"LaserSight\",\n            Width = LaserSightWidth,\n            DefaultColor = LaserSightColor,\n            BeginCapMode = Line2D.LineCapMode.Round,\n            EndCapMode = Line2D.LineCapMode.Round\n        };\n\n        _laserSight.AddPoint(Vector2.Zero);\n        _laserSight.AddPoint(Vector2.Right * LaserSightLength);\n\n        AddChild(_laserSight);\n    }\n\n    /// <summary>\n    /// Updates the laser sight visualization with recoil offset.\n    /// Uses raycasting to stop at obstacles.\n    /// </summary>\n    private void UpdateLaserSight()\n    {\n        if (_laserSight == null)\n        {\n            return;\n        }\n\n        Vector2 laserDirection = _aimDirection.Rotated(_recoilOffset);\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float maxLaserLength = viewportSize.Length();\n\n        Vector2 endPoint = laserDirection * maxLaserLength;\n\n        var spaceState = GetWorld2D().DirectSpaceState;\n        var query = PhysicsRayQueryParameters2D.Create(\n            GlobalPosition,\n            GlobalPosition + endPoint,\n            4 // Collision mask for obstacles (layer 3 = value 4)\n        );\n\n        var result = spaceState.IntersectRay(query);\n\n        if (result.Count > 0)\n        {\n            Vector2 hitPosition = (Vector2)result[\"position\"];\n            endPoint = hitPosition - GlobalPosition;\n        }\n\n        _laserSight.SetPointPosition(0, Vector2.Zero);\n        _laserSight.SetPointPosition(1, endPoint);\n    }\n\n    /// <summary>\n    /// Updates the visibility of the laser sight.\n    /// </summary>\n    private void UpdateLaserSightVisibility()\n    {\n        if (_laserSight != null)\n        {\n            _laserSight.Visible = LaserSightEnabled;\n        }\n    }\n\n    /// <summary>\n    /// Updates the rifle sprite rotation to match aim direction.\n    /// </summary>\n    private void UpdateRifleSpriteRotation(Vector2 direction)\n    {\n        if (_rifleSprite == null)\n        {\n            return;\n        }\n\n        float angle = direction.Angle();\n        _rifleSprite.Rotation = angle;\n\n        bool aimingLeft = Mathf.Abs(angle) > Mathf.Pi / 2;\n        _rifleSprite.FlipV = aimingLeft;\n    }\n\n    /// <summary>\n    /// Enables or disables the laser sight.\n    /// </summary>\n    public void SetLaserSightEnabled(bool enabled)\n    {\n        LaserSightEnabled = enabled;\n        UpdateLaserSightVisibility();\n    }\n\n    // =========================================================================\n    // Firing\n    // =========================================================================\n\n    /// <summary>\n    /// Fires the sniper rifle. Only fires if bolt is ready.\n    /// After firing, transitions to NeedsBoltCycle state.\n    /// </summary>\n    public override bool Fire(Vector2 direction)\n    {\n        // Check for empty magazine\n        if (CurrentAmmo <= 0)\n        {\n            PlayEmptyClickSound();\n            return false;\n        }\n\n        // Check if bolt is ready\n        if (!IsBoltReady)\n        {\n            // Play a click to indicate bolt not cycled\n            PlayEmptyClickSound();\n            return false;\n        }\n\n        // Check standard fire conditions\n        if (!CanFire || WeaponData == null || BulletScene == null)\n        {\n            return false;\n        }\n\n        // Apply recoil to aim direction\n        Vector2 spreadDirection = ApplyRecoil(_aimDirection);\n        bool result = base.Fire(spreadDirection);\n\n        if (result)\n        {\n            // Transition to needs bolt cycle\n            _boltStep = BoltActionStep.NeedsBoltCycle;\n            EmitSignal(SignalName.BoltStepChanged, 0, 4);\n\n            // Play sniper shot sound\n            PlaySniperShotSound();\n            // Emit gunshot sound for enemy detection\n            EmitGunshotSound();\n            // Play shell casing with delay\n            PlayShellCasingDelayed();\n            // Trigger heavy screen shake\n            TriggerScreenShake(spreadDirection);\n\n            // Spawn smoky tracer trail\n            SpawnSmokyTracer(GlobalPosition, spreadDirection);\n\n            GD.Print(\"[SniperRifle] FIRED! Bolt needs cycling. Ammo remaining: \" + CurrentAmmo);\n        }\n\n        return result;\n    }\n\n    /// <summary>\n    /// Override SpawnBullet to configure the SniperBullet for sniper behavior:\n    /// - Very high damage (50)\n    /// - Passes through enemies (doesn't destroy on hit)\n    /// - Penetrates through 2 walls (wall-count based, not distance-based)\n    /// </summary>\n    protected override void SpawnBullet(Vector2 direction)\n    {\n        if (BulletScene == null)\n        {\n            return;\n        }\n\n        // Check bullet spawn path\n        var (isBlocked, hitPosition, hitNormal) = CheckBulletSpawnPath(direction);\n\n        Vector2 spawnPosition;\n        if (isBlocked)\n        {\n            spawnPosition = GlobalPosition + direction * 2.0f;\n            GD.Print(\"[SniperRifle] Point-blank shot: spawning for penetration\");\n        }\n        else\n        {\n            spawnPosition = GlobalPosition + direction * BulletSpawnOffset;\n        }\n\n        var bulletNode = BulletScene.Instantiate<Node2D>();\n        bulletNode.GlobalPosition = spawnPosition;\n\n        // Try to cast to C# SniperBullet for direct property access\n        var sniperBullet = bulletNode as SniperBullet;\n\n        if (sniperBullet != null)\n        {\n            // SniperBullet - set properties directly\n            sniperBullet.Direction = direction;\n            if (WeaponData != null)\n            {\n                sniperBullet.Speed = WeaponData.BulletSpeed;\n                sniperBullet.Damage = WeaponData.Damage;\n            }\n            var owner = GetParent();\n            if (owner != null)\n            {\n                sniperBullet.ShooterId = owner.GetInstanceId();\n            }\n            sniperBullet.ShooterPosition = GlobalPosition;\n            sniperBullet.MaxWallPenetrations = MaxWallPenetrations;\n            GD.Print($\"[SniperRifle] Spawned SniperBullet: Damage={sniperBullet.Damage}, Speed={sniperBullet.Speed}, MaxWallPen={MaxWallPenetrations}\");\n        }\n        else\n        {\n            // Fallback for any bullet type\n            if (bulletNode.HasMethod(\"SetDirection\"))\n            {\n                bulletNode.Call(\"SetDirection\", direction);\n            }\n            else\n            {\n                bulletNode.Set(\"Direction\", direction);\n                bulletNode.Set(\"direction\", direction);\n            }\n\n            if (WeaponData != null)\n            {\n                bulletNode.Set(\"Speed\", WeaponData.BulletSpeed);\n                bulletNode.Set(\"speed\", WeaponData.BulletSpeed);\n                bulletNode.Set(\"Damage\", WeaponData.Damage);\n                bulletNode.Set(\"damage\", WeaponData.Damage);\n            }\n\n            var owner = GetParent();\n            if (owner != null)\n            {\n                bulletNode.Set(\"ShooterId\", owner.GetInstanceId());\n                bulletNode.Set(\"shooter_id\", owner.GetInstanceId());\n            }\n\n            bulletNode.Set(\"ShooterPosition\", GlobalPosition);\n            bulletNode.Set(\"shooter_position\", GlobalPosition);\n        }\n\n        GetTree().CurrentScene.AddChild(bulletNode);\n\n        // Spawn muzzle flash effect - large flash for 12.7mm\n        SpawnMuzzleFlash(spawnPosition, direction, WeaponData?.Caliber);\n\n        // Spawn casing\n        SpawnCasing(direction, WeaponData?.Caliber);\n    }\n\n    // =========================================================================\n    // Smoky Tracer Trail\n    // =========================================================================\n\n    /// <summary>\n    /// Spawns a smoky dissipating tracer trail from the fire position\n    /// in the shooting direction across the entire map.\n    /// The tracer is an instant visual effect (like a contrail from a plane)\n    /// that fades out over time.\n    /// </summary>\n    private void SpawnSmokyTracer(Vector2 fromPosition, Vector2 direction)\n    {\n        // Calculate tracer end point - extend to edge of map (very far)\n        float tracerLength = 5000.0f; // Far enough to reach any map edge\n        Vector2 endPosition = fromPosition + direction * tracerLength;\n\n        // Create the tracer as a Line2D with smoke-like appearance\n        var tracer = new Line2D\n        {\n            Name = \"SniperTracer\",\n            Width = 6.0f,\n            DefaultColor = new Color(0.8f, 0.8f, 0.8f, 0.7f),\n            BeginCapMode = Line2D.LineCapMode.Round,\n            EndCapMode = Line2D.LineCapMode.Round,\n            TopLevel = true,\n            Position = Vector2.Zero,\n            ZIndex = -1 // Behind other elements\n        };\n\n        // Set up width curve - wider at start, tapers to narrower at end\n        var widthCurve = new Curve();\n        widthCurve.AddPoint(new Vector2(0.0f, 1.0f));\n        widthCurve.AddPoint(new Vector2(0.3f, 0.8f));\n        widthCurve.AddPoint(new Vector2(1.0f, 0.3f));\n        tracer.WidthCurve = widthCurve;\n\n        // Set up gradient - smoky white/gray that fades out\n        var gradient = new Gradient();\n        gradient.SetColor(0, new Color(0.9f, 0.9f, 0.85f, 0.8f));\n        gradient.AddPoint(0.5f, new Color(0.7f, 0.7f, 0.65f, 0.5f));\n        gradient.SetColor(gradient.GetPointCount() - 1, new Color(0.5f, 0.5f, 0.5f, 0.2f));\n        tracer.Gradient = gradient;\n\n        // Add the tracer line points (using global coordinates since TopLevel=true)\n        tracer.AddPoint(fromPosition + direction * BulletSpawnOffset);\n        tracer.AddPoint(endPosition);\n\n        // Add to scene\n        GetTree().CurrentScene.AddChild(tracer);\n\n        // Start the fade-out animation\n        FadeOutTracer(tracer);\n    }\n\n    /// <summary>\n    /// Animates the tracer trail fading out and dissipating over time.\n    /// The tracer gradually becomes more transparent and wider (simulating smoke dissipation).\n    /// </summary>\n    private async void FadeOutTracer(Line2D tracer)\n    {\n        float fadeDuration = 2.0f;\n        float elapsed = 0.0f;\n\n        float initialWidth = tracer.Width;\n\n        while (elapsed < fadeDuration && IsInstanceValid(tracer))\n        {\n            elapsed += (float)GetProcessDeltaTime();\n            float progress = elapsed / fadeDuration;\n\n            // Fade the alpha\n            float alpha = Mathf.Lerp(0.7f, 0.0f, progress);\n            tracer.DefaultColor = new Color(0.8f, 0.8f, 0.8f, alpha);\n\n            // Widen slightly to simulate smoke dissipation\n            tracer.Width = initialWidth + progress * 4.0f;\n\n            // Update gradient alpha\n            var gradient = new Gradient();\n            gradient.SetColor(0, new Color(0.9f, 0.9f, 0.85f, alpha));\n            gradient.AddPoint(0.5f, new Color(0.7f, 0.7f, 0.65f, alpha * 0.6f));\n            gradient.SetColor(gradient.GetPointCount() - 1, new Color(0.5f, 0.5f, 0.5f, alpha * 0.3f));\n            tracer.Gradient = gradient;\n\n            await ToSignal(GetTree(), \"process_frame\");\n        }\n\n        // Remove the tracer after fade completes\n        if (IsInstanceValid(tracer))\n        {\n            tracer.QueueFree();\n        }\n    }\n\n    // =========================================================================\n    // Sound and Effects\n    // =========================================================================\n\n    /// <summary>\n    /// Plays the sniper shot sound via AudioManager.\n    /// </summary>\n    private void PlaySniperShotSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        // Use M16 shot as a placeholder sound for the sniper\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_shot\"))\n        {\n            audioManager.Call(\"play_m16_shot\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Plays the empty gun click sound.\n    /// </summary>\n    private void PlayEmptyClickSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_empty_click\"))\n        {\n            audioManager.Call(\"play_empty_click\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Emits gunshot sound for enemy detection via SoundPropagation.\n    /// Very loud for the 12.7mm round.\n    /// </summary>\n    private void EmitGunshotSound()\n    {\n        var soundPropagation = GetNodeOrNull(\"/root/SoundPropagation\");\n        if (soundPropagation != null && soundPropagation.HasMethod(\"emit_sound\"))\n        {\n            float loudness = WeaponData?.Loudness ?? 3000.0f;\n            soundPropagation.Call(\"emit_sound\", 0, GlobalPosition, 0, this, loudness);\n        }\n    }\n\n    /// <summary>\n    /// Plays shell casing sound with a delay.\n    /// </summary>\n    private async void PlayShellCasingDelayed()\n    {\n        await ToSignal(GetTree().CreateTimer(0.2), \"timeout\");\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_shell_rifle\"))\n        {\n            audioManager.Call(\"play_shell_rifle\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Applies recoil to shooting direction.\n    /// </summary>\n    private Vector2 ApplyRecoil(Vector2 direction)\n    {\n        // Apply current recoil offset\n        Vector2 result = direction.Rotated(_recoilOffset);\n\n        // Add strong recoil for next shot (heavy 12.7mm kick)\n        float recoilDirection = (float)GD.RandRange(-1.0, 1.0);\n        _recoilOffset += recoilDirection * RecoilPerShot;\n        _recoilOffset = Mathf.Clamp(_recoilOffset, -MaxRecoilOffset, MaxRecoilOffset);\n\n        _timeSinceLastShot = 0;\n\n        return result;\n    }\n\n    /// <summary>\n    /// Triggers screen shake from sniper shot.\n    /// Heavy shake for 12.7mm round.\n    /// </summary>\n    private void TriggerScreenShake(Vector2 shootDirection)\n    {\n        if (WeaponData == null || WeaponData.ScreenShakeIntensity <= 0)\n        {\n            return;\n        }\n\n        var screenShakeManager = GetNodeOrNull(\"/root/ScreenShakeManager\");\n        if (screenShakeManager == null || !screenShakeManager.HasMethod(\"add_shake\"))\n        {\n            return;\n        }\n\n        // Heavy shake for sniper\n        float fireRate = WeaponData.FireRate;\n        float shakeIntensity;\n        if (fireRate > 0)\n        {\n            shakeIntensity = WeaponData.ScreenShakeIntensity / fireRate * 10.0f;\n        }\n        else\n        {\n            shakeIntensity = WeaponData.ScreenShakeIntensity;\n        }\n\n        float recoveryTime = WeaponData.ScreenShakeMinRecoveryTime;\n\n        screenShakeManager.Call(\"add_shake\", shootDirection, shakeIntensity, recoveryTime);\n    }\n\n    /// <summary>\n    /// Fires the bullet in the chamber during reload sequence.\n    /// </summary>\n    public override bool FireChamberBullet(Vector2 direction)\n    {\n        // Sniper rifle doesn't support chamber bullet during reload\n        // (bolt-action requires full cycle)\n        return false;\n    }\n\n    /// <summary>\n    /// Gets the current aim direction.\n    /// </summary>\n    public Vector2 AimDirection => _aimDirection;\n\n    /// <summary>\n    /// Gets the current bolt-action step.\n    /// </summary>\n    public BoltActionStep CurrentBoltStep => _boltStep;\n\n    /// <summary>\n    /// Resets the bolt to ready state (e.g., after reload with a new magazine).\n    /// </summary>\n    public void ResetBolt()\n    {\n        _boltStep = BoltActionStep.Ready;\n        EmitSignal(SignalName.BoltStepChanged, 4, 4);\n        GD.Print(\"[SniperRifle] Bolt reset to ready state\");\n    }\n\n    // =========================================================================\n    // Scope / Aiming System (RMB)\n    // =========================================================================\n\n    /// <summary>\n    /// Whether the scope is currently active (RMB held).\n    /// </summary>\n    private bool _isScopeActive = false;\n\n    /// <summary>\n    /// Whether the scope is active (read-only property for external access).\n    /// </summary>\n    public bool IsScopeActive => _isScopeActive;\n\n    /// <summary>\n    /// Signal emitted when scope state changes.\n    /// </summary>\n    [Signal]\n    public delegate void ScopeStateChangedEventHandler(bool isActive);\n\n    /// <summary>\n    /// Current scope zoom distance multiplier (how far beyond viewport the player can see).\n    /// 1.0 = one viewport distance, 2.0 = two viewport distances.\n    /// Controlled by mouse wheel while scoping.\n    /// </summary>\n    private float _scopeZoomDistance = 1.0f;\n\n    /// <summary>\n    /// Minimum scope zoom distance (viewport multiplier).\n    /// </summary>\n    private const float MinScopeZoomDistance = 0.5f;\n\n    /// <summary>\n    /// Maximum scope zoom distance (viewport multiplier).\n    /// </summary>\n    private const float MaxScopeZoomDistance = 3.0f;\n\n    /// <summary>\n    /// Step size for mouse wheel zoom adjustment.\n    /// </summary>\n    private const float ScopeZoomStep = 0.25f;\n\n    /// <summary>\n    /// Base sway amplitude in pixels at 1 viewport distance.\n    /// </summary>\n    private const float BaseScopeSwayAmplitude = 8.0f;\n\n    /// <summary>\n    /// Speed of the sway oscillation.\n    /// </summary>\n    private const float ScopeSwaySpeed = 2.5f;\n\n    /// <summary>\n    /// Current scope sway time accumulator.\n    /// </summary>\n    private float _scopeSwayTime = 0.0f;\n\n    /// <summary>\n    /// Current scope sway offset in pixels (applied to camera).\n    /// </summary>\n    private Vector2 _scopeSwayOffset = Vector2.Zero;\n\n    /// <summary>\n    /// Reference to the scope overlay CanvasLayer (created when scope activates).\n    /// </summary>\n    private CanvasLayer? _scopeOverlay = null;\n\n    /// <summary>\n    /// Reference to the scope crosshair control node.\n    /// </summary>\n    private Control? _scopeCrosshair = null;\n\n    /// <summary>\n    /// Reference to the scope darkening background.\n    /// </summary>\n    private ColorRect? _scopeBackground = null;\n\n    /// <summary>\n    /// Cached reference to the player's Camera2D node.\n    /// </summary>\n    private Camera2D? _playerCamera = null;\n\n    /// <summary>\n    /// Original camera offset before scoping (to restore on exit).\n    /// </summary>\n    private Vector2 _originalCameraOffset = Vector2.Zero;\n\n    /// <summary>\n    /// Gets the current camera offset for scope aiming.\n    /// Called by the player or level scripts to position the camera.\n    /// </summary>\n    public Vector2 GetScopeCameraOffset()\n    {\n        if (!_isScopeActive)\n        {\n            return Vector2.Zero;\n        }\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return Vector2.Zero;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float baseDistance = viewportSize.Length() * 0.5f;\n\n        // Camera offset = aim direction * zoom distance * viewport size + sway\n        Vector2 offset = _aimDirection * baseDistance * _scopeZoomDistance + _scopeSwayOffset;\n\n        return offset;\n    }\n\n    /// <summary>\n    /// Activates the scope (called when RMB is pressed).\n    /// </summary>\n    public void ActivateScope()\n    {\n        if (_isScopeActive)\n        {\n            return;\n        }\n\n        _isScopeActive = true;\n        _scopeSwayTime = 0.0f;\n\n        // Find and cache the player's Camera2D\n        FindPlayerCamera();\n\n        // Store original camera offset\n        if (_playerCamera != null)\n        {\n            _originalCameraOffset = _playerCamera.Offset;\n        }\n\n        // Create the scope overlay\n        CreateScopeOverlay();\n\n        EmitSignal(SignalName.ScopeStateChanged, true);\n        GD.Print($\"[SniperRifle] Scope activated. Zoom distance: {_scopeZoomDistance:F1}x\");\n    }\n\n    /// <summary>\n    /// Deactivates the scope (called when RMB is released).\n    /// </summary>\n    public void DeactivateScope()\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        _isScopeActive = false;\n\n        // Restore original camera offset\n        if (_playerCamera != null)\n        {\n            _playerCamera.Offset = _originalCameraOffset;\n        }\n\n        // Remove scope overlay\n        RemoveScopeOverlay();\n\n        EmitSignal(SignalName.ScopeStateChanged, false);\n        GD.Print(\"[SniperRifle] Scope deactivated.\");\n    }\n\n    /// <summary>\n    /// Adjusts the scope zoom distance (called on mouse wheel while scoping).\n    /// </summary>\n    public void AdjustScopeZoom(float direction)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        _scopeZoomDistance += direction * ScopeZoomStep;\n        _scopeZoomDistance = Mathf.Clamp(_scopeZoomDistance, MinScopeZoomDistance, MaxScopeZoomDistance);\n\n        GD.Print($\"[SniperRifle] Scope zoom adjusted: {_scopeZoomDistance:F2}x\");\n    }\n\n    /// <summary>\n    /// Finds the player's Camera2D node by traversing up to the parent (player).\n    /// </summary>\n    private void FindPlayerCamera()\n    {\n        if (_playerCamera != null)\n        {\n            return;\n        }\n\n        var parent = GetParent();\n        if (parent != null)\n        {\n            _playerCamera = parent.GetNodeOrNull<Camera2D>(\"Camera2D\");\n        }\n    }\n\n    /// <summary>\n    /// Updates the scope system each frame (called from _Process).\n    /// </summary>\n    private void UpdateScope(float delta)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        // Update sway\n        _scopeSwayTime += delta;\n        float swayAmplitude = BaseScopeSwayAmplitude * _scopeZoomDistance;\n\n        // Use two sine waves at different frequencies for natural-looking sway\n        float swayX = Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 1.0f) * swayAmplitude\n                    + Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 2.3f) * swayAmplitude * 0.3f;\n        float swayY = Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 1.4f) * swayAmplitude\n                    + Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 0.7f) * swayAmplitude * 0.4f;\n\n        _scopeSwayOffset = new Vector2(swayX, swayY);\n\n        // Update camera offset for scope view\n        if (_playerCamera != null)\n        {\n            _playerCamera.Offset = _originalCameraOffset + GetScopeCameraOffset();\n        }\n\n        // Update scope overlay crosshair position with sway\n        UpdateScopeOverlayPosition();\n    }\n\n    /// <summary>\n    /// Creates the scope overlay UI with crosshair and darkened edges.\n    /// </summary>\n    private void CreateScopeOverlay()\n    {\n        RemoveScopeOverlay();\n\n        _scopeOverlay = new CanvasLayer\n        {\n            Name = \"ScopeOverlay\",\n            Layer = 10\n        };\n\n        Viewport? viewport = GetViewport();\n        Vector2 viewportSize = viewport?.GetVisibleRect().Size ?? new Vector2(1280, 720);\n\n        // Dark background with circular cutout effect (vignette)\n        _scopeBackground = new ColorRect\n        {\n            Name = \"ScopeBackground\",\n            Color = new Color(0.0f, 0.0f, 0.0f, 0.5f),\n            Size = viewportSize,\n            Position = Vector2.Zero,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        _scopeOverlay.AddChild(_scopeBackground);\n\n        // Create the crosshair as a Control node\n        _scopeCrosshair = new Control\n        {\n            Name = \"ScopeCrosshair\",\n            Position = viewportSize / 2,\n            Size = Vector2.Zero,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        _scopeOverlay.AddChild(_scopeCrosshair);\n\n        // Add crosshair lines - based on the reference image from the issue\n        // The scope has a classic crosshair with circle and mil-dots\n\n        // Outer circle\n        float circleRadius = Mathf.Min(viewportSize.X, viewportSize.Y) * 0.35f;\n        int segments = 64;\n        var outerCircle = new Line2D\n        {\n            Name = \"OuterCircle\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f),\n            Antialiased = true\n        };\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            outerCircle.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * circleRadius);\n        }\n        _scopeCrosshair.AddChild(outerCircle);\n\n        // Inner thin circle\n        float innerRadius = circleRadius * 0.05f;\n        var innerCircle = new Line2D\n        {\n            Name = \"InnerCircle\",\n            Width = 1.5f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f),\n            Antialiased = true\n        };\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            innerCircle.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * innerRadius);\n        }\n        _scopeCrosshair.AddChild(innerCircle);\n\n        // Horizontal crosshair line (left)\n        var hLineLeft = new Line2D\n        {\n            Name = \"HLineLeft\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        hLineLeft.AddPoint(new Vector2(-circleRadius, 0));\n        hLineLeft.AddPoint(new Vector2(-innerRadius, 0));\n        _scopeCrosshair.AddChild(hLineLeft);\n\n        // Horizontal crosshair line (right)\n        var hLineRight = new Line2D\n        {\n            Name = \"HLineRight\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        hLineRight.AddPoint(new Vector2(innerRadius, 0));\n        hLineRight.AddPoint(new Vector2(circleRadius, 0));\n        _scopeCrosshair.AddChild(hLineRight);\n\n        // Vertical crosshair line (top)\n        var vLineTop = new Line2D\n        {\n            Name = \"VLineTop\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        vLineTop.AddPoint(new Vector2(0, -circleRadius));\n        vLineTop.AddPoint(new Vector2(0, -innerRadius));\n        _scopeCrosshair.AddChild(vLineTop);\n\n        // Vertical crosshair line (bottom) with mil-dots\n        var vLineBottom = new Line2D\n        {\n            Name = \"VLineBottom\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        vLineBottom.AddPoint(new Vector2(0, innerRadius));\n        vLineBottom.AddPoint(new Vector2(0, circleRadius));\n        _scopeCrosshair.AddChild(vLineBottom);\n\n        // Add mil-dot markers on the bottom crosshair (range estimation)\n        float dotSpacing = circleRadius * 0.15f;\n        for (int i = 1; i <= 4; i++)\n        {\n            float dotY = dotSpacing * i;\n            var dot = new Line2D\n            {\n                Name = $\"MilDot_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            float dotWidth = 4.0f - i * 0.5f; // Dots get smaller further from center\n            dot.AddPoint(new Vector2(-dotWidth, dotY));\n            dot.AddPoint(new Vector2(dotWidth, dotY));\n            _scopeCrosshair.AddChild(dot);\n        }\n\n        // Add mil-dot markers on horizontal lines\n        for (int i = 1; i <= 3; i++)\n        {\n            float dotX = dotSpacing * i;\n            // Right side dots\n            var dotRight = new Line2D\n            {\n                Name = $\"HMilDotRight_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            float dotHeight = 4.0f - i * 0.5f;\n            dotRight.AddPoint(new Vector2(dotX, -dotHeight));\n            dotRight.AddPoint(new Vector2(dotX, dotHeight));\n            _scopeCrosshair.AddChild(dotRight);\n\n            // Left side dots\n            var dotLeft = new Line2D\n            {\n                Name = $\"HMilDotLeft_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            dotLeft.AddPoint(new Vector2(-dotX, -dotHeight));\n            dotLeft.AddPoint(new Vector2(-dotX, dotHeight));\n            _scopeCrosshair.AddChild(dotLeft);\n        }\n\n        // Add thick outer ring to mask edges (simulate scope tube)\n        var scopeRing = new Line2D\n        {\n            Name = \"ScopeRing\",\n            Width = 6.0f,\n            DefaultColor = new Color(0.1f, 0.1f, 0.1f, 0.95f),\n            Antialiased = true\n        };\n        float ringRadius = circleRadius + 3.0f;\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            scopeRing.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * ringRadius);\n        }\n        _scopeCrosshair.AddChild(scopeRing);\n\n        // Zoom distance indicator text\n        var zoomLabel = new Label\n        {\n            Name = \"ZoomLabel\",\n            Position = new Vector2(circleRadius * 0.5f, circleRadius * 0.7f),\n            Text = $\"{_scopeZoomDistance:F1}x\",\n            HorizontalAlignment = HorizontalAlignment.Center,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        zoomLabel.AddThemeColorOverride(\"font_color\", new Color(0.0f, 0.0f, 0.0f, 0.6f));\n        zoomLabel.AddThemeFontSizeOverride(\"font_size\", 12);\n        _scopeCrosshair.AddChild(zoomLabel);\n\n        GetTree().CurrentScene.AddChild(_scopeOverlay);\n    }\n\n    /// <summary>\n    /// Updates the scope overlay crosshair position with sway applied.\n    /// </summary>\n    private void UpdateScopeOverlayPosition()\n    {\n        if (_scopeCrosshair == null || _scopeOverlay == null)\n        {\n            return;\n        }\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n\n        // Crosshair stays centered but sways\n        _scopeCrosshair.Position = viewportSize / 2 + _scopeSwayOffset;\n\n        // Update zoom label\n        var zoomLabel = _scopeCrosshair.GetNodeOrNull<Label>(\"ZoomLabel\");\n        if (zoomLabel != null)\n        {\n            zoomLabel.Text = $\"{_scopeZoomDistance:F1}x\";\n        }\n    }\n\n    /// <summary>\n    /// Removes the scope overlay from the scene.\n    /// </summary>\n    private void RemoveScopeOverlay()\n    {\n        if (_scopeOverlay != null && IsInstanceValid(_scopeOverlay))\n        {\n            _scopeOverlay.QueueFree();\n            _scopeOverlay = null;\n            _scopeCrosshair = null;\n            _scopeBackground = null;\n        }\n    }\n}\n",
      "numLines": 1367,
      "startLine": 1,
      "totalLines": 1367
    }
  }
}
[2026-02-06T20:56:11.716Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_014diDpLsL4AokM4qGdtxzpS",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01RHfKNVHcGkgNYTjKqMyrVA",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1770411323361/Scripts/Characters/Player.cs"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 389,
      "cache_read_input_tokens": 31492,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 389
      },
      "output_tokens": 25,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "4c0977dd-0d73-4169-9a49-c46a4b56e63d"
}
[2026-02-06T20:56:11.960Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "type": "tool_result",
        "content": "File content (41522 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.",
        "is_error": true,
        "tool_use_id": "toolu_01RHfKNVHcGkgNYTjKqMyrVA"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "47ac65a1-7d97-438d-a87b-6aff8c4ef164",
  "tool_use_result": "Error: File content (41522 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."
}
[2026-02-06T20:56:15.078Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01HSZTTxrqvXffUR3e3Df4fG",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "The Player.cs file is large. Let me read the relevant scope-related parts of it."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 18081,
      "cache_read_input_tokens": 31881,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 18081
      },
      "output_tokens": 1,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "61e8c764-eecb-498b-9007-13024fd0d553"
}
[2026-02-06T20:56:20.464Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01HSZTTxrqvXffUR3e3Df4fG",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_016R5qTtn9MCk9cofB4UdyNS",
        "name": "TodoWrite",
        "input": {
          "todos": [
            {
              "content": "Read and understand current SniperRifle.cs scope implementation",
              "status": "completed",
              "activeForm": "Reading SniperRifle.cs scope implementation"
            },
            {
              "content": "Read and understand Player.cs scope input handling",
              "status": "in_progress",
              "activeForm": "Reading Player.cs scope input handling"
            },
            {
              "content": "Fix #1: Allow slight movement (~1/3 viewport) closer/further while scoped",
              "status": "pending",
              "activeForm": "Implementing scope movement closer/further"
            },
            {
              "content": "Fix #2: Make bullets fly to the center of the crosshair",
              "status": "pending",
              "activeForm": "Fixing bullet aim direction to match crosshair center"
            },
            {
              "content": "Fix #3: Move minimum scope distance half a viewport further",
              "status": "pending",
              "activeForm": "Increasing minimum scope distance by half viewport"
            },
            {
              "content": "Test all changes locally and verify no regressions",
              "status": "pending",
              "activeForm": "Testing changes locally"
            },
            {
              "content": "Commit, push, and update PR description",
              "status": "pending",
              "activeForm": "Committing and pushing changes"
            }
          ]
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 18081,
      "cache_read_input_tokens": 31881,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 18081
      },
      "output_tokens": 1,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "92bd1510-9608-4463-95f2-6188d8188c94"
}
[2026-02-06T20:56:20.467Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_016R5qTtn9MCk9cofB4UdyNS",
        "type": "tool_result",
        "content": "Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "f94fceae-e277-4c15-8634-b27ed9015ec0",
  "tool_use_result": {
    "oldTodos": [
      {
        "content": "Read and understand current SniperRifle.cs scope implementation",
        "status": "in_progress",
        "activeForm": "Reading SniperRifle.cs scope implementation"
      },
      {
        "content": "Read and understand Player.cs scope input handling",
        "status": "pending",
        "activeForm": "Reading Player.cs scope input handling"
      },
      {
        "content": "Fix #1: Allow slight movement (~1/3 viewport) closer/further while scoped",
        "status": "pending",
        "activeForm": "Implementing scope movement closer/further"
      },
      {
        "content": "Fix #2: Make bullets fly to the center of the crosshair",
        "status": "pending",
        "activeForm": "Fixing bullet aim direction to match crosshair center"
      },
      {
        "content": "Fix #3: Move minimum scope distance half a viewport further",
        "status": "pending",
        "activeForm": "Increasing minimum scope distance by half viewport"
      },
      {
        "content": "Test all changes locally and verify no regressions",
        "status": "pending",
        "activeForm": "Testing changes locally"
      },
      {
        "content": "Commit, push, and update PR description",
        "status": "pending",
        "activeForm": "Committing and pushing changes"
      }
    ],
    "newTodos": [
      {
        "content": "Read and understand current SniperRifle.cs scope implementation",
        "status": "completed",
        "activeForm": "Reading SniperRifle.cs scope implementation"
      },
      {
        "content": "Read and understand Player.cs scope input handling",
        "status": "in_progress",
        "activeForm": "Reading Player.cs scope input handling"
      },
      {
        "content": "Fix #1: Allow slight movement (~1/3 viewport) closer/further while scoped",
        "status": "pending",
        "activeForm": "Implementing scope movement closer/further"
      },
      {
        "content": "Fix #2: Make bullets fly to the center of the crosshair",
        "status": "pending",
        "activeForm": "Fixing bullet aim direction to match crosshair center"
      },
      {
        "content": "Fix #3: Move minimum scope distance half a viewport further",
        "status": "pending",
        "activeForm": "Increasing minimum scope distance by half viewport"
      },
      {
        "content": "Test all changes locally and verify no regressions",
        "status": "pending",
        "activeForm": "Testing changes locally"
      },
      {
        "content": "Commit, push, and update PR description",
        "status": "pending",
        "activeForm": "Committing and pushing changes"
      }
    ]
  }
}
[2026-02-06T20:56:25.008Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01VvqdasWV4sK8JzvDamXZTB",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01Sf7vmNQujMKVvzPHVBwiaD",
        "name": "Grep",
        "input": {
          "pattern": "Sniper|scope|Scope|sniper|HandleSniperScope|_UnhandledInput",
          "path": "/tmp/gh-issue-solver-1770411323361/Scripts/Characters/Player.cs",
          "output_mode": "content",
          "-n": true
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 385,
      "cache_read_input_tokens": 49962,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 385
      },
      "output_tokens": 26,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "82b42984-593d-4337-bb41-dc72b081a0bc"
}
[2026-02-06T20:56:25.027Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01Sf7vmNQujMKVvzPHVBwiaD",
        "type": "tool_result",
        "content": "1026:        // Handle sniper scope input (RMB) when SniperRifle is equipped\n1027:        // This takes priority over grenade input since the sniper uses RMB for scoping\n1028:        bool sniperScopeConsumedInput = HandleSniperScopeInput();\n1031:        // Skip if sniper scope already consumed the RMB input\n1032:        if (!sniperScopeConsumedInput)\n1211:        else if (CurrentWeapon is SniperRifle sniperRifle)\n1213:            aimDirection = sniperRifle.AimDirection;\n1894:    #region Sniper Scope System\n1897:    /// Handles sniper scope input when the SniperRifle is equipped.\n1898:    /// RMB activates the scope for aiming beyond the viewport.\n1899:    /// Mouse wheel adjusts zoom distance while scoped.\n1900:    /// Returns true if the sniper scope consumed the RMB input.\n1902:    private bool HandleSniperScopeInput()\n1904:        // Only handle scope when a SniperRifle is the current weapon\n1905:        var sniperRifle = CurrentWeapon as SniperRifle;\n1906:        if (sniperRifle == null)\n1911:        // Handle RMB press to activate scope\n1914:            // Only activate scope if not already in a grenade action\n1917:                sniperRifle.ActivateScope();\n1922:        // Handle RMB release to deactivate scope\n1923:        if (Input.IsActionJustReleased(\"grenade_throw\") && sniperRifle.IsScopeActive)\n1925:            sniperRifle.DeactivateScope();\n1929:        // While scope is active, consume RMB input to prevent grenade handling\n1930:        if (sniperRifle.IsScopeActive)\n1939:    /// Handles mouse wheel input for scope zoom when sniper scope is active.\n1940:    /// This is called from _UnhandledInput to capture wheel events.\n1942:    public override void _UnhandledInput(InputEvent @event)\n1944:        base._UnhandledInput(@event);\n1946:        var sniperRifle = CurrentWeapon as SniperRifle;\n1947:        if (sniperRifle == null || !sniperRifle.IsScopeActive)\n1958:                    sniperRifle.AdjustScopeZoom(1.0f);\n1963:                    sniperRifle.AdjustScopeZoom(-1.0f);"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "3fab8a20-d425-48e1-8bee-ed23c3a6c6dd",
  "tool_use_result": {
    "mode": "content",
    "numFiles": 0,
    "filenames": [],
    "content": "1026:        // Handle sniper scope input (RMB) when SniperRifle is equipped\n1027:        // This takes priority over grenade input since the sniper uses RMB for scoping\n1028:        bool sniperScopeConsumedInput = HandleSniperScopeInput();\n1031:        // Skip if sniper scope already consumed the RMB input\n1032:        if (!sniperScopeConsumedInput)\n1211:        else if (CurrentWeapon is SniperRifle sniperRifle)\n1213:            aimDirection = sniperRifle.AimDirection;\n1894:    #region Sniper Scope System\n1897:    /// Handles sniper scope input when the SniperRifle is equipped.\n1898:    /// RMB activates the scope for aiming beyond the viewport.\n1899:    /// Mouse wheel adjusts zoom distance while scoped.\n1900:    /// Returns true if the sniper scope consumed the RMB input.\n1902:    private bool HandleSniperScopeInput()\n1904:        // Only handle scope when a SniperRifle is the current weapon\n1905:        var sniperRifle = CurrentWeapon as SniperRifle;\n1906:        if (sniperRifle == null)\n1911:        // Handle RMB press to activate scope\n1914:            // Only activate scope if not already in a grenade action\n1917:                sniperRifle.ActivateScope();\n1922:        // Handle RMB release to deactivate scope\n1923:        if (Input.IsActionJustReleased(\"grenade_throw\") && sniperRifle.IsScopeActive)\n1925:            sniperRifle.DeactivateScope();\n1929:        // While scope is active, consume RMB input to prevent grenade handling\n1930:        if (sniperRifle.IsScopeActive)\n1939:    /// Handles mouse wheel input for scope zoom when sniper scope is active.\n1940:    /// This is called from _UnhandledInput to capture wheel events.\n1942:    public override void _UnhandledInput(InputEvent @event)\n1944:        base._UnhandledInput(@event);\n1946:        var sniperRifle = CurrentWeapon as SniperRifle;\n1947:        if (sniperRifle == null || !sniperRifle.IsScopeActive)\n1958:                    sniperRifle.AdjustScopeZoom(1.0f);\n1963:                    sniperRifle.AdjustScopeZoom(-1.0f);",
    "numLines": 32
  }
}
[2026-02-06T20:56:27.956Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01PEt3RLY1aMxZipKMzdAuFp",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01DfmmamXvcMeoW8x9rdSBv7",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1770411323361/Scripts/Characters/Player.cs",
          "offset": 1894,
          "limit": 80
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 828,
      "cache_read_input_tokens": 50347,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 828
      },
      "output_tokens": 25,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "042d2ffb-792c-40c1-a183-0278a783d0e1"
}
[2026-02-06T20:56:27.961Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01DfmmamXvcMeoW8x9rdSBv7",
        "type": "tool_result",
        "content": "  1894‚Üí    #region Sniper Scope System\n  1895‚Üí\n  1896‚Üí    /// <summary>\n  1897‚Üí    /// Handles sniper scope input when the SniperRifle is equipped.\n  1898‚Üí    /// RMB activates the scope for aiming beyond the viewport.\n  1899‚Üí    /// Mouse wheel adjusts zoom distance while scoped.\n  1900‚Üí    /// Returns true if the sniper scope consumed the RMB input.\n  1901‚Üí    /// </summary>\n  1902‚Üí    private bool HandleSniperScopeInput()\n  1903‚Üí    {\n  1904‚Üí        // Only handle scope when a SniperRifle is the current weapon\n  1905‚Üí        var sniperRifle = CurrentWeapon as SniperRifle;\n  1906‚Üí        if (sniperRifle == null)\n  1907‚Üí        {\n  1908‚Üí            return false;\n  1909‚Üí        }\n  1910‚Üí\n  1911‚Üí        // Handle RMB press to activate scope\n  1912‚Üí        if (Input.IsActionJustPressed(\"grenade_throw\"))\n  1913‚Üí        {\n  1914‚Üí            // Only activate scope if not already in a grenade action\n  1915‚Üí            if (_grenadeState == GrenadeState.Idle && !Input.IsActionPressed(\"grenade_prepare\"))\n  1916‚Üí            {\n  1917‚Üí                sniperRifle.ActivateScope();\n  1918‚Üí                return true;\n  1919‚Üí            }\n  1920‚Üí        }\n  1921‚Üí\n  1922‚Üí        // Handle RMB release to deactivate scope\n  1923‚Üí        if (Input.IsActionJustReleased(\"grenade_throw\") && sniperRifle.IsScopeActive)\n  1924‚Üí        {\n  1925‚Üí            sniperRifle.DeactivateScope();\n  1926‚Üí            return true;\n  1927‚Üí        }\n  1928‚Üí\n  1929‚Üí        // While scope is active, consume RMB input to prevent grenade handling\n  1930‚Üí        if (sniperRifle.IsScopeActive)\n  1931‚Üí        {\n  1932‚Üí            return true;\n  1933‚Üí        }\n  1934‚Üí\n  1935‚Üí        return false;\n  1936‚Üí    }\n  1937‚Üí\n  1938‚Üí    /// <summary>\n  1939‚Üí    /// Handles mouse wheel input for scope zoom when sniper scope is active.\n  1940‚Üí    /// This is called from _UnhandledInput to capture wheel events.\n  1941‚Üí    /// </summary>\n  1942‚Üí    public override void _UnhandledInput(InputEvent @event)\n  1943‚Üí    {\n  1944‚Üí        base._UnhandledInput(@event);\n  1945‚Üí\n  1946‚Üí        var sniperRifle = CurrentWeapon as SniperRifle;\n  1947‚Üí        if (sniperRifle == null || !sniperRifle.IsScopeActive)\n  1948‚Üí        {\n  1949‚Üí            return;\n  1950‚Üí        }\n  1951‚Üí\n  1952‚Üí        if (@event is InputEventMouseButton mouseButton)\n  1953‚Üí        {\n  1954‚Üí            if (mouseButton.Pressed)\n  1955‚Üí            {\n  1956‚Üí                if (mouseButton.ButtonIndex == MouseButton.WheelUp)\n  1957‚Üí                {\n  1958‚Üí                    sniperRifle.AdjustScopeZoom(1.0f);\n  1959‚Üí                    GetViewport().SetInputAsHandled();\n  1960‚Üí                }\n  1961‚Üí                else if (mouseButton.ButtonIndex == MouseButton.WheelDown)\n  1962‚Üí                {\n  1963‚Üí                    sniperRifle.AdjustScopeZoom(-1.0f);\n  1964‚Üí                    GetViewport().SetInputAsHandled();\n  1965‚Üí                }\n  1966‚Üí            }\n  1967‚Üí        }\n  1968‚Üí    }\n  1969‚Üí\n  1970‚Üí    #endregion\n  1971‚Üí\n  1972‚Üí    #region Grenade System\n  1973‚Üí\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "2438319d-17ea-4074-9396-382d8512381e",
  "tool_use_result": {
    "type": "text",
    "file": {
      "filePath": "/tmp/gh-issue-solver-1770411323361/Scripts/Characters/Player.cs",
      "content": "    #region Sniper Scope System\n\n    /// <summary>\n    /// Handles sniper scope input when the SniperRifle is equipped.\n    /// RMB activates the scope for aiming beyond the viewport.\n    /// Mouse wheel adjusts zoom distance while scoped.\n    /// Returns true if the sniper scope consumed the RMB input.\n    /// </summary>\n    private bool HandleSniperScopeInput()\n    {\n        // Only handle scope when a SniperRifle is the current weapon\n        var sniperRifle = CurrentWeapon as SniperRifle;\n        if (sniperRifle == null)\n        {\n            return false;\n        }\n\n        // Handle RMB press to activate scope\n        if (Input.IsActionJustPressed(\"grenade_throw\"))\n        {\n            // Only activate scope if not already in a grenade action\n            if (_grenadeState == GrenadeState.Idle && !Input.IsActionPressed(\"grenade_prepare\"))\n            {\n                sniperRifle.ActivateScope();\n                return true;\n            }\n        }\n\n        // Handle RMB release to deactivate scope\n        if (Input.IsActionJustReleased(\"grenade_throw\") && sniperRifle.IsScopeActive)\n        {\n            sniperRifle.DeactivateScope();\n            return true;\n        }\n\n        // While scope is active, consume RMB input to prevent grenade handling\n        if (sniperRifle.IsScopeActive)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    /// <summary>\n    /// Handles mouse wheel input for scope zoom when sniper scope is active.\n    /// This is called from _UnhandledInput to capture wheel events.\n    /// </summary>\n    public override void _UnhandledInput(InputEvent @event)\n    {\n        base._UnhandledInput(@event);\n\n        var sniperRifle = CurrentWeapon as SniperRifle;\n        if (sniperRifle == null || !sniperRifle.IsScopeActive)\n        {\n            return;\n        }\n\n        if (@event is InputEventMouseButton mouseButton)\n        {\n            if (mouseButton.Pressed)\n            {\n                if (mouseButton.ButtonIndex == MouseButton.WheelUp)\n                {\n                    sniperRifle.AdjustScopeZoom(1.0f);\n                    GetViewport().SetInputAsHandled();\n                }\n                else if (mouseButton.ButtonIndex == MouseButton.WheelDown)\n                {\n                    sniperRifle.AdjustScopeZoom(-1.0f);\n                    GetViewport().SetInputAsHandled();\n                }\n            }\n        }\n    }\n\n    #endregion\n\n    #region Grenade System\n",
      "numLines": 80,
      "startLine": 1894,
      "totalLines": 3761
    }
  }
}
[2026-02-06T20:56:28.676Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01PEt3RLY1aMxZipKMzdAuFp",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_018B3FbmHofMvux5Rqnc6TSB",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1770411323361/Scripts/Characters/Player.cs",
          "offset": 1020,
          "limit": 50
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 828,
      "cache_read_input_tokens": 50347,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 828
      },
      "output_tokens": 25,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "ba299641-e4a5-463b-b2bc-d5334cb3c971"
}
[2026-02-06T20:56:28.680Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_018B3FbmHofMvux5Rqnc6TSB",
        "type": "tool_result",
        "content": "  1020‚Üí        // Update reload animation\n  1021‚Üí        UpdateReloadAnimation((float)delta);\n  1022‚Üí\n  1023‚Üí        // Handle throw rotation animation (restore player rotation after throw)\n  1024‚Üí        HandleThrowRotationAnimation((float)delta);\n  1025‚Üí\n  1026‚Üí        // Handle sniper scope input (RMB) when SniperRifle is equipped\n  1027‚Üí        // This takes priority over grenade input since the sniper uses RMB for scoping\n  1028‚Üí        bool sniperScopeConsumedInput = HandleSniperScopeInput();\n  1029‚Üí\n  1030‚Üí        // Handle grenade input first (so it can consume shoot input)\n  1031‚Üí        // Skip if sniper scope already consumed the RMB input\n  1032‚Üí        if (!sniperScopeConsumedInput)\n  1033‚Üí        {\n  1034‚Üí            HandleGrenadeInput();\n  1035‚Üí        }\n  1036‚Üí\n  1037‚Üí        // Make active grenade follow player if held\n  1038‚Üí        if (_activeGrenade != null && IsInstanceValid(_activeGrenade))\n  1039‚Üí        {\n  1040‚Üí            _activeGrenade.GlobalPosition = GlobalPosition;\n  1041‚Üí        }\n  1042‚Üí\n  1043‚Üí        // Handle shooting input - support both automatic and semi-automatic weapons\n  1044‚Üí        // Allow shooting when not in grenade preparation\n  1045‚Üí        // In simple mode, RMB is for grenades so only LMB (shoot) should work\n  1046‚Üí        bool canShoot = _grenadeState == GrenadeState.Idle || _grenadeState == GrenadeState.TimerStarted || _grenadeState == GrenadeState.SimpleAiming;\n  1047‚Üí        if (canShoot)\n  1048‚Üí        {\n  1049‚Üí            HandleShootingInput();\n  1050‚Üí        }\n  1051‚Üí\n  1052‚Üí        // Handle reload sequence input (R-F-R)\n  1053‚Üí        HandleReloadSequenceInput();\n  1054‚Üí\n  1055‚Üí        // Handle fire mode toggle (B key for burst/auto toggle)\n  1056‚Üí        if (Input.IsActionJustPressed(\"toggle_fire_mode\"))\n  1057‚Üí        {\n  1058‚Üí            ToggleFireMode();\n  1059‚Üí        }\n  1060‚Üí    }\n  1061‚Üí\n  1062‚Üí    /// <summary>\n  1063‚Üí    /// Handles shooting input based on weapon type.\n  1064‚Üí    /// For automatic weapons: fires while held.\n  1065‚Üí    /// For semi-automatic/burst: fires on press.\n  1066‚Üí    /// Also handles bullet in chamber mechanics during reload sequence.\n  1067‚Üí    /// </summary>\n  1068‚Üí    private void HandleShootingInput()\n  1069‚Üí    {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "711609e2-6ffe-4609-8553-1409a8f4a467",
  "tool_use_result": {
    "type": "text",
    "file": {
      "filePath": "/tmp/gh-issue-solver-1770411323361/Scripts/Characters/Player.cs",
      "content": "        // Update reload animation\n        UpdateReloadAnimation((float)delta);\n\n        // Handle throw rotation animation (restore player rotation after throw)\n        HandleThrowRotationAnimation((float)delta);\n\n        // Handle sniper scope input (RMB) when SniperRifle is equipped\n        // This takes priority over grenade input since the sniper uses RMB for scoping\n        bool sniperScopeConsumedInput = HandleSniperScopeInput();\n\n        // Handle grenade input first (so it can consume shoot input)\n        // Skip if sniper scope already consumed the RMB input\n        if (!sniperScopeConsumedInput)\n        {\n            HandleGrenadeInput();\n        }\n\n        // Make active grenade follow player if held\n        if (_activeGrenade != null && IsInstanceValid(_activeGrenade))\n        {\n            _activeGrenade.GlobalPosition = GlobalPosition;\n        }\n\n        // Handle shooting input - support both automatic and semi-automatic weapons\n        // Allow shooting when not in grenade preparation\n        // In simple mode, RMB is for grenades so only LMB (shoot) should work\n        bool canShoot = _grenadeState == GrenadeState.Idle || _grenadeState == GrenadeState.TimerStarted || _grenadeState == GrenadeState.SimpleAiming;\n        if (canShoot)\n        {\n            HandleShootingInput();\n        }\n\n        // Handle reload sequence input (R-F-R)\n        HandleReloadSequenceInput();\n\n        // Handle fire mode toggle (B key for burst/auto toggle)\n        if (Input.IsActionJustPressed(\"toggle_fire_mode\"))\n        {\n            ToggleFireMode();\n        }\n    }\n\n    /// <summary>\n    /// Handles shooting input based on weapon type.\n    /// For automatic weapons: fires while held.\n    /// For semi-automatic/burst: fires on press.\n    /// Also handles bullet in chamber mechanics during reload sequence.\n    /// </summary>\n    private void HandleShootingInput()\n    {",
      "numLines": 50,
      "startLine": 1020,
      "totalLines": 3761
    }
  }
}
[2026-02-06T20:56:29.349Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01PEt3RLY1aMxZipKMzdAuFp",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_015x3m6xMLKWpw9Ydk2y68DY",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1770411323361/Scripts/Characters/Player.cs",
          "offset": 1200,
          "limit": 50
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 828,
      "cache_read_input_tokens": 50347,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 828
      },
      "output_tokens": 25,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "d20c094e-8690-4e5a-bb0d-15e8035831be"
}
[2026-02-06T20:56:29.371Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_015x3m6xMLKWpw9Ydk2y68DY",
        "type": "tool_result",
        "content": "  1200‚Üí        {\n  1201‚Üí            // Keep current rotation locked - don't follow mouse\n  1202‚Üí            return;\n  1203‚Üí        }\n  1204‚Üí\n  1205‚Üí        // Get the aim direction from the weapon if available\n  1206‚Üí        Vector2 aimDirection;\n  1207‚Üí        if (CurrentWeapon is AssaultRifle assaultRifle)\n  1208‚Üí        {\n  1209‚Üí            aimDirection = assaultRifle.AimDirection;\n  1210‚Üí        }\n  1211‚Üí        else if (CurrentWeapon is SniperRifle sniperRifle)\n  1212‚Üí        {\n  1213‚Üí            aimDirection = sniperRifle.AimDirection;\n  1214‚Üí        }\n  1215‚Üí        else\n  1216‚Üí        {\n  1217‚Üí            // Fallback: calculate direction to mouse cursor\n  1218‚Üí            Vector2 mousePos = GetGlobalMousePosition();\n  1219‚Üí            Vector2 toMouse = mousePos - GlobalPosition;\n  1220‚Üí            if (toMouse.LengthSquared() > 0.001f)\n  1221‚Üí            {\n  1222‚Üí                aimDirection = toMouse.Normalized();\n  1223‚Üí            }\n  1224‚Üí            else\n  1225‚Üí            {\n  1226‚Üí                return; // No valid direction\n  1227‚Üí            }\n  1228‚Üí        }\n  1229‚Üí\n  1230‚Üí        // Calculate target rotation angle\n  1231‚Üí        float targetAngle = aimDirection.Angle();\n  1232‚Üí\n  1233‚Üí        // Apply rotation to the player model\n  1234‚Üí        _playerModel.Rotation = targetAngle;\n  1235‚Üí\n  1236‚Üí        // Handle sprite flipping for left/right aim\n  1237‚Üí        // When aiming left (angle > 90¬∞ or < -90¬∞), flip vertically to avoid upside-down appearance\n  1238‚Üí        bool aimingLeft = Mathf.Abs(targetAngle) > Mathf.Pi / 2;\n  1239‚Üí\n  1240‚Üí        // Flip the player model vertically when aiming left\n  1241‚Üí        if (aimingLeft)\n  1242‚Üí        {\n  1243‚Üí            _playerModel.Scale = new Vector2(PlayerModelScale, -PlayerModelScale);\n  1244‚Üí        }\n  1245‚Üí        else\n  1246‚Üí        {\n  1247‚Üí            _playerModel.Scale = new Vector2(PlayerModelScale, PlayerModelScale);\n  1248‚Üí        }\n  1249‚Üí    }\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "86bf79e9-fe00-4f86-b5bd-69e1eebb5a37",
  "tool_use_result": {
    "type": "text",
    "file": {
      "filePath": "/tmp/gh-issue-solver-1770411323361/Scripts/Characters/Player.cs",
      "content": "        {\n            // Keep current rotation locked - don't follow mouse\n            return;\n        }\n\n        // Get the aim direction from the weapon if available\n        Vector2 aimDirection;\n        if (CurrentWeapon is AssaultRifle assaultRifle)\n        {\n            aimDirection = assaultRifle.AimDirection;\n        }\n        else if (CurrentWeapon is SniperRifle sniperRifle)\n        {\n            aimDirection = sniperRifle.AimDirection;\n        }\n        else\n        {\n            // Fallback: calculate direction to mouse cursor\n            Vector2 mousePos = GetGlobalMousePosition();\n            Vector2 toMouse = mousePos - GlobalPosition;\n            if (toMouse.LengthSquared() > 0.001f)\n            {\n                aimDirection = toMouse.Normalized();\n            }\n            else\n            {\n                return; // No valid direction\n            }\n        }\n\n        // Calculate target rotation angle\n        float targetAngle = aimDirection.Angle();\n\n        // Apply rotation to the player model\n        _playerModel.Rotation = targetAngle;\n\n        // Handle sprite flipping for left/right aim\n        // When aiming left (angle > 90¬∞ or < -90¬∞), flip vertically to avoid upside-down appearance\n        bool aimingLeft = Mathf.Abs(targetAngle) > Mathf.Pi / 2;\n\n        // Flip the player model vertically when aiming left\n        if (aimingLeft)\n        {\n            _playerModel.Scale = new Vector2(PlayerModelScale, -PlayerModelScale);\n        }\n        else\n        {\n            _playerModel.Scale = new Vector2(PlayerModelScale, PlayerModelScale);\n        }\n    }",
      "numLines": 50,
      "startLine": 1200,
      "totalLines": 3761
    }
  }
}
[2026-02-06T20:56:32.487Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_014ZrSGpJfyj7noxDWB5DrYM",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now let me also check how the shooting direction is determined for the SniperRifle ‚Äî specifically the `HandleShootingInput` and `Fire` call."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 2983,
      "cache_read_input_tokens": 51175,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 2983
      },
      "output_tokens": 1,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "ce66cb14-ab49-46e5-bfef-1a0ed86ca36c"
}
[2026-02-06T20:56:33.153Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_014ZrSGpJfyj7noxDWB5DrYM",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_013tNTgXSbiEReH2G4bhCpEJ",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1770411323361/Scripts/Characters/Player.cs",
          "offset": 1068,
          "limit": 80
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 2983,
      "cache_read_input_tokens": 51175,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 2983
      },
      "output_tokens": 1,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "74881cec-ef05-4589-b9bd-efbd92cbf321"
}
[2026-02-06T20:56:33.177Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_013tNTgXSbiEReH2G4bhCpEJ",
        "type": "tool_result",
        "content": "  1068‚Üí    private void HandleShootingInput()\n  1069‚Üí    {\n  1070‚Üí        if (CurrentWeapon == null)\n  1071‚Üí        {\n  1072‚Üí            // Fallback to original click-to-shoot behavior\n  1073‚Üí            if (Input.IsActionJustPressed(\"shoot\"))\n  1074‚Üí            {\n  1075‚Üí                Shoot();\n  1076‚Üí            }\n  1077‚Üí            return;\n  1078‚Üí        }\n  1079‚Üí\n  1080‚Üí        // Check if weapon is automatic (based on WeaponData)\n  1081‚Üí        bool isAutomatic = CurrentWeapon.WeaponData?.IsAutomatic ?? false;\n  1082‚Üí\n  1083‚Üí        // For AssaultRifle, also check if it's in automatic fire mode\n  1084‚Üí        if (CurrentWeapon is AssaultRifle assaultRifle)\n  1085‚Üí        {\n  1086‚Üí            isAutomatic = assaultRifle.CurrentFireMode == FireMode.Automatic;\n  1087‚Üí        }\n  1088‚Üí\n  1089‚Üí        // Determine if shooting input is active\n  1090‚Üí        bool shootInputActive = isAutomatic ? Input.IsActionPressed(\"shoot\") : Input.IsActionJustPressed(\"shoot\");\n  1091‚Üí\n  1092‚Üí        if (!shootInputActive)\n  1093‚Üí        {\n  1094‚Üí            return;\n  1095‚Üí        }\n  1096‚Üí\n  1097‚Üí        // Check if weapon is empty before trying to shoot (not in reload sequence)\n  1098‚Üí        // This notifies enemies that the player tried to shoot with no ammo\n  1099‚Üí        if (!_isReloadingSequence && CurrentWeapon.CurrentAmmo <= 0)\n  1100‚Üí        {\n  1101‚Üí            // Emit signal to notify enemies that player is vulnerable (out of ammo)\n  1102‚Üí            EmitSignal(SignalName.AmmoDepleted);\n  1103‚Üí            // The weapon will play the empty click sound\n  1104‚Üí        }\n  1105‚Üí\n  1106‚Üí        // Handle shooting based on reload sequence state\n  1107‚Üí        if (_isReloadingSequence)\n  1108‚Üí        {\n  1109‚Üí            // In reload sequence\n  1110‚Üí            if (_reloadSequenceStep == 1)\n  1111‚Üí            {\n  1112‚Üí                // Step 1 (only R pressed, waiting for F): shooting resets the combo\n  1113‚Üí                GD.Print(\"[Player] Shooting during reload step 1 - resetting reload sequence\");\n  1114‚Üí                ResetReloadSequence();\n  1115‚Üí                Shoot();\n  1116‚Üí            }\n  1117‚Üí            else if (_reloadSequenceStep == 2)\n  1118‚Üí            {\n  1119‚Üí                // Step 2 (R->F pressed, waiting for final R): try to fire chamber bullet\n  1120‚Üí                if (CurrentWeapon.CanFireChamberBullet)\n  1121‚Üí                {\n  1122‚Üí                    // Fire the chamber bullet\n  1123‚Üí                    Vector2 mousePos = GetGlobalMousePosition();\n  1124‚Üí                    Vector2 shootDirection = (mousePos - GlobalPosition).Normalized();\n  1125‚Üí\n  1126‚Üí                    if (CurrentWeapon.FireChamberBullet(shootDirection))\n  1127‚Üí                    {\n  1128‚Üí                        GD.Print(\"[Player] Fired bullet in chamber during reload\");\n  1129‚Üí                        // Note: Sound is handled by the weapon's FireChamberBullet implementation\n  1130‚Üí                    }\n  1131‚Üí                }\n  1132‚Üí                else if (CurrentWeapon.ChamberBulletFired)\n  1133‚Üí                {\n  1134‚Üí                    // Chamber bullet already fired, can't shoot until reload completes\n  1135‚Üí                    GD.Print(\"[Player] Cannot shoot - chamber bullet already fired, wait for reload to complete\");\n  1136‚Üí                    PlayEmptyClickSound();\n  1137‚Üí                }\n  1138‚Üí                else\n  1139‚Üí                {\n  1140‚Üí                    // No bullet in chamber (magazine was empty when reload started)\n  1141‚Üí                    GD.Print(\"[Player] Cannot shoot - no bullet in chamber, wait for reload to complete\");\n  1142‚Üí                    PlayEmptyClickSound();\n  1143‚Üí                }\n  1144‚Üí            }\n  1145‚Üí        }\n  1146‚Üí        else\n  1147‚Üí        {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "817fb15a-d6c1-4449-ba2e-346769a2645e",
  "tool_use_result": {
    "type": "text",
    "file": {
      "filePath": "/tmp/gh-issue-solver-1770411323361/Scripts/Characters/Player.cs",
      "content": "    private void HandleShootingInput()\n    {\n        if (CurrentWeapon == null)\n        {\n            // Fallback to original click-to-shoot behavior\n            if (Input.IsActionJustPressed(\"shoot\"))\n            {\n                Shoot();\n            }\n            return;\n        }\n\n        // Check if weapon is automatic (based on WeaponData)\n        bool isAutomatic = CurrentWeapon.WeaponData?.IsAutomatic ?? false;\n\n        // For AssaultRifle, also check if it's in automatic fire mode\n        if (CurrentWeapon is AssaultRifle assaultRifle)\n        {\n            isAutomatic = assaultRifle.CurrentFireMode == FireMode.Automatic;\n        }\n\n        // Determine if shooting input is active\n        bool shootInputActive = isAutomatic ? Input.IsActionPressed(\"shoot\") : Input.IsActionJustPressed(\"shoot\");\n\n        if (!shootInputActive)\n        {\n            return;\n        }\n\n        // Check if weapon is empty before trying to shoot (not in reload sequence)\n        // This notifies enemies that the player tried to shoot with no ammo\n        if (!_isReloadingSequence && CurrentWeapon.CurrentAmmo <= 0)\n        {\n            // Emit signal to notify enemies that player is vulnerable (out of ammo)\n            EmitSignal(SignalName.AmmoDepleted);\n            // The weapon will play the empty click sound\n        }\n\n        // Handle shooting based on reload sequence state\n        if (_isReloadingSequence)\n        {\n            // In reload sequence\n            if (_reloadSequenceStep == 1)\n            {\n                // Step 1 (only R pressed, waiting for F): shooting resets the combo\n                GD.Print(\"[Player] Shooting during reload step 1 - resetting reload sequence\");\n                ResetReloadSequence();\n                Shoot();\n            }\n            else if (_reloadSequenceStep == 2)\n            {\n                // Step 2 (R->F pressed, waiting for final R): try to fire chamber bullet\n                if (CurrentWeapon.CanFireChamberBullet)\n                {\n                    // Fire the chamber bullet\n                    Vector2 mousePos = GetGlobalMousePosition();\n                    Vector2 shootDirection = (mousePos - GlobalPosition).Normalized();\n\n                    if (CurrentWeapon.FireChamberBullet(shootDirection))\n                    {\n                        GD.Print(\"[Player] Fired bullet in chamber during reload\");\n                        // Note: Sound is handled by the weapon's FireChamberBullet implementation\n                    }\n                }\n                else if (CurrentWeapon.ChamberBulletFired)\n                {\n                    // Chamber bullet already fired, can't shoot until reload completes\n                    GD.Print(\"[Player] Cannot shoot - chamber bullet already fired, wait for reload to complete\");\n                    PlayEmptyClickSound();\n                }\n                else\n                {\n                    // No bullet in chamber (magazine was empty when reload started)\n                    GD.Print(\"[Player] Cannot shoot - no bullet in chamber, wait for reload to complete\");\n                    PlayEmptyClickSound();\n                }\n            }\n        }\n        else\n        {",
      "numLines": 80,
      "startLine": 1068,
      "totalLines": 3761
    }
  }
}
[2026-02-06T20:56:36.175Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01KWXz7KRzE7wGcvEscHZhEt",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01KRbsR9bQYMzfFBGPNMbE6f",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1770411323361/Scripts/Characters/Player.cs",
          "offset": 1146,
          "limit": 60
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 1338,
      "cache_read_input_tokens": 54158,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 1338
      },
      "output_tokens": 25,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "bfc06001-7b5c-49cf-b893-53ea1f8574c3"
}
[2026-02-06T20:56:36.240Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01KRbsR9bQYMzfFBGPNMbE6f",
        "type": "tool_result",
        "content": "  1146‚Üí        else\n  1147‚Üí        {\n  1148‚Üí            // Not in reload sequence - normal shooting\n  1149‚Üí            Shoot();\n  1150‚Üí        }\n  1151‚Üí    }\n  1152‚Üí\n  1153‚Üí    /// <summary>\n  1154‚Üí    /// Plays the empty click sound when trying to shoot without ammo.\n  1155‚Üí    /// </summary>\n  1156‚Üí    private void PlayEmptyClickSound()\n  1157‚Üí    {\n  1158‚Üí        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n  1159‚Üí        if (audioManager != null && audioManager.HasMethod(\"play_empty_click\"))\n  1160‚Üí        {\n  1161‚Üí            audioManager.Call(\"play_empty_click\", GlobalPosition);\n  1162‚Üí        }\n  1163‚Üí    }\n  1164‚Üí\n  1165‚Üí    /// <summary>\n  1166‚Üí    /// Toggles fire mode on the current weapon (if supported).\n  1167‚Üí    /// </summary>\n  1168‚Üí    private void ToggleFireMode()\n  1169‚Üí    {\n  1170‚Üí        if (CurrentWeapon is AssaultRifle assaultRifle)\n  1171‚Üí        {\n  1172‚Üí            assaultRifle.ToggleFireMode();\n  1173‚Üí        }\n  1174‚Üí    }\n  1175‚Üí\n  1176‚Üí    /// <summary>\n  1177‚Üí    /// Updates the player model rotation to face the aim direction.\n  1178‚Üí    /// The player model (body, head, arms) rotates to follow the rifle's aim direction.\n  1179‚Üí    /// This creates the appearance of the player rotating their whole body toward the target.\n  1180‚Üí    /// TACTICAL RELOAD (Issue #437): During shotgun reload OR when RMB is held (dragging),\n  1181‚Üí    /// player model rotation is locked to allow the player to keep aiming at a specific\n  1182‚Üí    /// spot while performing reload gestures.\n  1183‚Üí    ///\n  1184‚Üí    /// FIX (Issue #437 feedback): Lock rotation as soon as RMB is pressed, not just when\n  1185‚Üí    /// reload state changes. This prevents barrel/player shift during quick one-motion\n  1186‚Üí    /// reload gestures (drag up then down without releasing RMB).\n  1187‚Üí    /// </summary>\n  1188‚Üí    private void UpdatePlayerModelRotation()\n  1189‚Üí    {\n  1190‚Üí        if (_playerModel == null)\n  1191‚Üí        {\n  1192‚Üí            return;\n  1193‚Üí        }\n  1194‚Üí\n  1195‚Üí        // TACTICAL RELOAD (Issue #437): Don't rotate player model during shotgun reload\n  1196‚Üí        // OR when dragging (RMB is held). This ensures the player freezes immediately\n  1197‚Üí        // when RMB is pressed, before any state change occurs.\n  1198‚Üí        var shotgun = GetNodeOrNull<Shotgun>(\"Shotgun\");\n  1199‚Üí        if (shotgun != null && (shotgun.ReloadState != ShotgunReloadState.NotReloading || shotgun.IsDragging))\n  1200‚Üí        {\n  1201‚Üí            // Keep current rotation locked - don't follow mouse\n  1202‚Üí            return;\n  1203‚Üí        }\n  1204‚Üí\n  1205‚Üí        // Get the aim direction from the weapon if available\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "9482d448-4697-476c-a3a4-9dd752a97f63",
  "tool_use_result": {
    "type": "text",
    "file": {
      "filePath": "/tmp/gh-issue-solver-1770411323361/Scripts/Characters/Player.cs",
      "content": "        else\n        {\n            // Not in reload sequence - normal shooting\n            Shoot();\n        }\n    }\n\n    /// <summary>\n    /// Plays the empty click sound when trying to shoot without ammo.\n    /// </summary>\n    private void PlayEmptyClickSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_empty_click\"))\n        {\n            audioManager.Call(\"play_empty_click\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Toggles fire mode on the current weapon (if supported).\n    /// </summary>\n    private void ToggleFireMode()\n    {\n        if (CurrentWeapon is AssaultRifle assaultRifle)\n        {\n            assaultRifle.ToggleFireMode();\n        }\n    }\n\n    /// <summary>\n    /// Updates the player model rotation to face the aim direction.\n    /// The player model (body, head, arms) rotates to follow the rifle's aim direction.\n    /// This creates the appearance of the player rotating their whole body toward the target.\n    /// TACTICAL RELOAD (Issue #437): During shotgun reload OR when RMB is held (dragging),\n    /// player model rotation is locked to allow the player to keep aiming at a specific\n    /// spot while performing reload gestures.\n    ///\n    /// FIX (Issue #437 feedback): Lock rotation as soon as RMB is pressed, not just when\n    /// reload state changes. This prevents barrel/player shift during quick one-motion\n    /// reload gestures (drag up then down without releasing RMB).\n    /// </summary>\n    private void UpdatePlayerModelRotation()\n    {\n        if (_playerModel == null)\n        {\n            return;\n        }\n\n        // TACTICAL RELOAD (Issue #437): Don't rotate player model during shotgun reload\n        // OR when dragging (RMB is held). This ensures the player freezes immediately\n        // when RMB is pressed, before any state change occurs.\n        var shotgun = GetNodeOrNull<Shotgun>(\"Shotgun\");\n        if (shotgun != null && (shotgun.ReloadState != ShotgunReloadState.NotReloading || shotgun.IsDragging))\n        {\n            // Keep current rotation locked - don't follow mouse\n            return;\n        }\n\n        // Get the aim direction from the weapon if available",
      "numLines": 60,
      "startLine": 1146,
      "totalLines": 3761
    }
  }
}
[2026-02-06T20:56:38.846Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_016wfopj4H75Gz6R4NdXPEKF",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now let me find the `Shoot()` method to see how the direction is determined for firing."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 1029,
      "cache_read_input_tokens": 55496,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 1029
      },
      "output_tokens": 1,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "fee9e599-f572-44f2-8a83-82a7447b0a40"
}
[2026-02-06T20:56:40.339Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_016wfopj4H75Gz6R4NdXPEKF",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01Xxows4xEGiFnyhJvUtC63p",
        "name": "Grep",
        "input": {
          "pattern": "private.*void Shoot\\(\\)|protected.*void Shoot\\(\\)|public.*void Shoot\\(\\)",
          "path": "/tmp/gh-issue-solver-1770411323361/Scripts/Characters/Player.cs",
          "output_mode": "content",
          "-n": true
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 1029,
      "cache_read_input_tokens": 55496,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 1029
      },
      "output_tokens": 1,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "31984297-78e0-4d11-870b-cccb92c1bbea"
}
[2026-02-06T20:56:40.361Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01Xxows4xEGiFnyhJvUtC63p",
        "type": "tool_result",
        "content": "1655:    private void Shoot()"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "bf9b9e7a-af71-45fc-8484-8a96d537ca41",
  "tool_use_result": {
    "mode": "content",
    "numFiles": 0,
    "filenames": [],
    "content": "1655:    private void Shoot()",
    "numLines": 1
  }
}
[2026-02-06T20:56:42.991Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01QHJDEsyejtAgqQySu3PWrh",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01FKfQbABLZ7HtFke11hVnZo",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1770411323361/Scripts/Characters/Player.cs",
          "offset": 1655,
          "limit": 60
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 192,
      "cache_read_input_tokens": 56525,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 192
      },
      "output_tokens": 24,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "623f9612-d9cc-430a-984b-82d2e49f14af"
}
[2026-02-06T20:56:43.043Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01FKfQbABLZ7HtFke11hVnZo",
        "type": "tool_result",
        "content": "  1655‚Üí    private void Shoot()\n  1656‚Üí    {\n  1657‚Üí        // Calculate direction towards mouse cursor\n  1658‚Üí        Vector2 mousePos = GetGlobalMousePosition();\n  1659‚Üí        Vector2 shootDirection = (mousePos - GlobalPosition).Normalized();\n  1660‚Üí\n  1661‚Üí        // If we have a weapon equipped, use it\n  1662‚Üí        if (CurrentWeapon != null)\n  1663‚Üí        {\n  1664‚Üí            CurrentWeapon.Fire(shootDirection);\n  1665‚Üí            return;\n  1666‚Üí        }\n  1667‚Üí\n  1668‚Üí        // Otherwise use direct bullet spawning (original behavior)\n  1669‚Üí        SpawnBullet(shootDirection);\n  1670‚Üí    }\n  1671‚Üí\n  1672‚Üí    /// <summary>\n  1673‚Üí    /// Spawns a bullet directly without using the weapon system.\n  1674‚Üí    /// Preserves the original template behavior.\n  1675‚Üí    /// </summary>\n  1676‚Üí    /// <param name=\"direction\">Direction for the bullet to travel.</param>\n  1677‚Üí    private void SpawnBullet(Vector2 direction)\n  1678‚Üí    {\n  1679‚Üí        if (BulletScene == null)\n  1680‚Üí        {\n  1681‚Üí            return;\n  1682‚Üí        }\n  1683‚Üí\n  1684‚Üí        // Create bullet instance\n  1685‚Üí        var bullet = BulletScene.Instantiate<Node2D>();\n  1686‚Üí\n  1687‚Üí        // Set bullet position with offset in shoot direction\n  1688‚Üí        bullet.GlobalPosition = GlobalPosition + direction * BulletSpawnOffset;\n  1689‚Üí\n  1690‚Üí        // Set bullet direction\n  1691‚Üí        if (bullet.HasMethod(\"SetDirection\"))\n  1692‚Üí        {\n  1693‚Üí            bullet.Call(\"SetDirection\", direction);\n  1694‚Üí        }\n  1695‚Üí        else\n  1696‚Üí        {\n  1697‚Üí            bullet.Set(\"direction\", direction);\n  1698‚Üí        }\n  1699‚Üí\n  1700‚Üí        // Set shooter ID to prevent self-damage\n  1701‚Üí        if (bullet.HasMethod(\"SetShooterId\"))\n  1702‚Üí        {\n  1703‚Üí            bullet.Call(\"SetShooterId\", GetInstanceId());\n  1704‚Üí        }\n  1705‚Üí        else\n  1706‚Üí        {\n  1707‚Üí            bullet.Set(\"shooter_id\", GetInstanceId());\n  1708‚Üí        }\n  1709‚Üí\n  1710‚Üí        // Add bullet to the scene tree\n  1711‚Üí        GetTree().CurrentScene.AddChild(bullet);\n  1712‚Üí    }\n  1713‚Üí\n  1714‚Üí    /// <summary>\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "dc94cad0-3231-4e77-b852-97974736b3a3",
  "tool_use_result": {
    "type": "text",
    "file": {
      "filePath": "/tmp/gh-issue-solver-1770411323361/Scripts/Characters/Player.cs",
      "content": "    private void Shoot()\n    {\n        // Calculate direction towards mouse cursor\n        Vector2 mousePos = GetGlobalMousePosition();\n        Vector2 shootDirection = (mousePos - GlobalPosition).Normalized();\n\n        // If we have a weapon equipped, use it\n        if (CurrentWeapon != null)\n        {\n            CurrentWeapon.Fire(shootDirection);\n            return;\n        }\n\n        // Otherwise use direct bullet spawning (original behavior)\n        SpawnBullet(shootDirection);\n    }\n\n    /// <summary>\n    /// Spawns a bullet directly without using the weapon system.\n    /// Preserves the original template behavior.\n    /// </summary>\n    /// <param name=\"direction\">Direction for the bullet to travel.</param>\n    private void SpawnBullet(Vector2 direction)\n    {\n        if (BulletScene == null)\n        {\n            return;\n        }\n\n        // Create bullet instance\n        var bullet = BulletScene.Instantiate<Node2D>();\n\n        // Set bullet position with offset in shoot direction\n        bullet.GlobalPosition = GlobalPosition + direction * BulletSpawnOffset;\n\n        // Set bullet direction\n        if (bullet.HasMethod(\"SetDirection\"))\n        {\n            bullet.Call(\"SetDirection\", direction);\n        }\n        else\n        {\n            bullet.Set(\"direction\", direction);\n        }\n\n        // Set shooter ID to prevent self-damage\n        if (bullet.HasMethod(\"SetShooterId\"))\n        {\n            bullet.Call(\"SetShooterId\", GetInstanceId());\n        }\n        else\n        {\n            bullet.Set(\"shooter_id\", GetInstanceId());\n        }\n\n        // Add bullet to the scene tree\n        GetTree().CurrentScene.AddChild(bullet);\n    }\n\n    /// <summary>",
      "numLines": 60,
      "startLine": 1655,
      "totalLines": 3761
    }
  }
}
[2026-02-06T20:56:51.320Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01LTJUhEqixA45HYRC1aXLSm",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now I have a clear picture of the issues. Let me analyze:\n\n**Issue #2 (bullets not going to crosshair center)**: In `Shoot()` at line 1658-1659, the shoot direction is calculated as `(mousePos - GlobalPosition).Normalized()`. But when scoped, the camera is offset and the crosshair center represents a different world position. The bullets should fire toward the scope's aim point (which is `GlobalPosition + _aimDirection * baseDistance * _scopeZoomDistance`), not toward the mouse cursor on screen.\n\n**Issue #1 (movement within scope)**: Currently mouse movement while scoped doesn't allow the player to adjust the aim within the scope view. The scope just follows the `_aimDirection` (which is the rifle's aim). The user wants mouse movement to slightly adjust the scope position (about 1/3 viewport) within the scope view.\n\n**Issue #3 (minimum scope distance)**: Currently `MinScopeZoomDistance = 0.5f`. Need to increase it by 0.5 (half viewport), making it `1.0f`.\n\nLet me now implement these changes."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 1121,
      "cache_read_input_tokens": 56717,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 1121
      },
      "output_tokens": 5,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "695653b0-0e41-4597-a9fb-60872c3fa83c"
}
[2026-02-06T20:56:54.829Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01LTJUhEqixA45HYRC1aXLSm",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01WH5VXsCT5hXcDakPcfZfDu",
        "name": "TodoWrite",
        "input": {
          "todos": [
            {
              "content": "Read and understand current SniperRifle.cs scope implementation",
              "status": "completed",
              "activeForm": "Reading SniperRifle.cs scope implementation"
            },
            {
              "content": "Read and understand Player.cs scope input handling",
              "status": "completed",
              "activeForm": "Reading Player.cs scope input handling"
            },
            {
              "content": "Fix #1: Allow slight movement (~1/3 viewport) closer/further while scoped via mouse movement",
              "status": "in_progress",
              "activeForm": "Implementing scope movement closer/further"
            },
            {
              "content": "Fix #2: Make bullets fly to the center of the crosshair (scope aim point)",
              "status": "pending",
              "activeForm": "Fixing bullet aim direction to match crosshair center"
            },
            {
              "content": "Fix #3: Move minimum scope distance half a viewport further (0.5 -> 1.0)",
              "status": "pending",
              "activeForm": "Increasing minimum scope distance by half viewport"
            },
            {
              "content": "Test all changes locally and verify no regressions",
              "status": "pending",
              "activeForm": "Testing changes locally"
            },
            {
              "content": "Commit, push, and update PR description",
              "status": "pending",
              "activeForm": "Committing and pushing changes"
            }
          ]
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 1121,
      "cache_read_input_tokens": 56717,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 1121
      },
      "output_tokens": 5,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "8ec93923-881c-4c12-b827-4d04b33e9a70"
}
[2026-02-06T20:56:54.846Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01WH5VXsCT5hXcDakPcfZfDu",
        "type": "tool_result",
        "content": "Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "a03cf599-9c79-4396-b4c1-f12866c02762",
  "tool_use_result": {
    "oldTodos": [
      {
        "content": "Read and understand current SniperRifle.cs scope implementation",
        "status": "completed",
        "activeForm": "Reading SniperRifle.cs scope implementation"
      },
      {
        "content": "Read and understand Player.cs scope input handling",
        "status": "in_progress",
        "activeForm": "Reading Player.cs scope input handling"
      },
      {
        "content": "Fix #1: Allow slight movement (~1/3 viewport) closer/further while scoped",
        "status": "pending",
        "activeForm": "Implementing scope movement closer/further"
      },
      {
        "content": "Fix #2: Make bullets fly to the center of the crosshair",
        "status": "pending",
        "activeForm": "Fixing bullet aim direction to match crosshair center"
      },
      {
        "content": "Fix #3: Move minimum scope distance half a viewport further",
        "status": "pending",
        "activeForm": "Increasing minimum scope distance by half viewport"
      },
      {
        "content": "Test all changes locally and verify no regressions",
        "status": "pending",
        "activeForm": "Testing changes locally"
      },
      {
        "content": "Commit, push, and update PR description",
        "status": "pending",
        "activeForm": "Committing and pushing changes"
      }
    ],
    "newTodos": [
      {
        "content": "Read and understand current SniperRifle.cs scope implementation",
        "status": "completed",
        "activeForm": "Reading SniperRifle.cs scope implementation"
      },
      {
        "content": "Read and understand Player.cs scope input handling",
        "status": "completed",
        "activeForm": "Reading Player.cs scope input handling"
      },
      {
        "content": "Fix #1: Allow slight movement (~1/3 viewport) closer/further while scoped via mouse movement",
        "status": "in_progress",
        "activeForm": "Implementing scope movement closer/further"
      },
      {
        "content": "Fix #2: Make bullets fly to the center of the crosshair (scope aim point)",
        "status": "pending",
        "activeForm": "Fixing bullet aim direction to match crosshair center"
      },
      {
        "content": "Fix #3: Move minimum scope distance half a viewport further (0.5 -> 1.0)",
        "status": "pending",
        "activeForm": "Increasing minimum scope distance by half viewport"
      },
      {
        "content": "Test all changes locally and verify no regressions",
        "status": "pending",
        "activeForm": "Testing changes locally"
      },
      {
        "content": "Commit, push, and update PR description",
        "status": "pending",
        "activeForm": "Committing and pushing changes"
      }
    ]
  }
}
[2026-02-06T20:57:02.832Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01WX5YPjHsCqHG8FzBDHx266",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Let me re-read the owner's comment more carefully:\n\n> 1. –≤ —Ä–µ–∂–∏–º–µ –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –Ω–µ–º–Ω–æ–≥–æ (—Ç—Ä–µ—Ç—å –≤—å—é–ø–æ—Ä—Ç–∞ –ø—Ä–∏–º–µ—Ä–Ω–æ) –ø–µ—Ä–µ–º–µ—â–∞—Ç—å—Å—è –¥–∞–ª—å—à–µ/–±–ª–∏–∂–µ.\n\nThis says \"in scope mode, there should be an ability to move a little (about 1/3 viewport) further/closer\" ‚Äî this means they want mouse-based fine-tuning of the scope distance (not just mouse wheel). While scoped, the player should be able to move the mouse forward/backward relative to their aim direction to adjust the viewing distance by about 1/3 viewport.\n\nActually, re-reading the original issue more carefully:\n\n> –ø—Ä–∏ –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏–∏ –º–æ–∂–Ω–æ —Ü–µ–ª–∏—Ç—å—Å—è –≤ —Ä–∞–º–∫–∞—Ö –≤—å—é–ø–æ—Ä—Ç–∞\n\n\"while scoped, you can aim within the viewport\" ‚Äî meaning mouse movement within the viewport should adjust aim.\n\nSo the feedback item #1 is saying: while scoped, mouse movement should allow you to adjust the aiming point slightly closer or further (about 1/3 viewport range). This is about mouse-based fine aiming within the scope view.\n\nLet me implement all three fixes now. I'll start with the SniperRifle.cs changes."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 642,
      "cache_read_input_tokens": 57838,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 642
      },
      "output_tokens": 1,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "c49648e3-e889-4ae1-b0eb-c8e45fb3a69f"
}
[2026-02-06T20:57:05.041Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01WX5YPjHsCqHG8FzBDHx266",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01LpSet7zeetYSshM2Nk4cjK",
        "name": "Edit",
        "input": {
          "replace_all": false,
          "file_path": "/tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs",
          "old_string": "    /// <summary>\n    /// Minimum scope zoom distance (viewport multiplier).\n    /// </summary>\n    private const float MinScopeZoomDistance = 0.5f;",
          "new_string": "    /// <summary>\n    /// Minimum scope zoom distance (viewport multiplier).\n    /// Set to 1.0 so the scope always looks beyond the normal viewport.\n    /// </summary>\n    private const float MinScopeZoomDistance = 1.0f;"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 642,
      "cache_read_input_tokens": 57838,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 642
      },
      "output_tokens": 1,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "fcf87cfa-73ad-46b1-ad42-2ae85bb283f2"
}
[2026-02-06T20:57:05.053Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01LpSet7zeetYSshM2Nk4cjK",
        "type": "tool_result",
        "content": "The file /tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs has been updated successfully."
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "c1871d52-48c8-4b8c-93a3-a6803e4aa8b1",
  "tool_use_result": {
    "filePath": "/tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs",
    "oldString": "    /// <summary>\n    /// Minimum scope zoom distance (viewport multiplier).\n    /// </summary>\n    private const float MinScopeZoomDistance = 0.5f;",
    "newString": "    /// <summary>\n    /// Minimum scope zoom distance (viewport multiplier).\n    /// Set to 1.0 so the scope always looks beyond the normal viewport.\n    /// </summary>\n    private const float MinScopeZoomDistance = 1.0f;",
    "originalFile": "using Godot;\nusing GodotTopDownTemplate.AbstractClasses;\nusing GodotTopDownTemplate.Projectiles;\n\nnamespace GodotTopDownTemplate.Weapons;\n\n/// <summary>\n/// Bolt-action charging state for the ASVK sniper rifle.\n/// Before each shot, the player must complete a 4-step bolt-action sequence:\n/// Down (pull bolt back) ‚Üí Left (open bolt) ‚Üí Down (close bolt) ‚Üí Up (chamber round)\n/// </summary>\npublic enum BoltActionStep\n{\n    /// <summary>\n    /// Bolt is ready - weapon can fire. After firing, transitions to NeedsBoltCycle.\n    /// </summary>\n    Ready,\n\n    /// <summary>\n    /// Just fired - needs bolt cycling before next shot.\n    /// Waiting for Down arrow (pull bolt back).\n    /// </summary>\n    NeedsBoltCycle,\n\n    /// <summary>\n    /// Step 1 complete (bolt pulled back). Waiting for Left arrow (open bolt).\n    /// </summary>\n    WaitOpenBolt,\n\n    /// <summary>\n    /// Step 2 complete (bolt opened). Waiting for Down arrow (close bolt).\n    /// </summary>\n    WaitCloseBolt,\n\n    /// <summary>\n    /// Step 3 complete (bolt closed). Waiting for Up arrow (chamber round).\n    /// </summary>\n    WaitChamberRound\n}\n\n/// <summary>\n/// ASVK sniper rifle - heavy anti-materiel bolt-action rifle.\n/// Features:\n/// - 12.7x108mm ammunition dealing 50 damage per shot\n/// - Penetrates through 2 walls and through enemies\n/// - Instant bullet speed with smoky dissipating tracer trail\n/// - Very high turn sensitivity\n/// - 5-round magazine with M16-style swap reload\n/// - Single-shot bolt-action with manual charging sequence (Down‚ÜíLeft‚ÜíDown‚ÜíUp)\n/// - Red laser sight for aiming\n/// Reference: ASVK (–ê–°–í–ö) anti-materiel sniper rifle\n/// </summary>\npublic partial class SniperRifle : BaseWeapon\n{\n    // =========================================================================\n    // Bolt-Action State\n    // =========================================================================\n\n    /// <summary>\n    /// Current bolt-action charging step.\n    /// </summary>\n    private BoltActionStep _boltStep = BoltActionStep.Ready;\n\n    /// <summary>\n    /// Whether the bolt action is ready to fire (chambered).\n    /// Initially true so first shot can be fired immediately.\n    /// </summary>\n    public bool IsBoltReady => _boltStep == BoltActionStep.Ready;\n\n    /// <summary>\n    /// Whether the weapon needs bolt cycling before it can fire again.\n    /// </summary>\n    public bool NeedsBoltCycle => _boltStep != BoltActionStep.Ready;\n\n    /// <summary>\n    /// Signal emitted when bolt-action step changes.\n    /// </summary>\n    [Signal]\n    public delegate void BoltStepChangedEventHandler(int step, int totalSteps);\n\n    // =========================================================================\n    // Smoky Tracer Trail\n    // =========================================================================\n\n    /// <summary>\n    /// Scene for the smoky tracer trail effect.\n    /// Created programmatically as a Line2D with smoke-like appearance.\n    /// </summary>\n    private Line2D? _lastTracerTrail;\n\n    // =========================================================================\n    // Laser Sight Configuration\n    // =========================================================================\n\n    /// <summary>\n    /// Whether the laser sight is enabled.\n    /// </summary>\n    [Export]\n    public bool LaserSightEnabled { get; set; } = true;\n\n    /// <summary>\n    /// Maximum length of the laser sight in pixels.\n    /// </summary>\n    [Export]\n    public float LaserSightLength { get; set; } = 500.0f;\n\n    /// <summary>\n    /// Color of the laser sight (red for sniper).\n    /// </summary>\n    [Export]\n    public Color LaserSightColor { get; set; } = new Color(1.0f, 0.0f, 0.0f, 0.5f);\n\n    /// <summary>\n    /// Width of the laser sight line.\n    /// </summary>\n    [Export]\n    public float LaserSightWidth { get; set; } = 2.0f;\n\n    /// <summary>\n    /// Reference to the Line2D node for the laser sight.\n    /// </summary>\n    private Line2D? _laserSight;\n\n    /// <summary>\n    /// Reference to the Sprite2D node for the rifle visual.\n    /// </summary>\n    private Sprite2D? _rifleSprite;\n\n    /// <summary>\n    /// Current aim direction based on laser sight.\n    /// </summary>\n    private Vector2 _aimDirection = Vector2.Right;\n\n    /// <summary>\n    /// Current aim angle in radians.\n    /// </summary>\n    private float _currentAimAngle = 0.0f;\n\n    /// <summary>\n    /// Whether the aim angle has been initialized.\n    /// </summary>\n    private bool _aimAngleInitialized = false;\n\n    /// <summary>\n    /// Current recoil offset angle in radians.\n    /// Heavy sniper recoil.\n    /// </summary>\n    private float _recoilOffset = 0.0f;\n\n    /// <summary>\n    /// Time since the last shot was fired, used for recoil recovery.\n    /// </summary>\n    private float _timeSinceLastShot = 0.0f;\n\n    /// <summary>\n    /// Time in seconds before recoil starts recovering.\n    /// Long delay for heavy sniper.\n    /// </summary>\n    private const float RecoilRecoveryDelay = 0.5f;\n\n    /// <summary>\n    /// Speed at which recoil recovers (radians per second).\n    /// </summary>\n    private const float RecoilRecoverySpeed = 3.0f;\n\n    /// <summary>\n    /// Maximum recoil offset in radians (about 15 degrees).\n    /// </summary>\n    private const float MaxRecoilOffset = 0.26f;\n\n    /// <summary>\n    /// Recoil amount per shot in radians.\n    /// Heavy kick for 12.7mm.\n    /// </summary>\n    private const float RecoilPerShot = 0.15f;\n\n    /// <summary>\n    /// Number of walls this bullet can penetrate through.\n    /// The bullet continues flying after penetrating walls.\n    /// </summary>\n    private const int MaxWallPenetrations = 2;\n\n    public override void _Ready()\n    {\n        base._Ready();\n\n        // Get the rifle sprite for visual representation\n        _rifleSprite = GetNodeOrNull<Sprite2D>(\"RifleSprite\");\n\n        if (_rifleSprite != null)\n        {\n            var texture = _rifleSprite.Texture;\n            GD.Print($\"[SniperRifle] RifleSprite found: visible={_rifleSprite.Visible}, z_index={_rifleSprite.ZIndex}, texture={(texture != null ? \"loaded\" : \"NULL\")}\");\n        }\n        else\n        {\n            GD.PrintErr(\"[SniperRifle] WARNING: RifleSprite node not found!\");\n        }\n\n        // Check for Power Fantasy mode blue laser\n        var difficultyManager = GetNodeOrNull(\"/root/DifficultyManager\");\n        if (difficultyManager != null)\n        {\n            var shouldForceBlueLaser = difficultyManager.Call(\"should_force_blue_laser_sight\");\n            if (shouldForceBlueLaser.AsBool())\n            {\n                var blueColorVariant = difficultyManager.Call(\"get_power_fantasy_laser_color\");\n                LaserSightColor = blueColorVariant.AsColor();\n                GD.Print($\"[SniperRifle] Power Fantasy mode: laser color set to blue {LaserSightColor}\");\n            }\n        }\n\n        // Get or create the laser sight Line2D\n        _laserSight = GetNodeOrNull<Line2D>(\"LaserSight\");\n\n        if (_laserSight == null && LaserSightEnabled)\n        {\n            CreateLaserSight();\n        }\n        else if (_laserSight != null)\n        {\n            _laserSight.Width = LaserSightWidth;\n            _laserSight.DefaultColor = LaserSightColor;\n            _laserSight.BeginCapMode = Line2D.LineCapMode.Round;\n            _laserSight.EndCapMode = Line2D.LineCapMode.Round;\n\n            if (_laserSight.GetPointCount() < 2)\n            {\n                _laserSight.ClearPoints();\n                _laserSight.AddPoint(Vector2.Zero);\n                _laserSight.AddPoint(Vector2.Right * LaserSightLength);\n            }\n        }\n\n        UpdateLaserSightVisibility();\n        GD.Print(\"[SniperRifle] ASVK initialized - bolt ready, laser sight enabled\");\n    }\n\n    public override void _ExitTree()\n    {\n        // Clean up scope overlay when weapon is removed from scene tree\n        if (_isScopeActive)\n        {\n            DeactivateScope();\n        }\n        base._ExitTree();\n    }\n\n    public override void _Process(double delta)\n    {\n        base._Process(delta);\n\n        // Update time since last shot for recoil recovery\n        _timeSinceLastShot += (float)delta;\n\n        // Recover recoil after delay\n        if (_timeSinceLastShot >= RecoilRecoveryDelay && _recoilOffset != 0)\n        {\n            float recoveryAmount = RecoilRecoverySpeed * (float)delta;\n            _recoilOffset = Mathf.MoveToward(_recoilOffset, 0, recoveryAmount);\n        }\n\n        // Always update aim direction and rifle sprite rotation\n        UpdateAimDirection();\n\n        // Update laser sight to point towards mouse (with recoil offset)\n        if (LaserSightEnabled && _laserSight != null)\n        {\n            UpdateLaserSight();\n        }\n\n        // Handle bolt-action input\n        HandleBoltActionInput();\n\n        // Update scope system (sway, camera offset, overlay)\n        UpdateScope((float)delta);\n    }\n\n    // =========================================================================\n    // Bolt-Action Charging Mechanics\n    // =========================================================================\n\n    /// <summary>\n    /// Handles the bolt-action charging input sequence.\n    /// Sequence: Down (pull bolt) ‚Üí Left (open bolt) ‚Üí Down (close bolt) ‚Üí Up (chamber round)\n    /// Uses the arrow keys / WASD movement input actions.\n    /// </summary>\n    private void HandleBoltActionInput()\n    {\n        switch (_boltStep)\n        {\n            case BoltActionStep.NeedsBoltCycle:\n                // Step 1: Down arrow - pull bolt back\n                if (Input.IsActionJustPressed(\"move_down\"))\n                {\n                    _boltStep = BoltActionStep.WaitOpenBolt;\n                    EmitSignal(SignalName.BoltStepChanged, 1, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 1/4: Bolt pulled back\");\n                }\n                break;\n\n            case BoltActionStep.WaitOpenBolt:\n                // Step 2: Left arrow - open bolt\n                if (Input.IsActionJustPressed(\"move_left\"))\n                {\n                    _boltStep = BoltActionStep.WaitCloseBolt;\n                    EmitSignal(SignalName.BoltStepChanged, 2, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 2/4: Bolt opened\");\n                }\n                break;\n\n            case BoltActionStep.WaitCloseBolt:\n                // Step 3: Down arrow - close bolt\n                if (Input.IsActionJustPressed(\"move_down\"))\n                {\n                    _boltStep = BoltActionStep.WaitChamberRound;\n                    EmitSignal(SignalName.BoltStepChanged, 3, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 3/4: Bolt closed\");\n                }\n                break;\n\n            case BoltActionStep.WaitChamberRound:\n                // Step 4: Up arrow - chamber round\n                if (Input.IsActionJustPressed(\"move_up\"))\n                {\n                    _boltStep = BoltActionStep.Ready;\n                    EmitSignal(SignalName.BoltStepChanged, 4, 4);\n                    PlayBoltChamberSound();\n                    GD.Print(\"[SniperRifle] Bolt step 4/4: Round chambered - READY TO FIRE\");\n                }\n                break;\n\n            case BoltActionStep.Ready:\n                // Already ready, no bolt action needed\n                break;\n        }\n    }\n\n    /// <summary>\n    /// Plays the bolt manipulation sound.\n    /// </summary>\n    private void PlayBoltSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_bolt\"))\n        {\n            audioManager.Call(\"play_m16_bolt\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Plays the bolt chamber/ready sound.\n    /// </summary>\n    private void PlayBoltChamberSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_bolt\"))\n        {\n            audioManager.Call(\"play_m16_bolt\", GlobalPosition);\n        }\n    }\n\n    // =========================================================================\n    // Aiming and Laser Sight\n    // =========================================================================\n\n    /// <summary>\n    /// Updates the aim direction and rifle sprite rotation.\n    /// </summary>\n    private void UpdateAimDirection()\n    {\n        Vector2 mousePos = GetGlobalMousePosition();\n        Vector2 toMouse = mousePos - GlobalPosition;\n        float targetAngle = toMouse.Angle();\n\n        if (!_aimAngleInitialized)\n        {\n            _currentAimAngle = targetAngle;\n            _aimAngleInitialized = true;\n        }\n\n        Vector2 direction;\n\n        // Apply sensitivity for the sniper rifle\n        if (WeaponData != null && WeaponData.Sensitivity > 0)\n        {\n            float angleDiff = Mathf.Wrap(targetAngle - _currentAimAngle, -Mathf.Pi, Mathf.Pi);\n            float rotationSpeed = WeaponData.Sensitivity * 10.0f;\n            float delta = (float)GetProcessDeltaTime();\n            float maxRotation = rotationSpeed * delta;\n            float actualRotation = Mathf.Clamp(angleDiff, -maxRotation, maxRotation);\n            _currentAimAngle += actualRotation;\n            direction = new Vector2(Mathf.Cos(_currentAimAngle), Mathf.Sin(_currentAimAngle));\n        }\n        else\n        {\n            if (toMouse.LengthSquared() > 0.001f)\n            {\n                direction = toMouse.Normalized();\n                _currentAimAngle = targetAngle;\n            }\n            else\n            {\n                direction = _aimDirection;\n            }\n        }\n\n        _aimDirection = direction;\n        UpdateRifleSpriteRotation(direction);\n    }\n\n    /// <summary>\n    /// Creates the laser sight Line2D programmatically.\n    /// </summary>\n    private void CreateLaserSight()\n    {\n        _laserSight = new Line2D\n        {\n            Name = \"LaserSight\",\n            Width = LaserSightWidth,\n            DefaultColor = LaserSightColor,\n            BeginCapMode = Line2D.LineCapMode.Round,\n            EndCapMode = Line2D.LineCapMode.Round\n        };\n\n        _laserSight.AddPoint(Vector2.Zero);\n        _laserSight.AddPoint(Vector2.Right * LaserSightLength);\n\n        AddChild(_laserSight);\n    }\n\n    /// <summary>\n    /// Updates the laser sight visualization with recoil offset.\n    /// Uses raycasting to stop at obstacles.\n    /// </summary>\n    private void UpdateLaserSight()\n    {\n        if (_laserSight == null)\n        {\n            return;\n        }\n\n        Vector2 laserDirection = _aimDirection.Rotated(_recoilOffset);\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float maxLaserLength = viewportSize.Length();\n\n        Vector2 endPoint = laserDirection * maxLaserLength;\n\n        var spaceState = GetWorld2D().DirectSpaceState;\n        var query = PhysicsRayQueryParameters2D.Create(\n            GlobalPosition,\n            GlobalPosition + endPoint,\n            4 // Collision mask for obstacles (layer 3 = value 4)\n        );\n\n        var result = spaceState.IntersectRay(query);\n\n        if (result.Count > 0)\n        {\n            Vector2 hitPosition = (Vector2)result[\"position\"];\n            endPoint = hitPosition - GlobalPosition;\n        }\n\n        _laserSight.SetPointPosition(0, Vector2.Zero);\n        _laserSight.SetPointPosition(1, endPoint);\n    }\n\n    /// <summary>\n    /// Updates the visibility of the laser sight.\n    /// </summary>\n    private void UpdateLaserSightVisibility()\n    {\n        if (_laserSight != null)\n        {\n            _laserSight.Visible = LaserSightEnabled;\n        }\n    }\n\n    /// <summary>\n    /// Updates the rifle sprite rotation to match aim direction.\n    /// </summary>\n    private void UpdateRifleSpriteRotation(Vector2 direction)\n    {\n        if (_rifleSprite == null)\n        {\n            return;\n        }\n\n        float angle = direction.Angle();\n        _rifleSprite.Rotation = angle;\n\n        bool aimingLeft = Mathf.Abs(angle) > Mathf.Pi / 2;\n        _rifleSprite.FlipV = aimingLeft;\n    }\n\n    /// <summary>\n    /// Enables or disables the laser sight.\n    /// </summary>\n    public void SetLaserSightEnabled(bool enabled)\n    {\n        LaserSightEnabled = enabled;\n        UpdateLaserSightVisibility();\n    }\n\n    // =========================================================================\n    // Firing\n    // =========================================================================\n\n    /// <summary>\n    /// Fires the sniper rifle. Only fires if bolt is ready.\n    /// After firing, transitions to NeedsBoltCycle state.\n    /// </summary>\n    public override bool Fire(Vector2 direction)\n    {\n        // Check for empty magazine\n        if (CurrentAmmo <= 0)\n        {\n            PlayEmptyClickSound();\n            return false;\n        }\n\n        // Check if bolt is ready\n        if (!IsBoltReady)\n        {\n            // Play a click to indicate bolt not cycled\n            PlayEmptyClickSound();\n            return false;\n        }\n\n        // Check standard fire conditions\n        if (!CanFire || WeaponData == null || BulletScene == null)\n        {\n            return false;\n        }\n\n        // Apply recoil to aim direction\n        Vector2 spreadDirection = ApplyRecoil(_aimDirection);\n        bool result = base.Fire(spreadDirection);\n\n        if (result)\n        {\n            // Transition to needs bolt cycle\n            _boltStep = BoltActionStep.NeedsBoltCycle;\n            EmitSignal(SignalName.BoltStepChanged, 0, 4);\n\n            // Play sniper shot sound\n            PlaySniperShotSound();\n            // Emit gunshot sound for enemy detection\n            EmitGunshotSound();\n            // Play shell casing with delay\n            PlayShellCasingDelayed();\n            // Trigger heavy screen shake\n            TriggerScreenShake(spreadDirection);\n\n            // Spawn smoky tracer trail\n            SpawnSmokyTracer(GlobalPosition, spreadDirection);\n\n            GD.Print(\"[SniperRifle] FIRED! Bolt needs cycling. Ammo remaining: \" + CurrentAmmo);\n        }\n\n        return result;\n    }\n\n    /// <summary>\n    /// Override SpawnBullet to configure the SniperBullet for sniper behavior:\n    /// - Very high damage (50)\n    /// - Passes through enemies (doesn't destroy on hit)\n    /// - Penetrates through 2 walls (wall-count based, not distance-based)\n    /// </summary>\n    protected override void SpawnBullet(Vector2 direction)\n    {\n        if (BulletScene == null)\n        {\n            return;\n        }\n\n        // Check bullet spawn path\n        var (isBlocked, hitPosition, hitNormal) = CheckBulletSpawnPath(direction);\n\n        Vector2 spawnPosition;\n        if (isBlocked)\n        {\n            spawnPosition = GlobalPosition + direction * 2.0f;\n            GD.Print(\"[SniperRifle] Point-blank shot: spawning for penetration\");\n        }\n        else\n        {\n            spawnPosition = GlobalPosition + direction * BulletSpawnOffset;\n        }\n\n        var bulletNode = BulletScene.Instantiate<Node2D>();\n        bulletNode.GlobalPosition = spawnPosition;\n\n        // Try to cast to C# SniperBullet for direct property access\n        var sniperBullet = bulletNode as SniperBullet;\n\n        if (sniperBullet != null)\n        {\n            // SniperBullet - set properties directly\n            sniperBullet.Direction = direction;\n            if (WeaponData != null)\n            {\n                sniperBullet.Speed = WeaponData.BulletSpeed;\n                sniperBullet.Damage = WeaponData.Damage;\n            }\n            var owner = GetParent();\n            if (owner != null)\n            {\n                sniperBullet.ShooterId = owner.GetInstanceId();\n            }\n            sniperBullet.ShooterPosition = GlobalPosition;\n            sniperBullet.MaxWallPenetrations = MaxWallPenetrations;\n            GD.Print($\"[SniperRifle] Spawned SniperBullet: Damage={sniperBullet.Damage}, Speed={sniperBullet.Speed}, MaxWallPen={MaxWallPenetrations}\");\n        }\n        else\n        {\n            // Fallback for any bullet type\n            if (bulletNode.HasMethod(\"SetDirection\"))\n            {\n                bulletNode.Call(\"SetDirection\", direction);\n            }\n            else\n            {\n                bulletNode.Set(\"Direction\", direction);\n                bulletNode.Set(\"direction\", direction);\n            }\n\n            if (WeaponData != null)\n            {\n                bulletNode.Set(\"Speed\", WeaponData.BulletSpeed);\n                bulletNode.Set(\"speed\", WeaponData.BulletSpeed);\n                bulletNode.Set(\"Damage\", WeaponData.Damage);\n                bulletNode.Set(\"damage\", WeaponData.Damage);\n            }\n\n            var owner = GetParent();\n            if (owner != null)\n            {\n                bulletNode.Set(\"ShooterId\", owner.GetInstanceId());\n                bulletNode.Set(\"shooter_id\", owner.GetInstanceId());\n            }\n\n            bulletNode.Set(\"ShooterPosition\", GlobalPosition);\n            bulletNode.Set(\"shooter_position\", GlobalPosition);\n        }\n\n        GetTree().CurrentScene.AddChild(bulletNode);\n\n        // Spawn muzzle flash effect - large flash for 12.7mm\n        SpawnMuzzleFlash(spawnPosition, direction, WeaponData?.Caliber);\n\n        // Spawn casing\n        SpawnCasing(direction, WeaponData?.Caliber);\n    }\n\n    // =========================================================================\n    // Smoky Tracer Trail\n    // =========================================================================\n\n    /// <summary>\n    /// Spawns a smoky dissipating tracer trail from the fire position\n    /// in the shooting direction across the entire map.\n    /// The tracer is an instant visual effect (like a contrail from a plane)\n    /// that fades out over time.\n    /// </summary>\n    private void SpawnSmokyTracer(Vector2 fromPosition, Vector2 direction)\n    {\n        // Calculate tracer end point - extend to edge of map (very far)\n        float tracerLength = 5000.0f; // Far enough to reach any map edge\n        Vector2 endPosition = fromPosition + direction * tracerLength;\n\n        // Create the tracer as a Line2D with smoke-like appearance\n        var tracer = new Line2D\n        {\n            Name = \"SniperTracer\",\n            Width = 6.0f,\n            DefaultColor = new Color(0.8f, 0.8f, 0.8f, 0.7f),\n            BeginCapMode = Line2D.LineCapMode.Round,\n            EndCapMode = Line2D.LineCapMode.Round,\n            TopLevel = true,\n            Position = Vector2.Zero,\n            ZIndex = -1 // Behind other elements\n        };\n\n        // Set up width curve - wider at start, tapers to narrower at end\n        var widthCurve = new Curve();\n        widthCurve.AddPoint(new Vector2(0.0f, 1.0f));\n        widthCurve.AddPoint(new Vector2(0.3f, 0.8f));\n        widthCurve.AddPoint(new Vector2(1.0f, 0.3f));\n        tracer.WidthCurve = widthCurve;\n\n        // Set up gradient - smoky white/gray that fades out\n        var gradient = new Gradient();\n        gradient.SetColor(0, new Color(0.9f, 0.9f, 0.85f, 0.8f));\n        gradient.AddPoint(0.5f, new Color(0.7f, 0.7f, 0.65f, 0.5f));\n        gradient.SetColor(gradient.GetPointCount() - 1, new Color(0.5f, 0.5f, 0.5f, 0.2f));\n        tracer.Gradient = gradient;\n\n        // Add the tracer line points (using global coordinates since TopLevel=true)\n        tracer.AddPoint(fromPosition + direction * BulletSpawnOffset);\n        tracer.AddPoint(endPosition);\n\n        // Add to scene\n        GetTree().CurrentScene.AddChild(tracer);\n\n        // Start the fade-out animation\n        FadeOutTracer(tracer);\n    }\n\n    /// <summary>\n    /// Animates the tracer trail fading out and dissipating over time.\n    /// The tracer gradually becomes more transparent and wider (simulating smoke dissipation).\n    /// </summary>\n    private async void FadeOutTracer(Line2D tracer)\n    {\n        float fadeDuration = 2.0f;\n        float elapsed = 0.0f;\n\n        float initialWidth = tracer.Width;\n\n        while (elapsed < fadeDuration && IsInstanceValid(tracer))\n        {\n            elapsed += (float)GetProcessDeltaTime();\n            float progress = elapsed / fadeDuration;\n\n            // Fade the alpha\n            float alpha = Mathf.Lerp(0.7f, 0.0f, progress);\n            tracer.DefaultColor = new Color(0.8f, 0.8f, 0.8f, alpha);\n\n            // Widen slightly to simulate smoke dissipation\n            tracer.Width = initialWidth + progress * 4.0f;\n\n            // Update gradient alpha\n            var gradient = new Gradient();\n            gradient.SetColor(0, new Color(0.9f, 0.9f, 0.85f, alpha));\n            gradient.AddPoint(0.5f, new Color(0.7f, 0.7f, 0.65f, alpha * 0.6f));\n            gradient.SetColor(gradient.GetPointCount() - 1, new Color(0.5f, 0.5f, 0.5f, alpha * 0.3f));\n            tracer.Gradient = gradient;\n\n            await ToSignal(GetTree(), \"process_frame\");\n        }\n\n        // Remove the tracer after fade completes\n        if (IsInstanceValid(tracer))\n        {\n            tracer.QueueFree();\n        }\n    }\n\n    // =========================================================================\n    // Sound and Effects\n    // =========================================================================\n\n    /// <summary>\n    /// Plays the sniper shot sound via AudioManager.\n    /// </summary>\n    private void PlaySniperShotSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        // Use M16 shot as a placeholder sound for the sniper\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_shot\"))\n        {\n            audioManager.Call(\"play_m16_shot\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Plays the empty gun click sound.\n    /// </summary>\n    private void PlayEmptyClickSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_empty_click\"))\n        {\n            audioManager.Call(\"play_empty_click\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Emits gunshot sound for enemy detection via SoundPropagation.\n    /// Very loud for the 12.7mm round.\n    /// </summary>\n    private void EmitGunshotSound()\n    {\n        var soundPropagation = GetNodeOrNull(\"/root/SoundPropagation\");\n        if (soundPropagation != null && soundPropagation.HasMethod(\"emit_sound\"))\n        {\n            float loudness = WeaponData?.Loudness ?? 3000.0f;\n            soundPropagation.Call(\"emit_sound\", 0, GlobalPosition, 0, this, loudness);\n        }\n    }\n\n    /// <summary>\n    /// Plays shell casing sound with a delay.\n    /// </summary>\n    private async void PlayShellCasingDelayed()\n    {\n        await ToSignal(GetTree().CreateTimer(0.2), \"timeout\");\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_shell_rifle\"))\n        {\n            audioManager.Call(\"play_shell_rifle\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Applies recoil to shooting direction.\n    /// </summary>\n    private Vector2 ApplyRecoil(Vector2 direction)\n    {\n        // Apply current recoil offset\n        Vector2 result = direction.Rotated(_recoilOffset);\n\n        // Add strong recoil for next shot (heavy 12.7mm kick)\n        float recoilDirection = (float)GD.RandRange(-1.0, 1.0);\n        _recoilOffset += recoilDirection * RecoilPerShot;\n        _recoilOffset = Mathf.Clamp(_recoilOffset, -MaxRecoilOffset, MaxRecoilOffset);\n\n        _timeSinceLastShot = 0;\n\n        return result;\n    }\n\n    /// <summary>\n    /// Triggers screen shake from sniper shot.\n    /// Heavy shake for 12.7mm round.\n    /// </summary>\n    private void TriggerScreenShake(Vector2 shootDirection)\n    {\n        if (WeaponData == null || WeaponData.ScreenShakeIntensity <= 0)\n        {\n            return;\n        }\n\n        var screenShakeManager = GetNodeOrNull(\"/root/ScreenShakeManager\");\n        if (screenShakeManager == null || !screenShakeManager.HasMethod(\"add_shake\"))\n        {\n            return;\n        }\n\n        // Heavy shake for sniper\n        float fireRate = WeaponData.FireRate;\n        float shakeIntensity;\n        if (fireRate > 0)\n        {\n            shakeIntensity = WeaponData.ScreenShakeIntensity / fireRate * 10.0f;\n        }\n        else\n        {\n            shakeIntensity = WeaponData.ScreenShakeIntensity;\n        }\n\n        float recoveryTime = WeaponData.ScreenShakeMinRecoveryTime;\n\n        screenShakeManager.Call(\"add_shake\", shootDirection, shakeIntensity, recoveryTime);\n    }\n\n    /// <summary>\n    /// Fires the bullet in the chamber during reload sequence.\n    /// </summary>\n    public override bool FireChamberBullet(Vector2 direction)\n    {\n        // Sniper rifle doesn't support chamber bullet during reload\n        // (bolt-action requires full cycle)\n        return false;\n    }\n\n    /// <summary>\n    /// Gets the current aim direction.\n    /// </summary>\n    public Vector2 AimDirection => _aimDirection;\n\n    /// <summary>\n    /// Gets the current bolt-action step.\n    /// </summary>\n    public BoltActionStep CurrentBoltStep => _boltStep;\n\n    /// <summary>\n    /// Resets the bolt to ready state (e.g., after reload with a new magazine).\n    /// </summary>\n    public void ResetBolt()\n    {\n        _boltStep = BoltActionStep.Ready;\n        EmitSignal(SignalName.BoltStepChanged, 4, 4);\n        GD.Print(\"[SniperRifle] Bolt reset to ready state\");\n    }\n\n    // =========================================================================\n    // Scope / Aiming System (RMB)\n    // =========================================================================\n\n    /// <summary>\n    /// Whether the scope is currently active (RMB held).\n    /// </summary>\n    private bool _isScopeActive = false;\n\n    /// <summary>\n    /// Whether the scope is active (read-only property for external access).\n    /// </summary>\n    public bool IsScopeActive => _isScopeActive;\n\n    /// <summary>\n    /// Signal emitted when scope state changes.\n    /// </summary>\n    [Signal]\n    public delegate void ScopeStateChangedEventHandler(bool isActive);\n\n    /// <summary>\n    /// Current scope zoom distance multiplier (how far beyond viewport the player can see).\n    /// 1.0 = one viewport distance, 2.0 = two viewport distances.\n    /// Controlled by mouse wheel while scoping.\n    /// </summary>\n    private float _scopeZoomDistance = 1.0f;\n\n    /// <summary>\n    /// Minimum scope zoom distance (viewport multiplier).\n    /// </summary>\n    private const float MinScopeZoomDistance = 0.5f;\n\n    /// <summary>\n    /// Maximum scope zoom distance (viewport multiplier).\n    /// </summary>\n    private const float MaxScopeZoomDistance = 3.0f;\n\n    /// <summary>\n    /// Step size for mouse wheel zoom adjustment.\n    /// </summary>\n    private const float ScopeZoomStep = 0.25f;\n\n    /// <summary>\n    /// Base sway amplitude in pixels at 1 viewport distance.\n    /// </summary>\n    private const float BaseScopeSwayAmplitude = 8.0f;\n\n    /// <summary>\n    /// Speed of the sway oscillation.\n    /// </summary>\n    private const float ScopeSwaySpeed = 2.5f;\n\n    /// <summary>\n    /// Current scope sway time accumulator.\n    /// </summary>\n    private float _scopeSwayTime = 0.0f;\n\n    /// <summary>\n    /// Current scope sway offset in pixels (applied to camera).\n    /// </summary>\n    private Vector2 _scopeSwayOffset = Vector2.Zero;\n\n    /// <summary>\n    /// Reference to the scope overlay CanvasLayer (created when scope activates).\n    /// </summary>\n    private CanvasLayer? _scopeOverlay = null;\n\n    /// <summary>\n    /// Reference to the scope crosshair control node.\n    /// </summary>\n    private Control? _scopeCrosshair = null;\n\n    /// <summary>\n    /// Reference to the scope darkening background.\n    /// </summary>\n    private ColorRect? _scopeBackground = null;\n\n    /// <summary>\n    /// Cached reference to the player's Camera2D node.\n    /// </summary>\n    private Camera2D? _playerCamera = null;\n\n    /// <summary>\n    /// Original camera offset before scoping (to restore on exit).\n    /// </summary>\n    private Vector2 _originalCameraOffset = Vector2.Zero;\n\n    /// <summary>\n    /// Gets the current camera offset for scope aiming.\n    /// Called by the player or level scripts to position the camera.\n    /// </summary>\n    public Vector2 GetScopeCameraOffset()\n    {\n        if (!_isScopeActive)\n        {\n            return Vector2.Zero;\n        }\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return Vector2.Zero;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float baseDistance = viewportSize.Length() * 0.5f;\n\n        // Camera offset = aim direction * zoom distance * viewport size + sway\n        Vector2 offset = _aimDirection * baseDistance * _scopeZoomDistance + _scopeSwayOffset;\n\n        return offset;\n    }\n\n    /// <summary>\n    /// Activates the scope (called when RMB is pressed).\n    /// </summary>\n    public void ActivateScope()\n    {\n        if (_isScopeActive)\n        {\n            return;\n        }\n\n        _isScopeActive = true;\n        _scopeSwayTime = 0.0f;\n\n        // Find and cache the player's Camera2D\n        FindPlayerCamera();\n\n        // Store original camera offset\n        if (_playerCamera != null)\n        {\n            _originalCameraOffset = _playerCamera.Offset;\n        }\n\n        // Create the scope overlay\n        CreateScopeOverlay();\n\n        EmitSignal(SignalName.ScopeStateChanged, true);\n        GD.Print($\"[SniperRifle] Scope activated. Zoom distance: {_scopeZoomDistance:F1}x\");\n    }\n\n    /// <summary>\n    /// Deactivates the scope (called when RMB is released).\n    /// </summary>\n    public void DeactivateScope()\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        _isScopeActive = false;\n\n        // Restore original camera offset\n        if (_playerCamera != null)\n        {\n            _playerCamera.Offset = _originalCameraOffset;\n        }\n\n        // Remove scope overlay\n        RemoveScopeOverlay();\n\n        EmitSignal(SignalName.ScopeStateChanged, false);\n        GD.Print(\"[SniperRifle] Scope deactivated.\");\n    }\n\n    /// <summary>\n    /// Adjusts the scope zoom distance (called on mouse wheel while scoping).\n    /// </summary>\n    public void AdjustScopeZoom(float direction)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        _scopeZoomDistance += direction * ScopeZoomStep;\n        _scopeZoomDistance = Mathf.Clamp(_scopeZoomDistance, MinScopeZoomDistance, MaxScopeZoomDistance);\n\n        GD.Print($\"[SniperRifle] Scope zoom adjusted: {_scopeZoomDistance:F2}x\");\n    }\n\n    /// <summary>\n    /// Finds the player's Camera2D node by traversing up to the parent (player).\n    /// </summary>\n    private void FindPlayerCamera()\n    {\n        if (_playerCamera != null)\n        {\n            return;\n        }\n\n        var parent = GetParent();\n        if (parent != null)\n        {\n            _playerCamera = parent.GetNodeOrNull<Camera2D>(\"Camera2D\");\n        }\n    }\n\n    /// <summary>\n    /// Updates the scope system each frame (called from _Process).\n    /// </summary>\n    private void UpdateScope(float delta)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        // Update sway\n        _scopeSwayTime += delta;\n        float swayAmplitude = BaseScopeSwayAmplitude * _scopeZoomDistance;\n\n        // Use two sine waves at different frequencies for natural-looking sway\n        float swayX = Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 1.0f) * swayAmplitude\n                    + Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 2.3f) * swayAmplitude * 0.3f;\n        float swayY = Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 1.4f) * swayAmplitude\n                    + Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 0.7f) * swayAmplitude * 0.4f;\n\n        _scopeSwayOffset = new Vector2(swayX, swayY);\n\n        // Update camera offset for scope view\n        if (_playerCamera != null)\n        {\n            _playerCamera.Offset = _originalCameraOffset + GetScopeCameraOffset();\n        }\n\n        // Update scope overlay crosshair position with sway\n        UpdateScopeOverlayPosition();\n    }\n\n    /// <summary>\n    /// Creates the scope overlay UI with crosshair and darkened edges.\n    /// </summary>\n    private void CreateScopeOverlay()\n    {\n        RemoveScopeOverlay();\n\n        _scopeOverlay = new CanvasLayer\n        {\n            Name = \"ScopeOverlay\",\n            Layer = 10\n        };\n\n        Viewport? viewport = GetViewport();\n        Vector2 viewportSize = viewport?.GetVisibleRect().Size ?? new Vector2(1280, 720);\n\n        // Dark background with circular cutout effect (vignette)\n        _scopeBackground = new ColorRect\n        {\n            Name = \"ScopeBackground\",\n            Color = new Color(0.0f, 0.0f, 0.0f, 0.5f),\n            Size = viewportSize,\n            Position = Vector2.Zero,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        _scopeOverlay.AddChild(_scopeBackground);\n\n        // Create the crosshair as a Control node\n        _scopeCrosshair = new Control\n        {\n            Name = \"ScopeCrosshair\",\n            Position = viewportSize / 2,\n            Size = Vector2.Zero,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        _scopeOverlay.AddChild(_scopeCrosshair);\n\n        // Add crosshair lines - based on the reference image from the issue\n        // The scope has a classic crosshair with circle and mil-dots\n\n        // Outer circle\n        float circleRadius = Mathf.Min(viewportSize.X, viewportSize.Y) * 0.35f;\n        int segments = 64;\n        var outerCircle = new Line2D\n        {\n            Name = \"OuterCircle\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f),\n            Antialiased = true\n        };\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            outerCircle.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * circleRadius);\n        }\n        _scopeCrosshair.AddChild(outerCircle);\n\n        // Inner thin circle\n        float innerRadius = circleRadius * 0.05f;\n        var innerCircle = new Line2D\n        {\n            Name = \"InnerCircle\",\n            Width = 1.5f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f),\n            Antialiased = true\n        };\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            innerCircle.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * innerRadius);\n        }\n        _scopeCrosshair.AddChild(innerCircle);\n\n        // Horizontal crosshair line (left)\n        var hLineLeft = new Line2D\n        {\n            Name = \"HLineLeft\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        hLineLeft.AddPoint(new Vector2(-circleRadius, 0));\n        hLineLeft.AddPoint(new Vector2(-innerRadius, 0));\n        _scopeCrosshair.AddChild(hLineLeft);\n\n        // Horizontal crosshair line (right)\n        var hLineRight = new Line2D\n        {\n            Name = \"HLineRight\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        hLineRight.AddPoint(new Vector2(innerRadius, 0));\n        hLineRight.AddPoint(new Vector2(circleRadius, 0));\n        _scopeCrosshair.AddChild(hLineRight);\n\n        // Vertical crosshair line (top)\n        var vLineTop = new Line2D\n        {\n            Name = \"VLineTop\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        vLineTop.AddPoint(new Vector2(0, -circleRadius));\n        vLineTop.AddPoint(new Vector2(0, -innerRadius));\n        _scopeCrosshair.AddChild(vLineTop);\n\n        // Vertical crosshair line (bottom) with mil-dots\n        var vLineBottom = new Line2D\n        {\n            Name = \"VLineBottom\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        vLineBottom.AddPoint(new Vector2(0, innerRadius));\n        vLineBottom.AddPoint(new Vector2(0, circleRadius));\n        _scopeCrosshair.AddChild(vLineBottom);\n\n        // Add mil-dot markers on the bottom crosshair (range estimation)\n        float dotSpacing = circleRadius * 0.15f;\n        for (int i = 1; i <= 4; i++)\n        {\n            float dotY = dotSpacing * i;\n            var dot = new Line2D\n            {\n                Name = $\"MilDot_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            float dotWidth = 4.0f - i * 0.5f; // Dots get smaller further from center\n            dot.AddPoint(new Vector2(-dotWidth, dotY));\n            dot.AddPoint(new Vector2(dotWidth, dotY));\n            _scopeCrosshair.AddChild(dot);\n        }\n\n        // Add mil-dot markers on horizontal lines\n        for (int i = 1; i <= 3; i++)\n        {\n            float dotX = dotSpacing * i;\n            // Right side dots\n            var dotRight = new Line2D\n            {\n                Name = $\"HMilDotRight_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            float dotHeight = 4.0f - i * 0.5f;\n            dotRight.AddPoint(new Vector2(dotX, -dotHeight));\n            dotRight.AddPoint(new Vector2(dotX, dotHeight));\n            _scopeCrosshair.AddChild(dotRight);\n\n            // Left side dots\n            var dotLeft = new Line2D\n            {\n                Name = $\"HMilDotLeft_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            dotLeft.AddPoint(new Vector2(-dotX, -dotHeight));\n            dotLeft.AddPoint(new Vector2(-dotX, dotHeight));\n            _scopeCrosshair.AddChild(dotLeft);\n        }\n\n        // Add thick outer ring to mask edges (simulate scope tube)\n        var scopeRing = new Line2D\n        {\n            Name = \"ScopeRing\",\n            Width = 6.0f,\n            DefaultColor = new Color(0.1f, 0.1f, 0.1f, 0.95f),\n            Antialiased = true\n        };\n        float ringRadius = circleRadius + 3.0f;\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            scopeRing.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * ringRadius);\n        }\n        _scopeCrosshair.AddChild(scopeRing);\n\n        // Zoom distance indicator text\n        var zoomLabel = new Label\n        {\n            Name = \"ZoomLabel\",\n            Position = new Vector2(circleRadius * 0.5f, circleRadius * 0.7f),\n            Text = $\"{_scopeZoomDistance:F1}x\",\n            HorizontalAlignment = HorizontalAlignment.Center,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        zoomLabel.AddThemeColorOverride(\"font_color\", new Color(0.0f, 0.0f, 0.0f, 0.6f));\n        zoomLabel.AddThemeFontSizeOverride(\"font_size\", 12);\n        _scopeCrosshair.AddChild(zoomLabel);\n\n        GetTree().CurrentScene.AddChild(_scopeOverlay);\n    }\n\n    /// <summary>\n    /// Updates the scope overlay crosshair position with sway applied.\n    /// </summary>\n    private void UpdateScopeOverlayPosition()\n    {\n        if (_scopeCrosshair == null || _scopeOverlay == null)\n        {\n            return;\n        }\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n\n        // Crosshair stays centered but sways\n        _scopeCrosshair.Position = viewportSize / 2 + _scopeSwayOffset;\n\n        // Update zoom label\n        var zoomLabel = _scopeCrosshair.GetNodeOrNull<Label>(\"ZoomLabel\");\n        if (zoomLabel != null)\n        {\n            zoomLabel.Text = $\"{_scopeZoomDistance:F1}x\";\n        }\n    }\n\n    /// <summary>\n    /// Removes the scope overlay from the scene.\n    /// </summary>\n    private void RemoveScopeOverlay()\n    {\n        if (_scopeOverlay != null && IsInstanceValid(_scopeOverlay))\n        {\n            _scopeOverlay.QueueFree();\n            _scopeOverlay = null;\n            _scopeCrosshair = null;\n            _scopeBackground = null;\n        }\n    }\n}\n",
    "structuredPatch": [
      {
        "oldStart": 924,
        "oldLines": 8,
        "newStart": 924,
        "newLines": 9,
        "lines": [
          " ",
          "     /// <summary>",
          "     /// Minimum scope zoom distance (viewport multiplier).",
          "+    /// Set to 1.0 so the scope always looks beyond the normal viewport.",
          "     /// </summary>",
          "-    private const float MinScopeZoomDistance = 0.5f;",
          "+    private const float MinScopeZoomDistance = 1.0f;",
          " ",
          "     /// <summary>",
          "     /// Maximum scope zoom distance (viewport multiplier)."
        ]
      }
    ],
    "userModified": false,
    "replaceAll": false
  }
}
[2026-02-06T20:57:08.781Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01PGm8SycmG6DW7MzjeseYWp",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now let me add the mouse-based fine-tuning offset for the scope (fix #1) and the method to get the world-space aim target for bullets (fix #2). I need to add a new field for the mouse fine-tune offset and update the relevant methods."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 571,
      "cache_read_input_tokens": 58480,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 571
      },
      "output_tokens": 1,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "292a14f1-e176-466a-bd8b-7e641a7eac65"
}
[2026-02-06T20:57:12.785Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01PGm8SycmG6DW7MzjeseYWp",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01GVeHjqPDvrexcyNJhw3nPX",
        "name": "Edit",
        "input": {
          "replace_all": false,
          "file_path": "/tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs",
          "old_string": "    /// <summary>\n    /// Current scope sway time accumulator.\n    /// </summary>\n    private float _scopeSwayTime = 0.0f;",
          "new_string": "    /// <summary>\n    /// Maximum range (in viewport fraction) that the player can fine-tune the scope\n    /// distance via mouse movement while scoped. About 1/3 of the viewport.\n    /// </summary>\n    private const float ScopeMouseFineTuneRange = 0.33f;\n\n    /// <summary>\n    /// Current mouse fine-tune offset applied to scope distance.\n    /// Ranges from -ScopeMouseFineTuneRange to +ScopeMouseFineTuneRange (viewport fraction).\n    /// Positive = further, negative = closer.\n    /// </summary>\n    private float _scopeMouseFineTuneOffset = 0.0f;\n\n    /// <summary>\n    /// Current scope sway time accumulator.\n    /// </summary>\n    private float _scopeSwayTime = 0.0f;"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 571,
      "cache_read_input_tokens": 58480,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 571
      },
      "output_tokens": 1,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "8b17f033-aa98-48ef-bd19-9b7ce2b997a9"
}
[2026-02-06T20:57:12.797Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01GVeHjqPDvrexcyNJhw3nPX",
        "type": "tool_result",
        "content": "The file /tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs has been updated successfully."
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "686023ac-660e-4050-b427-5a56a8874150",
  "tool_use_result": {
    "filePath": "/tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs",
    "oldString": "    /// <summary>\n    /// Current scope sway time accumulator.\n    /// </summary>\n    private float _scopeSwayTime = 0.0f;",
    "newString": "    /// <summary>\n    /// Maximum range (in viewport fraction) that the player can fine-tune the scope\n    /// distance via mouse movement while scoped. About 1/3 of the viewport.\n    /// </summary>\n    private const float ScopeMouseFineTuneRange = 0.33f;\n\n    /// <summary>\n    /// Current mouse fine-tune offset applied to scope distance.\n    /// Ranges from -ScopeMouseFineTuneRange to +ScopeMouseFineTuneRange (viewport fraction).\n    /// Positive = further, negative = closer.\n    /// </summary>\n    private float _scopeMouseFineTuneOffset = 0.0f;\n\n    /// <summary>\n    /// Current scope sway time accumulator.\n    /// </summary>\n    private float _scopeSwayTime = 0.0f;",
    "originalFile": "using Godot;\nusing GodotTopDownTemplate.AbstractClasses;\nusing GodotTopDownTemplate.Projectiles;\n\nnamespace GodotTopDownTemplate.Weapons;\n\n/// <summary>\n/// Bolt-action charging state for the ASVK sniper rifle.\n/// Before each shot, the player must complete a 4-step bolt-action sequence:\n/// Down (pull bolt back) ‚Üí Left (open bolt) ‚Üí Down (close bolt) ‚Üí Up (chamber round)\n/// </summary>\npublic enum BoltActionStep\n{\n    /// <summary>\n    /// Bolt is ready - weapon can fire. After firing, transitions to NeedsBoltCycle.\n    /// </summary>\n    Ready,\n\n    /// <summary>\n    /// Just fired - needs bolt cycling before next shot.\n    /// Waiting for Down arrow (pull bolt back).\n    /// </summary>\n    NeedsBoltCycle,\n\n    /// <summary>\n    /// Step 1 complete (bolt pulled back). Waiting for Left arrow (open bolt).\n    /// </summary>\n    WaitOpenBolt,\n\n    /// <summary>\n    /// Step 2 complete (bolt opened). Waiting for Down arrow (close bolt).\n    /// </summary>\n    WaitCloseBolt,\n\n    /// <summary>\n    /// Step 3 complete (bolt closed). Waiting for Up arrow (chamber round).\n    /// </summary>\n    WaitChamberRound\n}\n\n/// <summary>\n/// ASVK sniper rifle - heavy anti-materiel bolt-action rifle.\n/// Features:\n/// - 12.7x108mm ammunition dealing 50 damage per shot\n/// - Penetrates through 2 walls and through enemies\n/// - Instant bullet speed with smoky dissipating tracer trail\n/// - Very high turn sensitivity\n/// - 5-round magazine with M16-style swap reload\n/// - Single-shot bolt-action with manual charging sequence (Down‚ÜíLeft‚ÜíDown‚ÜíUp)\n/// - Red laser sight for aiming\n/// Reference: ASVK (–ê–°–í–ö) anti-materiel sniper rifle\n/// </summary>\npublic partial class SniperRifle : BaseWeapon\n{\n    // =========================================================================\n    // Bolt-Action State\n    // =========================================================================\n\n    /// <summary>\n    /// Current bolt-action charging step.\n    /// </summary>\n    private BoltActionStep _boltStep = BoltActionStep.Ready;\n\n    /// <summary>\n    /// Whether the bolt action is ready to fire (chambered).\n    /// Initially true so first shot can be fired immediately.\n    /// </summary>\n    public bool IsBoltReady => _boltStep == BoltActionStep.Ready;\n\n    /// <summary>\n    /// Whether the weapon needs bolt cycling before it can fire again.\n    /// </summary>\n    public bool NeedsBoltCycle => _boltStep != BoltActionStep.Ready;\n\n    /// <summary>\n    /// Signal emitted when bolt-action step changes.\n    /// </summary>\n    [Signal]\n    public delegate void BoltStepChangedEventHandler(int step, int totalSteps);\n\n    // =========================================================================\n    // Smoky Tracer Trail\n    // =========================================================================\n\n    /// <summary>\n    /// Scene for the smoky tracer trail effect.\n    /// Created programmatically as a Line2D with smoke-like appearance.\n    /// </summary>\n    private Line2D? _lastTracerTrail;\n\n    // =========================================================================\n    // Laser Sight Configuration\n    // =========================================================================\n\n    /// <summary>\n    /// Whether the laser sight is enabled.\n    /// </summary>\n    [Export]\n    public bool LaserSightEnabled { get; set; } = true;\n\n    /// <summary>\n    /// Maximum length of the laser sight in pixels.\n    /// </summary>\n    [Export]\n    public float LaserSightLength { get; set; } = 500.0f;\n\n    /// <summary>\n    /// Color of the laser sight (red for sniper).\n    /// </summary>\n    [Export]\n    public Color LaserSightColor { get; set; } = new Color(1.0f, 0.0f, 0.0f, 0.5f);\n\n    /// <summary>\n    /// Width of the laser sight line.\n    /// </summary>\n    [Export]\n    public float LaserSightWidth { get; set; } = 2.0f;\n\n    /// <summary>\n    /// Reference to the Line2D node for the laser sight.\n    /// </summary>\n    private Line2D? _laserSight;\n\n    /// <summary>\n    /// Reference to the Sprite2D node for the rifle visual.\n    /// </summary>\n    private Sprite2D? _rifleSprite;\n\n    /// <summary>\n    /// Current aim direction based on laser sight.\n    /// </summary>\n    private Vector2 _aimDirection = Vector2.Right;\n\n    /// <summary>\n    /// Current aim angle in radians.\n    /// </summary>\n    private float _currentAimAngle = 0.0f;\n\n    /// <summary>\n    /// Whether the aim angle has been initialized.\n    /// </summary>\n    private bool _aimAngleInitialized = false;\n\n    /// <summary>\n    /// Current recoil offset angle in radians.\n    /// Heavy sniper recoil.\n    /// </summary>\n    private float _recoilOffset = 0.0f;\n\n    /// <summary>\n    /// Time since the last shot was fired, used for recoil recovery.\n    /// </summary>\n    private float _timeSinceLastShot = 0.0f;\n\n    /// <summary>\n    /// Time in seconds before recoil starts recovering.\n    /// Long delay for heavy sniper.\n    /// </summary>\n    private const float RecoilRecoveryDelay = 0.5f;\n\n    /// <summary>\n    /// Speed at which recoil recovers (radians per second).\n    /// </summary>\n    private const float RecoilRecoverySpeed = 3.0f;\n\n    /// <summary>\n    /// Maximum recoil offset in radians (about 15 degrees).\n    /// </summary>\n    private const float MaxRecoilOffset = 0.26f;\n\n    /// <summary>\n    /// Recoil amount per shot in radians.\n    /// Heavy kick for 12.7mm.\n    /// </summary>\n    private const float RecoilPerShot = 0.15f;\n\n    /// <summary>\n    /// Number of walls this bullet can penetrate through.\n    /// The bullet continues flying after penetrating walls.\n    /// </summary>\n    private const int MaxWallPenetrations = 2;\n\n    public override void _Ready()\n    {\n        base._Ready();\n\n        // Get the rifle sprite for visual representation\n        _rifleSprite = GetNodeOrNull<Sprite2D>(\"RifleSprite\");\n\n        if (_rifleSprite != null)\n        {\n            var texture = _rifleSprite.Texture;\n            GD.Print($\"[SniperRifle] RifleSprite found: visible={_rifleSprite.Visible}, z_index={_rifleSprite.ZIndex}, texture={(texture != null ? \"loaded\" : \"NULL\")}\");\n        }\n        else\n        {\n            GD.PrintErr(\"[SniperRifle] WARNING: RifleSprite node not found!\");\n        }\n\n        // Check for Power Fantasy mode blue laser\n        var difficultyManager = GetNodeOrNull(\"/root/DifficultyManager\");\n        if (difficultyManager != null)\n        {\n            var shouldForceBlueLaser = difficultyManager.Call(\"should_force_blue_laser_sight\");\n            if (shouldForceBlueLaser.AsBool())\n            {\n                var blueColorVariant = difficultyManager.Call(\"get_power_fantasy_laser_color\");\n                LaserSightColor = blueColorVariant.AsColor();\n                GD.Print($\"[SniperRifle] Power Fantasy mode: laser color set to blue {LaserSightColor}\");\n            }\n        }\n\n        // Get or create the laser sight Line2D\n        _laserSight = GetNodeOrNull<Line2D>(\"LaserSight\");\n\n        if (_laserSight == null && LaserSightEnabled)\n        {\n            CreateLaserSight();\n        }\n        else if (_laserSight != null)\n        {\n            _laserSight.Width = LaserSightWidth;\n            _laserSight.DefaultColor = LaserSightColor;\n            _laserSight.BeginCapMode = Line2D.LineCapMode.Round;\n            _laserSight.EndCapMode = Line2D.LineCapMode.Round;\n\n            if (_laserSight.GetPointCount() < 2)\n            {\n                _laserSight.ClearPoints();\n                _laserSight.AddPoint(Vector2.Zero);\n                _laserSight.AddPoint(Vector2.Right * LaserSightLength);\n            }\n        }\n\n        UpdateLaserSightVisibility();\n        GD.Print(\"[SniperRifle] ASVK initialized - bolt ready, laser sight enabled\");\n    }\n\n    public override void _ExitTree()\n    {\n        // Clean up scope overlay when weapon is removed from scene tree\n        if (_isScopeActive)\n        {\n            DeactivateScope();\n        }\n        base._ExitTree();\n    }\n\n    public override void _Process(double delta)\n    {\n        base._Process(delta);\n\n        // Update time since last shot for recoil recovery\n        _timeSinceLastShot += (float)delta;\n\n        // Recover recoil after delay\n        if (_timeSinceLastShot >= RecoilRecoveryDelay && _recoilOffset != 0)\n        {\n            float recoveryAmount = RecoilRecoverySpeed * (float)delta;\n            _recoilOffset = Mathf.MoveToward(_recoilOffset, 0, recoveryAmount);\n        }\n\n        // Always update aim direction and rifle sprite rotation\n        UpdateAimDirection();\n\n        // Update laser sight to point towards mouse (with recoil offset)\n        if (LaserSightEnabled && _laserSight != null)\n        {\n            UpdateLaserSight();\n        }\n\n        // Handle bolt-action input\n        HandleBoltActionInput();\n\n        // Update scope system (sway, camera offset, overlay)\n        UpdateScope((float)delta);\n    }\n\n    // =========================================================================\n    // Bolt-Action Charging Mechanics\n    // =========================================================================\n\n    /// <summary>\n    /// Handles the bolt-action charging input sequence.\n    /// Sequence: Down (pull bolt) ‚Üí Left (open bolt) ‚Üí Down (close bolt) ‚Üí Up (chamber round)\n    /// Uses the arrow keys / WASD movement input actions.\n    /// </summary>\n    private void HandleBoltActionInput()\n    {\n        switch (_boltStep)\n        {\n            case BoltActionStep.NeedsBoltCycle:\n                // Step 1: Down arrow - pull bolt back\n                if (Input.IsActionJustPressed(\"move_down\"))\n                {\n                    _boltStep = BoltActionStep.WaitOpenBolt;\n                    EmitSignal(SignalName.BoltStepChanged, 1, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 1/4: Bolt pulled back\");\n                }\n                break;\n\n            case BoltActionStep.WaitOpenBolt:\n                // Step 2: Left arrow - open bolt\n                if (Input.IsActionJustPressed(\"move_left\"))\n                {\n                    _boltStep = BoltActionStep.WaitCloseBolt;\n                    EmitSignal(SignalName.BoltStepChanged, 2, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 2/4: Bolt opened\");\n                }\n                break;\n\n            case BoltActionStep.WaitCloseBolt:\n                // Step 3: Down arrow - close bolt\n                if (Input.IsActionJustPressed(\"move_down\"))\n                {\n                    _boltStep = BoltActionStep.WaitChamberRound;\n                    EmitSignal(SignalName.BoltStepChanged, 3, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 3/4: Bolt closed\");\n                }\n                break;\n\n            case BoltActionStep.WaitChamberRound:\n                // Step 4: Up arrow - chamber round\n                if (Input.IsActionJustPressed(\"move_up\"))\n                {\n                    _boltStep = BoltActionStep.Ready;\n                    EmitSignal(SignalName.BoltStepChanged, 4, 4);\n                    PlayBoltChamberSound();\n                    GD.Print(\"[SniperRifle] Bolt step 4/4: Round chambered - READY TO FIRE\");\n                }\n                break;\n\n            case BoltActionStep.Ready:\n                // Already ready, no bolt action needed\n                break;\n        }\n    }\n\n    /// <summary>\n    /// Plays the bolt manipulation sound.\n    /// </summary>\n    private void PlayBoltSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_bolt\"))\n        {\n            audioManager.Call(\"play_m16_bolt\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Plays the bolt chamber/ready sound.\n    /// </summary>\n    private void PlayBoltChamberSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_bolt\"))\n        {\n            audioManager.Call(\"play_m16_bolt\", GlobalPosition);\n        }\n    }\n\n    // =========================================================================\n    // Aiming and Laser Sight\n    // =========================================================================\n\n    /// <summary>\n    /// Updates the aim direction and rifle sprite rotation.\n    /// </summary>\n    private void UpdateAimDirection()\n    {\n        Vector2 mousePos = GetGlobalMousePosition();\n        Vector2 toMouse = mousePos - GlobalPosition;\n        float targetAngle = toMouse.Angle();\n\n        if (!_aimAngleInitialized)\n        {\n            _currentAimAngle = targetAngle;\n            _aimAngleInitialized = true;\n        }\n\n        Vector2 direction;\n\n        // Apply sensitivity for the sniper rifle\n        if (WeaponData != null && WeaponData.Sensitivity > 0)\n        {\n            float angleDiff = Mathf.Wrap(targetAngle - _currentAimAngle, -Mathf.Pi, Mathf.Pi);\n            float rotationSpeed = WeaponData.Sensitivity * 10.0f;\n            float delta = (float)GetProcessDeltaTime();\n            float maxRotation = rotationSpeed * delta;\n            float actualRotation = Mathf.Clamp(angleDiff, -maxRotation, maxRotation);\n            _currentAimAngle += actualRotation;\n            direction = new Vector2(Mathf.Cos(_currentAimAngle), Mathf.Sin(_currentAimAngle));\n        }\n        else\n        {\n            if (toMouse.LengthSquared() > 0.001f)\n            {\n                direction = toMouse.Normalized();\n                _currentAimAngle = targetAngle;\n            }\n            else\n            {\n                direction = _aimDirection;\n            }\n        }\n\n        _aimDirection = direction;\n        UpdateRifleSpriteRotation(direction);\n    }\n\n    /// <summary>\n    /// Creates the laser sight Line2D programmatically.\n    /// </summary>\n    private void CreateLaserSight()\n    {\n        _laserSight = new Line2D\n        {\n            Name = \"LaserSight\",\n            Width = LaserSightWidth,\n            DefaultColor = LaserSightColor,\n            BeginCapMode = Line2D.LineCapMode.Round,\n            EndCapMode = Line2D.LineCapMode.Round\n        };\n\n        _laserSight.AddPoint(Vector2.Zero);\n        _laserSight.AddPoint(Vector2.Right * LaserSightLength);\n\n        AddChild(_laserSight);\n    }\n\n    /// <summary>\n    /// Updates the laser sight visualization with recoil offset.\n    /// Uses raycasting to stop at obstacles.\n    /// </summary>\n    private void UpdateLaserSight()\n    {\n        if (_laserSight == null)\n        {\n            return;\n        }\n\n        Vector2 laserDirection = _aimDirection.Rotated(_recoilOffset);\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float maxLaserLength = viewportSize.Length();\n\n        Vector2 endPoint = laserDirection * maxLaserLength;\n\n        var spaceState = GetWorld2D().DirectSpaceState;\n        var query = PhysicsRayQueryParameters2D.Create(\n            GlobalPosition,\n            GlobalPosition + endPoint,\n            4 // Collision mask for obstacles (layer 3 = value 4)\n        );\n\n        var result = spaceState.IntersectRay(query);\n\n        if (result.Count > 0)\n        {\n            Vector2 hitPosition = (Vector2)result[\"position\"];\n            endPoint = hitPosition - GlobalPosition;\n        }\n\n        _laserSight.SetPointPosition(0, Vector2.Zero);\n        _laserSight.SetPointPosition(1, endPoint);\n    }\n\n    /// <summary>\n    /// Updates the visibility of the laser sight.\n    /// </summary>\n    private void UpdateLaserSightVisibility()\n    {\n        if (_laserSight != null)\n        {\n            _laserSight.Visible = LaserSightEnabled;\n        }\n    }\n\n    /// <summary>\n    /// Updates the rifle sprite rotation to match aim direction.\n    /// </summary>\n    private void UpdateRifleSpriteRotation(Vector2 direction)\n    {\n        if (_rifleSprite == null)\n        {\n            return;\n        }\n\n        float angle = direction.Angle();\n        _rifleSprite.Rotation = angle;\n\n        bool aimingLeft = Mathf.Abs(angle) > Mathf.Pi / 2;\n        _rifleSprite.FlipV = aimingLeft;\n    }\n\n    /// <summary>\n    /// Enables or disables the laser sight.\n    /// </summary>\n    public void SetLaserSightEnabled(bool enabled)\n    {\n        LaserSightEnabled = enabled;\n        UpdateLaserSightVisibility();\n    }\n\n    // =========================================================================\n    // Firing\n    // =========================================================================\n\n    /// <summary>\n    /// Fires the sniper rifle. Only fires if bolt is ready.\n    /// After firing, transitions to NeedsBoltCycle state.\n    /// </summary>\n    public override bool Fire(Vector2 direction)\n    {\n        // Check for empty magazine\n        if (CurrentAmmo <= 0)\n        {\n            PlayEmptyClickSound();\n            return false;\n        }\n\n        // Check if bolt is ready\n        if (!IsBoltReady)\n        {\n            // Play a click to indicate bolt not cycled\n            PlayEmptyClickSound();\n            return false;\n        }\n\n        // Check standard fire conditions\n        if (!CanFire || WeaponData == null || BulletScene == null)\n        {\n            return false;\n        }\n\n        // Apply recoil to aim direction\n        Vector2 spreadDirection = ApplyRecoil(_aimDirection);\n        bool result = base.Fire(spreadDirection);\n\n        if (result)\n        {\n            // Transition to needs bolt cycle\n            _boltStep = BoltActionStep.NeedsBoltCycle;\n            EmitSignal(SignalName.BoltStepChanged, 0, 4);\n\n            // Play sniper shot sound\n            PlaySniperShotSound();\n            // Emit gunshot sound for enemy detection\n            EmitGunshotSound();\n            // Play shell casing with delay\n            PlayShellCasingDelayed();\n            // Trigger heavy screen shake\n            TriggerScreenShake(spreadDirection);\n\n            // Spawn smoky tracer trail\n            SpawnSmokyTracer(GlobalPosition, spreadDirection);\n\n            GD.Print(\"[SniperRifle] FIRED! Bolt needs cycling. Ammo remaining: \" + CurrentAmmo);\n        }\n\n        return result;\n    }\n\n    /// <summary>\n    /// Override SpawnBullet to configure the SniperBullet for sniper behavior:\n    /// - Very high damage (50)\n    /// - Passes through enemies (doesn't destroy on hit)\n    /// - Penetrates through 2 walls (wall-count based, not distance-based)\n    /// </summary>\n    protected override void SpawnBullet(Vector2 direction)\n    {\n        if (BulletScene == null)\n        {\n            return;\n        }\n\n        // Check bullet spawn path\n        var (isBlocked, hitPosition, hitNormal) = CheckBulletSpawnPath(direction);\n\n        Vector2 spawnPosition;\n        if (isBlocked)\n        {\n            spawnPosition = GlobalPosition + direction * 2.0f;\n            GD.Print(\"[SniperRifle] Point-blank shot: spawning for penetration\");\n        }\n        else\n        {\n            spawnPosition = GlobalPosition + direction * BulletSpawnOffset;\n        }\n\n        var bulletNode = BulletScene.Instantiate<Node2D>();\n        bulletNode.GlobalPosition = spawnPosition;\n\n        // Try to cast to C# SniperBullet for direct property access\n        var sniperBullet = bulletNode as SniperBullet;\n\n        if (sniperBullet != null)\n        {\n            // SniperBullet - set properties directly\n            sniperBullet.Direction = direction;\n            if (WeaponData != null)\n            {\n                sniperBullet.Speed = WeaponData.BulletSpeed;\n                sniperBullet.Damage = WeaponData.Damage;\n            }\n            var owner = GetParent();\n            if (owner != null)\n            {\n                sniperBullet.ShooterId = owner.GetInstanceId();\n            }\n            sniperBullet.ShooterPosition = GlobalPosition;\n            sniperBullet.MaxWallPenetrations = MaxWallPenetrations;\n            GD.Print($\"[SniperRifle] Spawned SniperBullet: Damage={sniperBullet.Damage}, Speed={sniperBullet.Speed}, MaxWallPen={MaxWallPenetrations}\");\n        }\n        else\n        {\n            // Fallback for any bullet type\n            if (bulletNode.HasMethod(\"SetDirection\"))\n            {\n                bulletNode.Call(\"SetDirection\", direction);\n            }\n            else\n            {\n                bulletNode.Set(\"Direction\", direction);\n                bulletNode.Set(\"direction\", direction);\n            }\n\n            if (WeaponData != null)\n            {\n                bulletNode.Set(\"Speed\", WeaponData.BulletSpeed);\n                bulletNode.Set(\"speed\", WeaponData.BulletSpeed);\n                bulletNode.Set(\"Damage\", WeaponData.Damage);\n                bulletNode.Set(\"damage\", WeaponData.Damage);\n            }\n\n            var owner = GetParent();\n            if (owner != null)\n            {\n                bulletNode.Set(\"ShooterId\", owner.GetInstanceId());\n                bulletNode.Set(\"shooter_id\", owner.GetInstanceId());\n            }\n\n            bulletNode.Set(\"ShooterPosition\", GlobalPosition);\n            bulletNode.Set(\"shooter_position\", GlobalPosition);\n        }\n\n        GetTree().CurrentScene.AddChild(bulletNode);\n\n        // Spawn muzzle flash effect - large flash for 12.7mm\n        SpawnMuzzleFlash(spawnPosition, direction, WeaponData?.Caliber);\n\n        // Spawn casing\n        SpawnCasing(direction, WeaponData?.Caliber);\n    }\n\n    // =========================================================================\n    // Smoky Tracer Trail\n    // =========================================================================\n\n    /// <summary>\n    /// Spawns a smoky dissipating tracer trail from the fire position\n    /// in the shooting direction across the entire map.\n    /// The tracer is an instant visual effect (like a contrail from a plane)\n    /// that fades out over time.\n    /// </summary>\n    private void SpawnSmokyTracer(Vector2 fromPosition, Vector2 direction)\n    {\n        // Calculate tracer end point - extend to edge of map (very far)\n        float tracerLength = 5000.0f; // Far enough to reach any map edge\n        Vector2 endPosition = fromPosition + direction * tracerLength;\n\n        // Create the tracer as a Line2D with smoke-like appearance\n        var tracer = new Line2D\n        {\n            Name = \"SniperTracer\",\n            Width = 6.0f,\n            DefaultColor = new Color(0.8f, 0.8f, 0.8f, 0.7f),\n            BeginCapMode = Line2D.LineCapMode.Round,\n            EndCapMode = Line2D.LineCapMode.Round,\n            TopLevel = true,\n            Position = Vector2.Zero,\n            ZIndex = -1 // Behind other elements\n        };\n\n        // Set up width curve - wider at start, tapers to narrower at end\n        var widthCurve = new Curve();\n        widthCurve.AddPoint(new Vector2(0.0f, 1.0f));\n        widthCurve.AddPoint(new Vector2(0.3f, 0.8f));\n        widthCurve.AddPoint(new Vector2(1.0f, 0.3f));\n        tracer.WidthCurve = widthCurve;\n\n        // Set up gradient - smoky white/gray that fades out\n        var gradient = new Gradient();\n        gradient.SetColor(0, new Color(0.9f, 0.9f, 0.85f, 0.8f));\n        gradient.AddPoint(0.5f, new Color(0.7f, 0.7f, 0.65f, 0.5f));\n        gradient.SetColor(gradient.GetPointCount() - 1, new Color(0.5f, 0.5f, 0.5f, 0.2f));\n        tracer.Gradient = gradient;\n\n        // Add the tracer line points (using global coordinates since TopLevel=true)\n        tracer.AddPoint(fromPosition + direction * BulletSpawnOffset);\n        tracer.AddPoint(endPosition);\n\n        // Add to scene\n        GetTree().CurrentScene.AddChild(tracer);\n\n        // Start the fade-out animation\n        FadeOutTracer(tracer);\n    }\n\n    /// <summary>\n    /// Animates the tracer trail fading out and dissipating over time.\n    /// The tracer gradually becomes more transparent and wider (simulating smoke dissipation).\n    /// </summary>\n    private async void FadeOutTracer(Line2D tracer)\n    {\n        float fadeDuration = 2.0f;\n        float elapsed = 0.0f;\n\n        float initialWidth = tracer.Width;\n\n        while (elapsed < fadeDuration && IsInstanceValid(tracer))\n        {\n            elapsed += (float)GetProcessDeltaTime();\n            float progress = elapsed / fadeDuration;\n\n            // Fade the alpha\n            float alpha = Mathf.Lerp(0.7f, 0.0f, progress);\n            tracer.DefaultColor = new Color(0.8f, 0.8f, 0.8f, alpha);\n\n            // Widen slightly to simulate smoke dissipation\n            tracer.Width = initialWidth + progress * 4.0f;\n\n            // Update gradient alpha\n            var gradient = new Gradient();\n            gradient.SetColor(0, new Color(0.9f, 0.9f, 0.85f, alpha));\n            gradient.AddPoint(0.5f, new Color(0.7f, 0.7f, 0.65f, alpha * 0.6f));\n            gradient.SetColor(gradient.GetPointCount() - 1, new Color(0.5f, 0.5f, 0.5f, alpha * 0.3f));\n            tracer.Gradient = gradient;\n\n            await ToSignal(GetTree(), \"process_frame\");\n        }\n\n        // Remove the tracer after fade completes\n        if (IsInstanceValid(tracer))\n        {\n            tracer.QueueFree();\n        }\n    }\n\n    // =========================================================================\n    // Sound and Effects\n    // =========================================================================\n\n    /// <summary>\n    /// Plays the sniper shot sound via AudioManager.\n    /// </summary>\n    private void PlaySniperShotSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        // Use M16 shot as a placeholder sound for the sniper\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_shot\"))\n        {\n            audioManager.Call(\"play_m16_shot\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Plays the empty gun click sound.\n    /// </summary>\n    private void PlayEmptyClickSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_empty_click\"))\n        {\n            audioManager.Call(\"play_empty_click\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Emits gunshot sound for enemy detection via SoundPropagation.\n    /// Very loud for the 12.7mm round.\n    /// </summary>\n    private void EmitGunshotSound()\n    {\n        var soundPropagation = GetNodeOrNull(\"/root/SoundPropagation\");\n        if (soundPropagation != null && soundPropagation.HasMethod(\"emit_sound\"))\n        {\n            float loudness = WeaponData?.Loudness ?? 3000.0f;\n            soundPropagation.Call(\"emit_sound\", 0, GlobalPosition, 0, this, loudness);\n        }\n    }\n\n    /// <summary>\n    /// Plays shell casing sound with a delay.\n    /// </summary>\n    private async void PlayShellCasingDelayed()\n    {\n        await ToSignal(GetTree().CreateTimer(0.2), \"timeout\");\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_shell_rifle\"))\n        {\n            audioManager.Call(\"play_shell_rifle\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Applies recoil to shooting direction.\n    /// </summary>\n    private Vector2 ApplyRecoil(Vector2 direction)\n    {\n        // Apply current recoil offset\n        Vector2 result = direction.Rotated(_recoilOffset);\n\n        // Add strong recoil for next shot (heavy 12.7mm kick)\n        float recoilDirection = (float)GD.RandRange(-1.0, 1.0);\n        _recoilOffset += recoilDirection * RecoilPerShot;\n        _recoilOffset = Mathf.Clamp(_recoilOffset, -MaxRecoilOffset, MaxRecoilOffset);\n\n        _timeSinceLastShot = 0;\n\n        return result;\n    }\n\n    /// <summary>\n    /// Triggers screen shake from sniper shot.\n    /// Heavy shake for 12.7mm round.\n    /// </summary>\n    private void TriggerScreenShake(Vector2 shootDirection)\n    {\n        if (WeaponData == null || WeaponData.ScreenShakeIntensity <= 0)\n        {\n            return;\n        }\n\n        var screenShakeManager = GetNodeOrNull(\"/root/ScreenShakeManager\");\n        if (screenShakeManager == null || !screenShakeManager.HasMethod(\"add_shake\"))\n        {\n            return;\n        }\n\n        // Heavy shake for sniper\n        float fireRate = WeaponData.FireRate;\n        float shakeIntensity;\n        if (fireRate > 0)\n        {\n            shakeIntensity = WeaponData.ScreenShakeIntensity / fireRate * 10.0f;\n        }\n        else\n        {\n            shakeIntensity = WeaponData.ScreenShakeIntensity;\n        }\n\n        float recoveryTime = WeaponData.ScreenShakeMinRecoveryTime;\n\n        screenShakeManager.Call(\"add_shake\", shootDirection, shakeIntensity, recoveryTime);\n    }\n\n    /// <summary>\n    /// Fires the bullet in the chamber during reload sequence.\n    /// </summary>\n    public override bool FireChamberBullet(Vector2 direction)\n    {\n        // Sniper rifle doesn't support chamber bullet during reload\n        // (bolt-action requires full cycle)\n        return false;\n    }\n\n    /// <summary>\n    /// Gets the current aim direction.\n    /// </summary>\n    public Vector2 AimDirection => _aimDirection;\n\n    /// <summary>\n    /// Gets the current bolt-action step.\n    /// </summary>\n    public BoltActionStep CurrentBoltStep => _boltStep;\n\n    /// <summary>\n    /// Resets the bolt to ready state (e.g., after reload with a new magazine).\n    /// </summary>\n    public void ResetBolt()\n    {\n        _boltStep = BoltActionStep.Ready;\n        EmitSignal(SignalName.BoltStepChanged, 4, 4);\n        GD.Print(\"[SniperRifle] Bolt reset to ready state\");\n    }\n\n    // =========================================================================\n    // Scope / Aiming System (RMB)\n    // =========================================================================\n\n    /// <summary>\n    /// Whether the scope is currently active (RMB held).\n    /// </summary>\n    private bool _isScopeActive = false;\n\n    /// <summary>\n    /// Whether the scope is active (read-only property for external access).\n    /// </summary>\n    public bool IsScopeActive => _isScopeActive;\n\n    /// <summary>\n    /// Signal emitted when scope state changes.\n    /// </summary>\n    [Signal]\n    public delegate void ScopeStateChangedEventHandler(bool isActive);\n\n    /// <summary>\n    /// Current scope zoom distance multiplier (how far beyond viewport the player can see).\n    /// 1.0 = one viewport distance, 2.0 = two viewport distances.\n    /// Controlled by mouse wheel while scoping.\n    /// </summary>\n    private float _scopeZoomDistance = 1.0f;\n\n    /// <summary>\n    /// Minimum scope zoom distance (viewport multiplier).\n    /// Set to 1.0 so the scope always looks beyond the normal viewport.\n    /// </summary>\n    private const float MinScopeZoomDistance = 1.0f;\n\n    /// <summary>\n    /// Maximum scope zoom distance (viewport multiplier).\n    /// </summary>\n    private const float MaxScopeZoomDistance = 3.0f;\n\n    /// <summary>\n    /// Step size for mouse wheel zoom adjustment.\n    /// </summary>\n    private const float ScopeZoomStep = 0.25f;\n\n    /// <summary>\n    /// Base sway amplitude in pixels at 1 viewport distance.\n    /// </summary>\n    private const float BaseScopeSwayAmplitude = 8.0f;\n\n    /// <summary>\n    /// Speed of the sway oscillation.\n    /// </summary>\n    private const float ScopeSwaySpeed = 2.5f;\n\n    /// <summary>\n    /// Current scope sway time accumulator.\n    /// </summary>\n    private float _scopeSwayTime = 0.0f;\n\n    /// <summary>\n    /// Current scope sway offset in pixels (applied to camera).\n    /// </summary>\n    private Vector2 _scopeSwayOffset = Vector2.Zero;\n\n    /// <summary>\n    /// Reference to the scope overlay CanvasLayer (created when scope activates).\n    /// </summary>\n    private CanvasLayer? _scopeOverlay = null;\n\n    /// <summary>\n    /// Reference to the scope crosshair control node.\n    /// </summary>\n    private Control? _scopeCrosshair = null;\n\n    /// <summary>\n    /// Reference to the scope darkening background.\n    /// </summary>\n    private ColorRect? _scopeBackground = null;\n\n    /// <summary>\n    /// Cached reference to the player's Camera2D node.\n    /// </summary>\n    private Camera2D? _playerCamera = null;\n\n    /// <summary>\n    /// Original camera offset before scoping (to restore on exit).\n    /// </summary>\n    private Vector2 _originalCameraOffset = Vector2.Zero;\n\n    /// <summary>\n    /// Gets the current camera offset for scope aiming.\n    /// Called by the player or level scripts to position the camera.\n    /// </summary>\n    public Vector2 GetScopeCameraOffset()\n    {\n        if (!_isScopeActive)\n        {\n            return Vector2.Zero;\n        }\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return Vector2.Zero;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float baseDistance = viewportSize.Length() * 0.5f;\n\n        // Camera offset = aim direction * zoom distance * viewport size + sway\n        Vector2 offset = _aimDirection * baseDistance * _scopeZoomDistance + _scopeSwayOffset;\n\n        return offset;\n    }\n\n    /// <summary>\n    /// Activates the scope (called when RMB is pressed).\n    /// </summary>\n    public void ActivateScope()\n    {\n        if (_isScopeActive)\n        {\n            return;\n        }\n\n        _isScopeActive = true;\n        _scopeSwayTime = 0.0f;\n\n        // Find and cache the player's Camera2D\n        FindPlayerCamera();\n\n        // Store original camera offset\n        if (_playerCamera != null)\n        {\n            _originalCameraOffset = _playerCamera.Offset;\n        }\n\n        // Create the scope overlay\n        CreateScopeOverlay();\n\n        EmitSignal(SignalName.ScopeStateChanged, true);\n        GD.Print($\"[SniperRifle] Scope activated. Zoom distance: {_scopeZoomDistance:F1}x\");\n    }\n\n    /// <summary>\n    /// Deactivates the scope (called when RMB is released).\n    /// </summary>\n    public void DeactivateScope()\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        _isScopeActive = false;\n\n        // Restore original camera offset\n        if (_playerCamera != null)\n        {\n            _playerCamera.Offset = _originalCameraOffset;\n        }\n\n        // Remove scope overlay\n        RemoveScopeOverlay();\n\n        EmitSignal(SignalName.ScopeStateChanged, false);\n        GD.Print(\"[SniperRifle] Scope deactivated.\");\n    }\n\n    /// <summary>\n    /// Adjusts the scope zoom distance (called on mouse wheel while scoping).\n    /// </summary>\n    public void AdjustScopeZoom(float direction)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        _scopeZoomDistance += direction * ScopeZoomStep;\n        _scopeZoomDistance = Mathf.Clamp(_scopeZoomDistance, MinScopeZoomDistance, MaxScopeZoomDistance);\n\n        GD.Print($\"[SniperRifle] Scope zoom adjusted: {_scopeZoomDistance:F2}x\");\n    }\n\n    /// <summary>\n    /// Finds the player's Camera2D node by traversing up to the parent (player).\n    /// </summary>\n    private void FindPlayerCamera()\n    {\n        if (_playerCamera != null)\n        {\n            return;\n        }\n\n        var parent = GetParent();\n        if (parent != null)\n        {\n            _playerCamera = parent.GetNodeOrNull<Camera2D>(\"Camera2D\");\n        }\n    }\n\n    /// <summary>\n    /// Updates the scope system each frame (called from _Process).\n    /// </summary>\n    private void UpdateScope(float delta)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        // Update sway\n        _scopeSwayTime += delta;\n        float swayAmplitude = BaseScopeSwayAmplitude * _scopeZoomDistance;\n\n        // Use two sine waves at different frequencies for natural-looking sway\n        float swayX = Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 1.0f) * swayAmplitude\n                    + Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 2.3f) * swayAmplitude * 0.3f;\n        float swayY = Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 1.4f) * swayAmplitude\n                    + Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 0.7f) * swayAmplitude * 0.4f;\n\n        _scopeSwayOffset = new Vector2(swayX, swayY);\n\n        // Update camera offset for scope view\n        if (_playerCamera != null)\n        {\n            _playerCamera.Offset = _originalCameraOffset + GetScopeCameraOffset();\n        }\n\n        // Update scope overlay crosshair position with sway\n        UpdateScopeOverlayPosition();\n    }\n\n    /// <summary>\n    /// Creates the scope overlay UI with crosshair and darkened edges.\n    /// </summary>\n    private void CreateScopeOverlay()\n    {\n        RemoveScopeOverlay();\n\n        _scopeOverlay = new CanvasLayer\n        {\n            Name = \"ScopeOverlay\",\n            Layer = 10\n        };\n\n        Viewport? viewport = GetViewport();\n        Vector2 viewportSize = viewport?.GetVisibleRect().Size ?? new Vector2(1280, 720);\n\n        // Dark background with circular cutout effect (vignette)\n        _scopeBackground = new ColorRect\n        {\n            Name = \"ScopeBackground\",\n            Color = new Color(0.0f, 0.0f, 0.0f, 0.5f),\n            Size = viewportSize,\n            Position = Vector2.Zero,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        _scopeOverlay.AddChild(_scopeBackground);\n\n        // Create the crosshair as a Control node\n        _scopeCrosshair = new Control\n        {\n            Name = \"ScopeCrosshair\",\n            Position = viewportSize / 2,\n            Size = Vector2.Zero,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        _scopeOverlay.AddChild(_scopeCrosshair);\n\n        // Add crosshair lines - based on the reference image from the issue\n        // The scope has a classic crosshair with circle and mil-dots\n\n        // Outer circle\n        float circleRadius = Mathf.Min(viewportSize.X, viewportSize.Y) * 0.35f;\n        int segments = 64;\n        var outerCircle = new Line2D\n        {\n            Name = \"OuterCircle\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f),\n            Antialiased = true\n        };\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            outerCircle.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * circleRadius);\n        }\n        _scopeCrosshair.AddChild(outerCircle);\n\n        // Inner thin circle\n        float innerRadius = circleRadius * 0.05f;\n        var innerCircle = new Line2D\n        {\n            Name = \"InnerCircle\",\n            Width = 1.5f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f),\n            Antialiased = true\n        };\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            innerCircle.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * innerRadius);\n        }\n        _scopeCrosshair.AddChild(innerCircle);\n\n        // Horizontal crosshair line (left)\n        var hLineLeft = new Line2D\n        {\n            Name = \"HLineLeft\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        hLineLeft.AddPoint(new Vector2(-circleRadius, 0));\n        hLineLeft.AddPoint(new Vector2(-innerRadius, 0));\n        _scopeCrosshair.AddChild(hLineLeft);\n\n        // Horizontal crosshair line (right)\n        var hLineRight = new Line2D\n        {\n            Name = \"HLineRight\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        hLineRight.AddPoint(new Vector2(innerRadius, 0));\n        hLineRight.AddPoint(new Vector2(circleRadius, 0));\n        _scopeCrosshair.AddChild(hLineRight);\n\n        // Vertical crosshair line (top)\n        var vLineTop = new Line2D\n        {\n            Name = \"VLineTop\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        vLineTop.AddPoint(new Vector2(0, -circleRadius));\n        vLineTop.AddPoint(new Vector2(0, -innerRadius));\n        _scopeCrosshair.AddChild(vLineTop);\n\n        // Vertical crosshair line (bottom) with mil-dots\n        var vLineBottom = new Line2D\n        {\n            Name = \"VLineBottom\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        vLineBottom.AddPoint(new Vector2(0, innerRadius));\n        vLineBottom.AddPoint(new Vector2(0, circleRadius));\n        _scopeCrosshair.AddChild(vLineBottom);\n\n        // Add mil-dot markers on the bottom crosshair (range estimation)\n        float dotSpacing = circleRadius * 0.15f;\n        for (int i = 1; i <= 4; i++)\n        {\n            float dotY = dotSpacing * i;\n            var dot = new Line2D\n            {\n                Name = $\"MilDot_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            float dotWidth = 4.0f - i * 0.5f; // Dots get smaller further from center\n            dot.AddPoint(new Vector2(-dotWidth, dotY));\n            dot.AddPoint(new Vector2(dotWidth, dotY));\n            _scopeCrosshair.AddChild(dot);\n        }\n\n        // Add mil-dot markers on horizontal lines\n        for (int i = 1; i <= 3; i++)\n        {\n            float dotX = dotSpacing * i;\n            // Right side dots\n            var dotRight = new Line2D\n            {\n                Name = $\"HMilDotRight_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            float dotHeight = 4.0f - i * 0.5f;\n            dotRight.AddPoint(new Vector2(dotX, -dotHeight));\n            dotRight.AddPoint(new Vector2(dotX, dotHeight));\n            _scopeCrosshair.AddChild(dotRight);\n\n            // Left side dots\n            var dotLeft = new Line2D\n            {\n                Name = $\"HMilDotLeft_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            dotLeft.AddPoint(new Vector2(-dotX, -dotHeight));\n            dotLeft.AddPoint(new Vector2(-dotX, dotHeight));\n            _scopeCrosshair.AddChild(dotLeft);\n        }\n\n        // Add thick outer ring to mask edges (simulate scope tube)\n        var scopeRing = new Line2D\n        {\n            Name = \"ScopeRing\",\n            Width = 6.0f,\n            DefaultColor = new Color(0.1f, 0.1f, 0.1f, 0.95f),\n            Antialiased = true\n        };\n        float ringRadius = circleRadius + 3.0f;\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            scopeRing.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * ringRadius);\n        }\n        _scopeCrosshair.AddChild(scopeRing);\n\n        // Zoom distance indicator text\n        var zoomLabel = new Label\n        {\n            Name = \"ZoomLabel\",\n            Position = new Vector2(circleRadius * 0.5f, circleRadius * 0.7f),\n            Text = $\"{_scopeZoomDistance:F1}x\",\n            HorizontalAlignment = HorizontalAlignment.Center,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        zoomLabel.AddThemeColorOverride(\"font_color\", new Color(0.0f, 0.0f, 0.0f, 0.6f));\n        zoomLabel.AddThemeFontSizeOverride(\"font_size\", 12);\n        _scopeCrosshair.AddChild(zoomLabel);\n\n        GetTree().CurrentScene.AddChild(_scopeOverlay);\n    }\n\n    /// <summary>\n    /// Updates the scope overlay crosshair position with sway applied.\n    /// </summary>\n    private void UpdateScopeOverlayPosition()\n    {\n        if (_scopeCrosshair == null || _scopeOverlay == null)\n        {\n            return;\n        }\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n\n        // Crosshair stays centered but sways\n        _scopeCrosshair.Position = viewportSize / 2 + _scopeSwayOffset;\n\n        // Update zoom label\n        var zoomLabel = _scopeCrosshair.GetNodeOrNull<Label>(\"ZoomLabel\");\n        if (zoomLabel != null)\n        {\n            zoomLabel.Text = $\"{_scopeZoomDistance:F1}x\";\n        }\n    }\n\n    /// <summary>\n    /// Removes the scope overlay from the scene.\n    /// </summary>\n    private void RemoveScopeOverlay()\n    {\n        if (_scopeOverlay != null && IsInstanceValid(_scopeOverlay))\n        {\n            _scopeOverlay.QueueFree();\n            _scopeOverlay = null;\n            _scopeCrosshair = null;\n            _scopeBackground = null;\n        }\n    }\n}\n",
    "structuredPatch": [
      {
        "oldStart": 949,
        "oldLines": 6,
        "newStart": 949,
        "newLines": 19,
        "lines": [
          "     private const float ScopeSwaySpeed = 2.5f;",
          " ",
          "     /// <summary>",
          "+    /// Maximum range (in viewport fraction) that the player can fine-tune the scope",
          "+    /// distance via mouse movement while scoped. About 1/3 of the viewport.",
          "+    /// </summary>",
          "+    private const float ScopeMouseFineTuneRange = 0.33f;",
          "+",
          "+    /// <summary>",
          "+    /// Current mouse fine-tune offset applied to scope distance.",
          "+    /// Ranges from -ScopeMouseFineTuneRange to +ScopeMouseFineTuneRange (viewport fraction).",
          "+    /// Positive = further, negative = closer.",
          "+    /// </summary>",
          "+    private float _scopeMouseFineTuneOffset = 0.0f;",
          "+",
          "+    /// <summary>",
          "     /// Current scope sway time accumulator.",
          "     /// </summary>",
          "     private float _scopeSwayTime = 0.0f;"
        ]
      }
    ],
    "userModified": false,
    "replaceAll": false
  }
}
[2026-02-06T20:57:15.344Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01CBDKpFcfisKRXs1PTgPPw8",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now update `GetScopeCameraOffset` to include the mouse fine-tune offset:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 479,
      "cache_read_input_tokens": 59051,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 479
      },
      "output_tokens": 2,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "76c53736-7feb-4b26-b059-cc79728c72c5"
}
[2026-02-06T20:57:24.793Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01CBDKpFcfisKRXs1PTgPPw8",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_012PGJSd465Py4vA1aFTkZbC",
        "name": "Edit",
        "input": {
          "replace_all": false,
          "file_path": "/tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs",
          "old_string": "    /// <summary>\n    /// Gets the current camera offset for scope aiming.\n    /// Called by the player or level scripts to position the camera.\n    /// </summary>\n    public Vector2 GetScopeCameraOffset()\n    {\n        if (!_isScopeActive)\n        {\n            return Vector2.Zero;\n        }\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return Vector2.Zero;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float baseDistance = viewportSize.Length() * 0.5f;\n\n        // Camera offset = aim direction * zoom distance * viewport size + sway\n        Vector2 offset = _aimDirection * baseDistance * _scopeZoomDistance + _scopeSwayOffset;\n\n        return offset;\n    }",
          "new_string": "    /// <summary>\n    /// Gets the effective scope zoom distance including mouse fine-tune offset.\n    /// </summary>\n    private float EffectiveScopeZoomDistance => _scopeZoomDistance + _scopeMouseFineTuneOffset;\n\n    /// <summary>\n    /// Gets the current camera offset for scope aiming.\n    /// Called by the player or level scripts to position the camera.\n    /// </summary>\n    public Vector2 GetScopeCameraOffset()\n    {\n        if (!_isScopeActive)\n        {\n            return Vector2.Zero;\n        }\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return Vector2.Zero;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float baseDistance = viewportSize.Length() * 0.5f;\n\n        // Camera offset = aim direction * (zoom distance + mouse fine-tune) * viewport size + sway\n        Vector2 offset = _aimDirection * baseDistance * EffectiveScopeZoomDistance + _scopeSwayOffset;\n\n        return offset;\n    }\n\n    /// <summary>\n    /// Gets the world-space position that the scope crosshair center is aiming at.\n    /// Used to direct bullets to the crosshair center.\n    /// </summary>\n    public Vector2 GetScopeAimTarget()\n    {\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return GlobalPosition + _aimDirection * 1000.0f;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float baseDistance = viewportSize.Length() * 0.5f;\n\n        // The scope aim target is the player's position offset by the scope camera offset\n        // (without sway, so bullets go to the true center, not the swaying crosshair)\n        Vector2 aimTarget = GlobalPosition + _aimDirection * baseDistance * EffectiveScopeZoomDistance;\n\n        return aimTarget;\n    }"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 479,
      "cache_read_input_tokens": 59051,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 479
      },
      "output_tokens": 2,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "b7bd6fc6-0c2d-4ef3-8ad4-adafa8d0754b"
}
[2026-02-06T20:57:24.805Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_012PGJSd465Py4vA1aFTkZbC",
        "type": "tool_result",
        "content": "The file /tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs has been updated successfully."
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "284e0042-7821-4e38-a1a0-4cea10bb70fc",
  "tool_use_result": {
    "filePath": "/tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs",
    "oldString": "    /// <summary>\n    /// Gets the current camera offset for scope aiming.\n    /// Called by the player or level scripts to position the camera.\n    /// </summary>\n    public Vector2 GetScopeCameraOffset()\n    {\n        if (!_isScopeActive)\n        {\n            return Vector2.Zero;\n        }\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return Vector2.Zero;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float baseDistance = viewportSize.Length() * 0.5f;\n\n        // Camera offset = aim direction * zoom distance * viewport size + sway\n        Vector2 offset = _aimDirection * baseDistance * _scopeZoomDistance + _scopeSwayOffset;\n\n        return offset;\n    }",
    "newString": "    /// <summary>\n    /// Gets the effective scope zoom distance including mouse fine-tune offset.\n    /// </summary>\n    private float EffectiveScopeZoomDistance => _scopeZoomDistance + _scopeMouseFineTuneOffset;\n\n    /// <summary>\n    /// Gets the current camera offset for scope aiming.\n    /// Called by the player or level scripts to position the camera.\n    /// </summary>\n    public Vector2 GetScopeCameraOffset()\n    {\n        if (!_isScopeActive)\n        {\n            return Vector2.Zero;\n        }\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return Vector2.Zero;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float baseDistance = viewportSize.Length() * 0.5f;\n\n        // Camera offset = aim direction * (zoom distance + mouse fine-tune) * viewport size + sway\n        Vector2 offset = _aimDirection * baseDistance * EffectiveScopeZoomDistance + _scopeSwayOffset;\n\n        return offset;\n    }\n\n    /// <summary>\n    /// Gets the world-space position that the scope crosshair center is aiming at.\n    /// Used to direct bullets to the crosshair center.\n    /// </summary>\n    public Vector2 GetScopeAimTarget()\n    {\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return GlobalPosition + _aimDirection * 1000.0f;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float baseDistance = viewportSize.Length() * 0.5f;\n\n        // The scope aim target is the player's position offset by the scope camera offset\n        // (without sway, so bullets go to the true center, not the swaying crosshair)\n        Vector2 aimTarget = GlobalPosition + _aimDirection * baseDistance * EffectiveScopeZoomDistance;\n\n        return aimTarget;\n    }",
    "originalFile": "using Godot;\nusing GodotTopDownTemplate.AbstractClasses;\nusing GodotTopDownTemplate.Projectiles;\n\nnamespace GodotTopDownTemplate.Weapons;\n\n/// <summary>\n/// Bolt-action charging state for the ASVK sniper rifle.\n/// Before each shot, the player must complete a 4-step bolt-action sequence:\n/// Down (pull bolt back) ‚Üí Left (open bolt) ‚Üí Down (close bolt) ‚Üí Up (chamber round)\n/// </summary>\npublic enum BoltActionStep\n{\n    /// <summary>\n    /// Bolt is ready - weapon can fire. After firing, transitions to NeedsBoltCycle.\n    /// </summary>\n    Ready,\n\n    /// <summary>\n    /// Just fired - needs bolt cycling before next shot.\n    /// Waiting for Down arrow (pull bolt back).\n    /// </summary>\n    NeedsBoltCycle,\n\n    /// <summary>\n    /// Step 1 complete (bolt pulled back). Waiting for Left arrow (open bolt).\n    /// </summary>\n    WaitOpenBolt,\n\n    /// <summary>\n    /// Step 2 complete (bolt opened). Waiting for Down arrow (close bolt).\n    /// </summary>\n    WaitCloseBolt,\n\n    /// <summary>\n    /// Step 3 complete (bolt closed). Waiting for Up arrow (chamber round).\n    /// </summary>\n    WaitChamberRound\n}\n\n/// <summary>\n/// ASVK sniper rifle - heavy anti-materiel bolt-action rifle.\n/// Features:\n/// - 12.7x108mm ammunition dealing 50 damage per shot\n/// - Penetrates through 2 walls and through enemies\n/// - Instant bullet speed with smoky dissipating tracer trail\n/// - Very high turn sensitivity\n/// - 5-round magazine with M16-style swap reload\n/// - Single-shot bolt-action with manual charging sequence (Down‚ÜíLeft‚ÜíDown‚ÜíUp)\n/// - Red laser sight for aiming\n/// Reference: ASVK (–ê–°–í–ö) anti-materiel sniper rifle\n/// </summary>\npublic partial class SniperRifle : BaseWeapon\n{\n    // =========================================================================\n    // Bolt-Action State\n    // =========================================================================\n\n    /// <summary>\n    /// Current bolt-action charging step.\n    /// </summary>\n    private BoltActionStep _boltStep = BoltActionStep.Ready;\n\n    /// <summary>\n    /// Whether the bolt action is ready to fire (chambered).\n    /// Initially true so first shot can be fired immediately.\n    /// </summary>\n    public bool IsBoltReady => _boltStep == BoltActionStep.Ready;\n\n    /// <summary>\n    /// Whether the weapon needs bolt cycling before it can fire again.\n    /// </summary>\n    public bool NeedsBoltCycle => _boltStep != BoltActionStep.Ready;\n\n    /// <summary>\n    /// Signal emitted when bolt-action step changes.\n    /// </summary>\n    [Signal]\n    public delegate void BoltStepChangedEventHandler(int step, int totalSteps);\n\n    // =========================================================================\n    // Smoky Tracer Trail\n    // =========================================================================\n\n    /// <summary>\n    /// Scene for the smoky tracer trail effect.\n    /// Created programmatically as a Line2D with smoke-like appearance.\n    /// </summary>\n    private Line2D? _lastTracerTrail;\n\n    // =========================================================================\n    // Laser Sight Configuration\n    // =========================================================================\n\n    /// <summary>\n    /// Whether the laser sight is enabled.\n    /// </summary>\n    [Export]\n    public bool LaserSightEnabled { get; set; } = true;\n\n    /// <summary>\n    /// Maximum length of the laser sight in pixels.\n    /// </summary>\n    [Export]\n    public float LaserSightLength { get; set; } = 500.0f;\n\n    /// <summary>\n    /// Color of the laser sight (red for sniper).\n    /// </summary>\n    [Export]\n    public Color LaserSightColor { get; set; } = new Color(1.0f, 0.0f, 0.0f, 0.5f);\n\n    /// <summary>\n    /// Width of the laser sight line.\n    /// </summary>\n    [Export]\n    public float LaserSightWidth { get; set; } = 2.0f;\n\n    /// <summary>\n    /// Reference to the Line2D node for the laser sight.\n    /// </summary>\n    private Line2D? _laserSight;\n\n    /// <summary>\n    /// Reference to the Sprite2D node for the rifle visual.\n    /// </summary>\n    private Sprite2D? _rifleSprite;\n\n    /// <summary>\n    /// Current aim direction based on laser sight.\n    /// </summary>\n    private Vector2 _aimDirection = Vector2.Right;\n\n    /// <summary>\n    /// Current aim angle in radians.\n    /// </summary>\n    private float _currentAimAngle = 0.0f;\n\n    /// <summary>\n    /// Whether the aim angle has been initialized.\n    /// </summary>\n    private bool _aimAngleInitialized = false;\n\n    /// <summary>\n    /// Current recoil offset angle in radians.\n    /// Heavy sniper recoil.\n    /// </summary>\n    private float _recoilOffset = 0.0f;\n\n    /// <summary>\n    /// Time since the last shot was fired, used for recoil recovery.\n    /// </summary>\n    private float _timeSinceLastShot = 0.0f;\n\n    /// <summary>\n    /// Time in seconds before recoil starts recovering.\n    /// Long delay for heavy sniper.\n    /// </summary>\n    private const float RecoilRecoveryDelay = 0.5f;\n\n    /// <summary>\n    /// Speed at which recoil recovers (radians per second).\n    /// </summary>\n    private const float RecoilRecoverySpeed = 3.0f;\n\n    /// <summary>\n    /// Maximum recoil offset in radians (about 15 degrees).\n    /// </summary>\n    private const float MaxRecoilOffset = 0.26f;\n\n    /// <summary>\n    /// Recoil amount per shot in radians.\n    /// Heavy kick for 12.7mm.\n    /// </summary>\n    private const float RecoilPerShot = 0.15f;\n\n    /// <summary>\n    /// Number of walls this bullet can penetrate through.\n    /// The bullet continues flying after penetrating walls.\n    /// </summary>\n    private const int MaxWallPenetrations = 2;\n\n    public override void _Ready()\n    {\n        base._Ready();\n\n        // Get the rifle sprite for visual representation\n        _rifleSprite = GetNodeOrNull<Sprite2D>(\"RifleSprite\");\n\n        if (_rifleSprite != null)\n        {\n            var texture = _rifleSprite.Texture;\n            GD.Print($\"[SniperRifle] RifleSprite found: visible={_rifleSprite.Visible}, z_index={_rifleSprite.ZIndex}, texture={(texture != null ? \"loaded\" : \"NULL\")}\");\n        }\n        else\n        {\n            GD.PrintErr(\"[SniperRifle] WARNING: RifleSprite node not found!\");\n        }\n\n        // Check for Power Fantasy mode blue laser\n        var difficultyManager = GetNodeOrNull(\"/root/DifficultyManager\");\n        if (difficultyManager != null)\n        {\n            var shouldForceBlueLaser = difficultyManager.Call(\"should_force_blue_laser_sight\");\n            if (shouldForceBlueLaser.AsBool())\n            {\n                var blueColorVariant = difficultyManager.Call(\"get_power_fantasy_laser_color\");\n                LaserSightColor = blueColorVariant.AsColor();\n                GD.Print($\"[SniperRifle] Power Fantasy mode: laser color set to blue {LaserSightColor}\");\n            }\n        }\n\n        // Get or create the laser sight Line2D\n        _laserSight = GetNodeOrNull<Line2D>(\"LaserSight\");\n\n        if (_laserSight == null && LaserSightEnabled)\n        {\n            CreateLaserSight();\n        }\n        else if (_laserSight != null)\n        {\n            _laserSight.Width = LaserSightWidth;\n            _laserSight.DefaultColor = LaserSightColor;\n            _laserSight.BeginCapMode = Line2D.LineCapMode.Round;\n            _laserSight.EndCapMode = Line2D.LineCapMode.Round;\n\n            if (_laserSight.GetPointCount() < 2)\n            {\n                _laserSight.ClearPoints();\n                _laserSight.AddPoint(Vector2.Zero);\n                _laserSight.AddPoint(Vector2.Right * LaserSightLength);\n            }\n        }\n\n        UpdateLaserSightVisibility();\n        GD.Print(\"[SniperRifle] ASVK initialized - bolt ready, laser sight enabled\");\n    }\n\n    public override void _ExitTree()\n    {\n        // Clean up scope overlay when weapon is removed from scene tree\n        if (_isScopeActive)\n        {\n            DeactivateScope();\n        }\n        base._ExitTree();\n    }\n\n    public override void _Process(double delta)\n    {\n        base._Process(delta);\n\n        // Update time since last shot for recoil recovery\n        _timeSinceLastShot += (float)delta;\n\n        // Recover recoil after delay\n        if (_timeSinceLastShot >= RecoilRecoveryDelay && _recoilOffset != 0)\n        {\n            float recoveryAmount = RecoilRecoverySpeed * (float)delta;\n            _recoilOffset = Mathf.MoveToward(_recoilOffset, 0, recoveryAmount);\n        }\n\n        // Always update aim direction and rifle sprite rotation\n        UpdateAimDirection();\n\n        // Update laser sight to point towards mouse (with recoil offset)\n        if (LaserSightEnabled && _laserSight != null)\n        {\n            UpdateLaserSight();\n        }\n\n        // Handle bolt-action input\n        HandleBoltActionInput();\n\n        // Update scope system (sway, camera offset, overlay)\n        UpdateScope((float)delta);\n    }\n\n    // =========================================================================\n    // Bolt-Action Charging Mechanics\n    // =========================================================================\n\n    /// <summary>\n    /// Handles the bolt-action charging input sequence.\n    /// Sequence: Down (pull bolt) ‚Üí Left (open bolt) ‚Üí Down (close bolt) ‚Üí Up (chamber round)\n    /// Uses the arrow keys / WASD movement input actions.\n    /// </summary>\n    private void HandleBoltActionInput()\n    {\n        switch (_boltStep)\n        {\n            case BoltActionStep.NeedsBoltCycle:\n                // Step 1: Down arrow - pull bolt back\n                if (Input.IsActionJustPressed(\"move_down\"))\n                {\n                    _boltStep = BoltActionStep.WaitOpenBolt;\n                    EmitSignal(SignalName.BoltStepChanged, 1, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 1/4: Bolt pulled back\");\n                }\n                break;\n\n            case BoltActionStep.WaitOpenBolt:\n                // Step 2: Left arrow - open bolt\n                if (Input.IsActionJustPressed(\"move_left\"))\n                {\n                    _boltStep = BoltActionStep.WaitCloseBolt;\n                    EmitSignal(SignalName.BoltStepChanged, 2, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 2/4: Bolt opened\");\n                }\n                break;\n\n            case BoltActionStep.WaitCloseBolt:\n                // Step 3: Down arrow - close bolt\n                if (Input.IsActionJustPressed(\"move_down\"))\n                {\n                    _boltStep = BoltActionStep.WaitChamberRound;\n                    EmitSignal(SignalName.BoltStepChanged, 3, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 3/4: Bolt closed\");\n                }\n                break;\n\n            case BoltActionStep.WaitChamberRound:\n                // Step 4: Up arrow - chamber round\n                if (Input.IsActionJustPressed(\"move_up\"))\n                {\n                    _boltStep = BoltActionStep.Ready;\n                    EmitSignal(SignalName.BoltStepChanged, 4, 4);\n                    PlayBoltChamberSound();\n                    GD.Print(\"[SniperRifle] Bolt step 4/4: Round chambered - READY TO FIRE\");\n                }\n                break;\n\n            case BoltActionStep.Ready:\n                // Already ready, no bolt action needed\n                break;\n        }\n    }\n\n    /// <summary>\n    /// Plays the bolt manipulation sound.\n    /// </summary>\n    private void PlayBoltSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_bolt\"))\n        {\n            audioManager.Call(\"play_m16_bolt\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Plays the bolt chamber/ready sound.\n    /// </summary>\n    private void PlayBoltChamberSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_bolt\"))\n        {\n            audioManager.Call(\"play_m16_bolt\", GlobalPosition);\n        }\n    }\n\n    // =========================================================================\n    // Aiming and Laser Sight\n    // =========================================================================\n\n    /// <summary>\n    /// Updates the aim direction and rifle sprite rotation.\n    /// </summary>\n    private void UpdateAimDirection()\n    {\n        Vector2 mousePos = GetGlobalMousePosition();\n        Vector2 toMouse = mousePos - GlobalPosition;\n        float targetAngle = toMouse.Angle();\n\n        if (!_aimAngleInitialized)\n        {\n            _currentAimAngle = targetAngle;\n            _aimAngleInitialized = true;\n        }\n\n        Vector2 direction;\n\n        // Apply sensitivity for the sniper rifle\n        if (WeaponData != null && WeaponData.Sensitivity > 0)\n        {\n            float angleDiff = Mathf.Wrap(targetAngle - _currentAimAngle, -Mathf.Pi, Mathf.Pi);\n            float rotationSpeed = WeaponData.Sensitivity * 10.0f;\n            float delta = (float)GetProcessDeltaTime();\n            float maxRotation = rotationSpeed * delta;\n            float actualRotation = Mathf.Clamp(angleDiff, -maxRotation, maxRotation);\n            _currentAimAngle += actualRotation;\n            direction = new Vector2(Mathf.Cos(_currentAimAngle), Mathf.Sin(_currentAimAngle));\n        }\n        else\n        {\n            if (toMouse.LengthSquared() > 0.001f)\n            {\n                direction = toMouse.Normalized();\n                _currentAimAngle = targetAngle;\n            }\n            else\n            {\n                direction = _aimDirection;\n            }\n        }\n\n        _aimDirection = direction;\n        UpdateRifleSpriteRotation(direction);\n    }\n\n    /// <summary>\n    /// Creates the laser sight Line2D programmatically.\n    /// </summary>\n    private void CreateLaserSight()\n    {\n        _laserSight = new Line2D\n        {\n            Name = \"LaserSight\",\n            Width = LaserSightWidth,\n            DefaultColor = LaserSightColor,\n            BeginCapMode = Line2D.LineCapMode.Round,\n            EndCapMode = Line2D.LineCapMode.Round\n        };\n\n        _laserSight.AddPoint(Vector2.Zero);\n        _laserSight.AddPoint(Vector2.Right * LaserSightLength);\n\n        AddChild(_laserSight);\n    }\n\n    /// <summary>\n    /// Updates the laser sight visualization with recoil offset.\n    /// Uses raycasting to stop at obstacles.\n    /// </summary>\n    private void UpdateLaserSight()\n    {\n        if (_laserSight == null)\n        {\n            return;\n        }\n\n        Vector2 laserDirection = _aimDirection.Rotated(_recoilOffset);\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float maxLaserLength = viewportSize.Length();\n\n        Vector2 endPoint = laserDirection * maxLaserLength;\n\n        var spaceState = GetWorld2D().DirectSpaceState;\n        var query = PhysicsRayQueryParameters2D.Create(\n            GlobalPosition,\n            GlobalPosition + endPoint,\n            4 // Collision mask for obstacles (layer 3 = value 4)\n        );\n\n        var result = spaceState.IntersectRay(query);\n\n        if (result.Count > 0)\n        {\n            Vector2 hitPosition = (Vector2)result[\"position\"];\n            endPoint = hitPosition - GlobalPosition;\n        }\n\n        _laserSight.SetPointPosition(0, Vector2.Zero);\n        _laserSight.SetPointPosition(1, endPoint);\n    }\n\n    /// <summary>\n    /// Updates the visibility of the laser sight.\n    /// </summary>\n    private void UpdateLaserSightVisibility()\n    {\n        if (_laserSight != null)\n        {\n            _laserSight.Visible = LaserSightEnabled;\n        }\n    }\n\n    /// <summary>\n    /// Updates the rifle sprite rotation to match aim direction.\n    /// </summary>\n    private void UpdateRifleSpriteRotation(Vector2 direction)\n    {\n        if (_rifleSprite == null)\n        {\n            return;\n        }\n\n        float angle = direction.Angle();\n        _rifleSprite.Rotation = angle;\n\n        bool aimingLeft = Mathf.Abs(angle) > Mathf.Pi / 2;\n        _rifleSprite.FlipV = aimingLeft;\n    }\n\n    /// <summary>\n    /// Enables or disables the laser sight.\n    /// </summary>\n    public void SetLaserSightEnabled(bool enabled)\n    {\n        LaserSightEnabled = enabled;\n        UpdateLaserSightVisibility();\n    }\n\n    // =========================================================================\n    // Firing\n    // =========================================================================\n\n    /// <summary>\n    /// Fires the sniper rifle. Only fires if bolt is ready.\n    /// After firing, transitions to NeedsBoltCycle state.\n    /// </summary>\n    public override bool Fire(Vector2 direction)\n    {\n        // Check for empty magazine\n        if (CurrentAmmo <= 0)\n        {\n            PlayEmptyClickSound();\n            return false;\n        }\n\n        // Check if bolt is ready\n        if (!IsBoltReady)\n        {\n            // Play a click to indicate bolt not cycled\n            PlayEmptyClickSound();\n            return false;\n        }\n\n        // Check standard fire conditions\n        if (!CanFire || WeaponData == null || BulletScene == null)\n        {\n            return false;\n        }\n\n        // Apply recoil to aim direction\n        Vector2 spreadDirection = ApplyRecoil(_aimDirection);\n        bool result = base.Fire(spreadDirection);\n\n        if (result)\n        {\n            // Transition to needs bolt cycle\n            _boltStep = BoltActionStep.NeedsBoltCycle;\n            EmitSignal(SignalName.BoltStepChanged, 0, 4);\n\n            // Play sniper shot sound\n            PlaySniperShotSound();\n            // Emit gunshot sound for enemy detection\n            EmitGunshotSound();\n            // Play shell casing with delay\n            PlayShellCasingDelayed();\n            // Trigger heavy screen shake\n            TriggerScreenShake(spreadDirection);\n\n            // Spawn smoky tracer trail\n            SpawnSmokyTracer(GlobalPosition, spreadDirection);\n\n            GD.Print(\"[SniperRifle] FIRED! Bolt needs cycling. Ammo remaining: \" + CurrentAmmo);\n        }\n\n        return result;\n    }\n\n    /// <summary>\n    /// Override SpawnBullet to configure the SniperBullet for sniper behavior:\n    /// - Very high damage (50)\n    /// - Passes through enemies (doesn't destroy on hit)\n    /// - Penetrates through 2 walls (wall-count based, not distance-based)\n    /// </summary>\n    protected override void SpawnBullet(Vector2 direction)\n    {\n        if (BulletScene == null)\n        {\n            return;\n        }\n\n        // Check bullet spawn path\n        var (isBlocked, hitPosition, hitNormal) = CheckBulletSpawnPath(direction);\n\n        Vector2 spawnPosition;\n        if (isBlocked)\n        {\n            spawnPosition = GlobalPosition + direction * 2.0f;\n            GD.Print(\"[SniperRifle] Point-blank shot: spawning for penetration\");\n        }\n        else\n        {\n            spawnPosition = GlobalPosition + direction * BulletSpawnOffset;\n        }\n\n        var bulletNode = BulletScene.Instantiate<Node2D>();\n        bulletNode.GlobalPosition = spawnPosition;\n\n        // Try to cast to C# SniperBullet for direct property access\n        var sniperBullet = bulletNode as SniperBullet;\n\n        if (sniperBullet != null)\n        {\n            // SniperBullet - set properties directly\n            sniperBullet.Direction = direction;\n            if (WeaponData != null)\n            {\n                sniperBullet.Speed = WeaponData.BulletSpeed;\n                sniperBullet.Damage = WeaponData.Damage;\n            }\n            var owner = GetParent();\n            if (owner != null)\n            {\n                sniperBullet.ShooterId = owner.GetInstanceId();\n            }\n            sniperBullet.ShooterPosition = GlobalPosition;\n            sniperBullet.MaxWallPenetrations = MaxWallPenetrations;\n            GD.Print($\"[SniperRifle] Spawned SniperBullet: Damage={sniperBullet.Damage}, Speed={sniperBullet.Speed}, MaxWallPen={MaxWallPenetrations}\");\n        }\n        else\n        {\n            // Fallback for any bullet type\n            if (bulletNode.HasMethod(\"SetDirection\"))\n            {\n                bulletNode.Call(\"SetDirection\", direction);\n            }\n            else\n            {\n                bulletNode.Set(\"Direction\", direction);\n                bulletNode.Set(\"direction\", direction);\n            }\n\n            if (WeaponData != null)\n            {\n                bulletNode.Set(\"Speed\", WeaponData.BulletSpeed);\n                bulletNode.Set(\"speed\", WeaponData.BulletSpeed);\n                bulletNode.Set(\"Damage\", WeaponData.Damage);\n                bulletNode.Set(\"damage\", WeaponData.Damage);\n            }\n\n            var owner = GetParent();\n            if (owner != null)\n            {\n                bulletNode.Set(\"ShooterId\", owner.GetInstanceId());\n                bulletNode.Set(\"shooter_id\", owner.GetInstanceId());\n            }\n\n            bulletNode.Set(\"ShooterPosition\", GlobalPosition);\n            bulletNode.Set(\"shooter_position\", GlobalPosition);\n        }\n\n        GetTree().CurrentScene.AddChild(bulletNode);\n\n        // Spawn muzzle flash effect - large flash for 12.7mm\n        SpawnMuzzleFlash(spawnPosition, direction, WeaponData?.Caliber);\n\n        // Spawn casing\n        SpawnCasing(direction, WeaponData?.Caliber);\n    }\n\n    // =========================================================================\n    // Smoky Tracer Trail\n    // =========================================================================\n\n    /// <summary>\n    /// Spawns a smoky dissipating tracer trail from the fire position\n    /// in the shooting direction across the entire map.\n    /// The tracer is an instant visual effect (like a contrail from a plane)\n    /// that fades out over time.\n    /// </summary>\n    private void SpawnSmokyTracer(Vector2 fromPosition, Vector2 direction)\n    {\n        // Calculate tracer end point - extend to edge of map (very far)\n        float tracerLength = 5000.0f; // Far enough to reach any map edge\n        Vector2 endPosition = fromPosition + direction * tracerLength;\n\n        // Create the tracer as a Line2D with smoke-like appearance\n        var tracer = new Line2D\n        {\n            Name = \"SniperTracer\",\n            Width = 6.0f,\n            DefaultColor = new Color(0.8f, 0.8f, 0.8f, 0.7f),\n            BeginCapMode = Line2D.LineCapMode.Round,\n            EndCapMode = Line2D.LineCapMode.Round,\n            TopLevel = true,\n            Position = Vector2.Zero,\n            ZIndex = -1 // Behind other elements\n        };\n\n        // Set up width curve - wider at start, tapers to narrower at end\n        var widthCurve = new Curve();\n        widthCurve.AddPoint(new Vector2(0.0f, 1.0f));\n        widthCurve.AddPoint(new Vector2(0.3f, 0.8f));\n        widthCurve.AddPoint(new Vector2(1.0f, 0.3f));\n        tracer.WidthCurve = widthCurve;\n\n        // Set up gradient - smoky white/gray that fades out\n        var gradient = new Gradient();\n        gradient.SetColor(0, new Color(0.9f, 0.9f, 0.85f, 0.8f));\n        gradient.AddPoint(0.5f, new Color(0.7f, 0.7f, 0.65f, 0.5f));\n        gradient.SetColor(gradient.GetPointCount() - 1, new Color(0.5f, 0.5f, 0.5f, 0.2f));\n        tracer.Gradient = gradient;\n\n        // Add the tracer line points (using global coordinates since TopLevel=true)\n        tracer.AddPoint(fromPosition + direction * BulletSpawnOffset);\n        tracer.AddPoint(endPosition);\n\n        // Add to scene\n        GetTree().CurrentScene.AddChild(tracer);\n\n        // Start the fade-out animation\n        FadeOutTracer(tracer);\n    }\n\n    /// <summary>\n    /// Animates the tracer trail fading out and dissipating over time.\n    /// The tracer gradually becomes more transparent and wider (simulating smoke dissipation).\n    /// </summary>\n    private async void FadeOutTracer(Line2D tracer)\n    {\n        float fadeDuration = 2.0f;\n        float elapsed = 0.0f;\n\n        float initialWidth = tracer.Width;\n\n        while (elapsed < fadeDuration && IsInstanceValid(tracer))\n        {\n            elapsed += (float)GetProcessDeltaTime();\n            float progress = elapsed / fadeDuration;\n\n            // Fade the alpha\n            float alpha = Mathf.Lerp(0.7f, 0.0f, progress);\n            tracer.DefaultColor = new Color(0.8f, 0.8f, 0.8f, alpha);\n\n            // Widen slightly to simulate smoke dissipation\n            tracer.Width = initialWidth + progress * 4.0f;\n\n            // Update gradient alpha\n            var gradient = new Gradient();\n            gradient.SetColor(0, new Color(0.9f, 0.9f, 0.85f, alpha));\n            gradient.AddPoint(0.5f, new Color(0.7f, 0.7f, 0.65f, alpha * 0.6f));\n            gradient.SetColor(gradient.GetPointCount() - 1, new Color(0.5f, 0.5f, 0.5f, alpha * 0.3f));\n            tracer.Gradient = gradient;\n\n            await ToSignal(GetTree(), \"process_frame\");\n        }\n\n        // Remove the tracer after fade completes\n        if (IsInstanceValid(tracer))\n        {\n            tracer.QueueFree();\n        }\n    }\n\n    // =========================================================================\n    // Sound and Effects\n    // =========================================================================\n\n    /// <summary>\n    /// Plays the sniper shot sound via AudioManager.\n    /// </summary>\n    private void PlaySniperShotSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        // Use M16 shot as a placeholder sound for the sniper\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_shot\"))\n        {\n            audioManager.Call(\"play_m16_shot\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Plays the empty gun click sound.\n    /// </summary>\n    private void PlayEmptyClickSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_empty_click\"))\n        {\n            audioManager.Call(\"play_empty_click\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Emits gunshot sound for enemy detection via SoundPropagation.\n    /// Very loud for the 12.7mm round.\n    /// </summary>\n    private void EmitGunshotSound()\n    {\n        var soundPropagation = GetNodeOrNull(\"/root/SoundPropagation\");\n        if (soundPropagation != null && soundPropagation.HasMethod(\"emit_sound\"))\n        {\n            float loudness = WeaponData?.Loudness ?? 3000.0f;\n            soundPropagation.Call(\"emit_sound\", 0, GlobalPosition, 0, this, loudness);\n        }\n    }\n\n    /// <summary>\n    /// Plays shell casing sound with a delay.\n    /// </summary>\n    private async void PlayShellCasingDelayed()\n    {\n        await ToSignal(GetTree().CreateTimer(0.2), \"timeout\");\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_shell_rifle\"))\n        {\n            audioManager.Call(\"play_shell_rifle\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Applies recoil to shooting direction.\n    /// </summary>\n    private Vector2 ApplyRecoil(Vector2 direction)\n    {\n        // Apply current recoil offset\n        Vector2 result = direction.Rotated(_recoilOffset);\n\n        // Add strong recoil for next shot (heavy 12.7mm kick)\n        float recoilDirection = (float)GD.RandRange(-1.0, 1.0);\n        _recoilOffset += recoilDirection * RecoilPerShot;\n        _recoilOffset = Mathf.Clamp(_recoilOffset, -MaxRecoilOffset, MaxRecoilOffset);\n\n        _timeSinceLastShot = 0;\n\n        return result;\n    }\n\n    /// <summary>\n    /// Triggers screen shake from sniper shot.\n    /// Heavy shake for 12.7mm round.\n    /// </summary>\n    private void TriggerScreenShake(Vector2 shootDirection)\n    {\n        if (WeaponData == null || WeaponData.ScreenShakeIntensity <= 0)\n        {\n            return;\n        }\n\n        var screenShakeManager = GetNodeOrNull(\"/root/ScreenShakeManager\");\n        if (screenShakeManager == null || !screenShakeManager.HasMethod(\"add_shake\"))\n        {\n            return;\n        }\n\n        // Heavy shake for sniper\n        float fireRate = WeaponData.FireRate;\n        float shakeIntensity;\n        if (fireRate > 0)\n        {\n            shakeIntensity = WeaponData.ScreenShakeIntensity / fireRate * 10.0f;\n        }\n        else\n        {\n            shakeIntensity = WeaponData.ScreenShakeIntensity;\n        }\n\n        float recoveryTime = WeaponData.ScreenShakeMinRecoveryTime;\n\n        screenShakeManager.Call(\"add_shake\", shootDirection, shakeIntensity, recoveryTime);\n    }\n\n    /// <summary>\n    /// Fires the bullet in the chamber during reload sequence.\n    /// </summary>\n    public override bool FireChamberBullet(Vector2 direction)\n    {\n        // Sniper rifle doesn't support chamber bullet during reload\n        // (bolt-action requires full cycle)\n        return false;\n    }\n\n    /// <summary>\n    /// Gets the current aim direction.\n    /// </summary>\n    public Vector2 AimDirection => _aimDirection;\n\n    /// <summary>\n    /// Gets the current bolt-action step.\n    /// </summary>\n    public BoltActionStep CurrentBoltStep => _boltStep;\n\n    /// <summary>\n    /// Resets the bolt to ready state (e.g., after reload with a new magazine).\n    /// </summary>\n    public void ResetBolt()\n    {\n        _boltStep = BoltActionStep.Ready;\n        EmitSignal(SignalName.BoltStepChanged, 4, 4);\n        GD.Print(\"[SniperRifle] Bolt reset to ready state\");\n    }\n\n    // =========================================================================\n    // Scope / Aiming System (RMB)\n    // =========================================================================\n\n    /// <summary>\n    /// Whether the scope is currently active (RMB held).\n    /// </summary>\n    private bool _isScopeActive = false;\n\n    /// <summary>\n    /// Whether the scope is active (read-only property for external access).\n    /// </summary>\n    public bool IsScopeActive => _isScopeActive;\n\n    /// <summary>\n    /// Signal emitted when scope state changes.\n    /// </summary>\n    [Signal]\n    public delegate void ScopeStateChangedEventHandler(bool isActive);\n\n    /// <summary>\n    /// Current scope zoom distance multiplier (how far beyond viewport the player can see).\n    /// 1.0 = one viewport distance, 2.0 = two viewport distances.\n    /// Controlled by mouse wheel while scoping.\n    /// </summary>\n    private float _scopeZoomDistance = 1.0f;\n\n    /// <summary>\n    /// Minimum scope zoom distance (viewport multiplier).\n    /// Set to 1.0 so the scope always looks beyond the normal viewport.\n    /// </summary>\n    private const float MinScopeZoomDistance = 1.0f;\n\n    /// <summary>\n    /// Maximum scope zoom distance (viewport multiplier).\n    /// </summary>\n    private const float MaxScopeZoomDistance = 3.0f;\n\n    /// <summary>\n    /// Step size for mouse wheel zoom adjustment.\n    /// </summary>\n    private const float ScopeZoomStep = 0.25f;\n\n    /// <summary>\n    /// Base sway amplitude in pixels at 1 viewport distance.\n    /// </summary>\n    private const float BaseScopeSwayAmplitude = 8.0f;\n\n    /// <summary>\n    /// Speed of the sway oscillation.\n    /// </summary>\n    private const float ScopeSwaySpeed = 2.5f;\n\n    /// <summary>\n    /// Maximum range (in viewport fraction) that the player can fine-tune the scope\n    /// distance via mouse movement while scoped. About 1/3 of the viewport.\n    /// </summary>\n    private const float ScopeMouseFineTuneRange = 0.33f;\n\n    /// <summary>\n    /// Current mouse fine-tune offset applied to scope distance.\n    /// Ranges from -ScopeMouseFineTuneRange to +ScopeMouseFineTuneRange (viewport fraction).\n    /// Positive = further, negative = closer.\n    /// </summary>\n    private float _scopeMouseFineTuneOffset = 0.0f;\n\n    /// <summary>\n    /// Current scope sway time accumulator.\n    /// </summary>\n    private float _scopeSwayTime = 0.0f;\n\n    /// <summary>\n    /// Current scope sway offset in pixels (applied to camera).\n    /// </summary>\n    private Vector2 _scopeSwayOffset = Vector2.Zero;\n\n    /// <summary>\n    /// Reference to the scope overlay CanvasLayer (created when scope activates).\n    /// </summary>\n    private CanvasLayer? _scopeOverlay = null;\n\n    /// <summary>\n    /// Reference to the scope crosshair control node.\n    /// </summary>\n    private Control? _scopeCrosshair = null;\n\n    /// <summary>\n    /// Reference to the scope darkening background.\n    /// </summary>\n    private ColorRect? _scopeBackground = null;\n\n    /// <summary>\n    /// Cached reference to the player's Camera2D node.\n    /// </summary>\n    private Camera2D? _playerCamera = null;\n\n    /// <summary>\n    /// Original camera offset before scoping (to restore on exit).\n    /// </summary>\n    private Vector2 _originalCameraOffset = Vector2.Zero;\n\n    /// <summary>\n    /// Gets the current camera offset for scope aiming.\n    /// Called by the player or level scripts to position the camera.\n    /// </summary>\n    public Vector2 GetScopeCameraOffset()\n    {\n        if (!_isScopeActive)\n        {\n            return Vector2.Zero;\n        }\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return Vector2.Zero;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float baseDistance = viewportSize.Length() * 0.5f;\n\n        // Camera offset = aim direction * zoom distance * viewport size + sway\n        Vector2 offset = _aimDirection * baseDistance * _scopeZoomDistance + _scopeSwayOffset;\n\n        return offset;\n    }\n\n    /// <summary>\n    /// Activates the scope (called when RMB is pressed).\n    /// </summary>\n    public void ActivateScope()\n    {\n        if (_isScopeActive)\n        {\n            return;\n        }\n\n        _isScopeActive = true;\n        _scopeSwayTime = 0.0f;\n\n        // Find and cache the player's Camera2D\n        FindPlayerCamera();\n\n        // Store original camera offset\n        if (_playerCamera != null)\n        {\n            _originalCameraOffset = _playerCamera.Offset;\n        }\n\n        // Create the scope overlay\n        CreateScopeOverlay();\n\n        EmitSignal(SignalName.ScopeStateChanged, true);\n        GD.Print($\"[SniperRifle] Scope activated. Zoom distance: {_scopeZoomDistance:F1}x\");\n    }\n\n    /// <summary>\n    /// Deactivates the scope (called when RMB is released).\n    /// </summary>\n    public void DeactivateScope()\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        _isScopeActive = false;\n\n        // Restore original camera offset\n        if (_playerCamera != null)\n        {\n            _playerCamera.Offset = _originalCameraOffset;\n        }\n\n        // Remove scope overlay\n        RemoveScopeOverlay();\n\n        EmitSignal(SignalName.ScopeStateChanged, false);\n        GD.Print(\"[SniperRifle] Scope deactivated.\");\n    }\n\n    /// <summary>\n    /// Adjusts the scope zoom distance (called on mouse wheel while scoping).\n    /// </summary>\n    public void AdjustScopeZoom(float direction)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        _scopeZoomDistance += direction * ScopeZoomStep;\n        _scopeZoomDistance = Mathf.Clamp(_scopeZoomDistance, MinScopeZoomDistance, MaxScopeZoomDistance);\n\n        GD.Print($\"[SniperRifle] Scope zoom adjusted: {_scopeZoomDistance:F2}x\");\n    }\n\n    /// <summary>\n    /// Finds the player's Camera2D node by traversing up to the parent (player).\n    /// </summary>\n    private void FindPlayerCamera()\n    {\n        if (_playerCamera != null)\n        {\n            return;\n        }\n\n        var parent = GetParent();\n        if (parent != null)\n        {\n            _playerCamera = parent.GetNodeOrNull<Camera2D>(\"Camera2D\");\n        }\n    }\n\n    /// <summary>\n    /// Updates the scope system each frame (called from _Process).\n    /// </summary>\n    private void UpdateScope(float delta)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        // Update sway\n        _scopeSwayTime += delta;\n        float swayAmplitude = BaseScopeSwayAmplitude * _scopeZoomDistance;\n\n        // Use two sine waves at different frequencies for natural-looking sway\n        float swayX = Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 1.0f) * swayAmplitude\n                    + Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 2.3f) * swayAmplitude * 0.3f;\n        float swayY = Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 1.4f) * swayAmplitude\n                    + Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 0.7f) * swayAmplitude * 0.4f;\n\n        _scopeSwayOffset = new Vector2(swayX, swayY);\n\n        // Update camera offset for scope view\n        if (_playerCamera != null)\n        {\n            _playerCamera.Offset = _originalCameraOffset + GetScopeCameraOffset();\n        }\n\n        // Update scope overlay crosshair position with sway\n        UpdateScopeOverlayPosition();\n    }\n\n    /// <summary>\n    /// Creates the scope overlay UI with crosshair and darkened edges.\n    /// </summary>\n    private void CreateScopeOverlay()\n    {\n        RemoveScopeOverlay();\n\n        _scopeOverlay = new CanvasLayer\n        {\n            Name = \"ScopeOverlay\",\n            Layer = 10\n        };\n\n        Viewport? viewport = GetViewport();\n        Vector2 viewportSize = viewport?.GetVisibleRect().Size ?? new Vector2(1280, 720);\n\n        // Dark background with circular cutout effect (vignette)\n        _scopeBackground = new ColorRect\n        {\n            Name = \"ScopeBackground\",\n            Color = new Color(0.0f, 0.0f, 0.0f, 0.5f),\n            Size = viewportSize,\n            Position = Vector2.Zero,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        _scopeOverlay.AddChild(_scopeBackground);\n\n        // Create the crosshair as a Control node\n        _scopeCrosshair = new Control\n        {\n            Name = \"ScopeCrosshair\",\n            Position = viewportSize / 2,\n            Size = Vector2.Zero,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        _scopeOverlay.AddChild(_scopeCrosshair);\n\n        // Add crosshair lines - based on the reference image from the issue\n        // The scope has a classic crosshair with circle and mil-dots\n\n        // Outer circle\n        float circleRadius = Mathf.Min(viewportSize.X, viewportSize.Y) * 0.35f;\n        int segments = 64;\n        var outerCircle = new Line2D\n        {\n            Name = \"OuterCircle\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f),\n            Antialiased = true\n        };\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            outerCircle.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * circleRadius);\n        }\n        _scopeCrosshair.AddChild(outerCircle);\n\n        // Inner thin circle\n        float innerRadius = circleRadius * 0.05f;\n        var innerCircle = new Line2D\n        {\n            Name = \"InnerCircle\",\n            Width = 1.5f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f),\n            Antialiased = true\n        };\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            innerCircle.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * innerRadius);\n        }\n        _scopeCrosshair.AddChild(innerCircle);\n\n        // Horizontal crosshair line (left)\n        var hLineLeft = new Line2D\n        {\n            Name = \"HLineLeft\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        hLineLeft.AddPoint(new Vector2(-circleRadius, 0));\n        hLineLeft.AddPoint(new Vector2(-innerRadius, 0));\n        _scopeCrosshair.AddChild(hLineLeft);\n\n        // Horizontal crosshair line (right)\n        var hLineRight = new Line2D\n        {\n            Name = \"HLineRight\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        hLineRight.AddPoint(new Vector2(innerRadius, 0));\n        hLineRight.AddPoint(new Vector2(circleRadius, 0));\n        _scopeCrosshair.AddChild(hLineRight);\n\n        // Vertical crosshair line (top)\n        var vLineTop = new Line2D\n        {\n            Name = \"VLineTop\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        vLineTop.AddPoint(new Vector2(0, -circleRadius));\n        vLineTop.AddPoint(new Vector2(0, -innerRadius));\n        _scopeCrosshair.AddChild(vLineTop);\n\n        // Vertical crosshair line (bottom) with mil-dots\n        var vLineBottom = new Line2D\n        {\n            Name = \"VLineBottom\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        vLineBottom.AddPoint(new Vector2(0, innerRadius));\n        vLineBottom.AddPoint(new Vector2(0, circleRadius));\n        _scopeCrosshair.AddChild(vLineBottom);\n\n        // Add mil-dot markers on the bottom crosshair (range estimation)\n        float dotSpacing = circleRadius * 0.15f;\n        for (int i = 1; i <= 4; i++)\n        {\n            float dotY = dotSpacing * i;\n            var dot = new Line2D\n            {\n                Name = $\"MilDot_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            float dotWidth = 4.0f - i * 0.5f; // Dots get smaller further from center\n            dot.AddPoint(new Vector2(-dotWidth, dotY));\n            dot.AddPoint(new Vector2(dotWidth, dotY));\n            _scopeCrosshair.AddChild(dot);\n        }\n\n        // Add mil-dot markers on horizontal lines\n        for (int i = 1; i <= 3; i++)\n        {\n            float dotX = dotSpacing * i;\n            // Right side dots\n            var dotRight = new Line2D\n            {\n                Name = $\"HMilDotRight_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            float dotHeight = 4.0f - i * 0.5f;\n            dotRight.AddPoint(new Vector2(dotX, -dotHeight));\n            dotRight.AddPoint(new Vector2(dotX, dotHeight));\n            _scopeCrosshair.AddChild(dotRight);\n\n            // Left side dots\n            var dotLeft = new Line2D\n            {\n                Name = $\"HMilDotLeft_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            dotLeft.AddPoint(new Vector2(-dotX, -dotHeight));\n            dotLeft.AddPoint(new Vector2(-dotX, dotHeight));\n            _scopeCrosshair.AddChild(dotLeft);\n        }\n\n        // Add thick outer ring to mask edges (simulate scope tube)\n        var scopeRing = new Line2D\n        {\n            Name = \"ScopeRing\",\n            Width = 6.0f,\n            DefaultColor = new Color(0.1f, 0.1f, 0.1f, 0.95f),\n            Antialiased = true\n        };\n        float ringRadius = circleRadius + 3.0f;\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            scopeRing.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * ringRadius);\n        }\n        _scopeCrosshair.AddChild(scopeRing);\n\n        // Zoom distance indicator text\n        var zoomLabel = new Label\n        {\n            Name = \"ZoomLabel\",\n            Position = new Vector2(circleRadius * 0.5f, circleRadius * 0.7f),\n            Text = $\"{_scopeZoomDistance:F1}x\",\n            HorizontalAlignment = HorizontalAlignment.Center,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        zoomLabel.AddThemeColorOverride(\"font_color\", new Color(0.0f, 0.0f, 0.0f, 0.6f));\n        zoomLabel.AddThemeFontSizeOverride(\"font_size\", 12);\n        _scopeCrosshair.AddChild(zoomLabel);\n\n        GetTree().CurrentScene.AddChild(_scopeOverlay);\n    }\n\n    /// <summary>\n    /// Updates the scope overlay crosshair position with sway applied.\n    /// </summary>\n    private void UpdateScopeOverlayPosition()\n    {\n        if (_scopeCrosshair == null || _scopeOverlay == null)\n        {\n            return;\n        }\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n\n        // Crosshair stays centered but sways\n        _scopeCrosshair.Position = viewportSize / 2 + _scopeSwayOffset;\n\n        // Update zoom label\n        var zoomLabel = _scopeCrosshair.GetNodeOrNull<Label>(\"ZoomLabel\");\n        if (zoomLabel != null)\n        {\n            zoomLabel.Text = $\"{_scopeZoomDistance:F1}x\";\n        }\n    }\n\n    /// <summary>\n    /// Removes the scope overlay from the scene.\n    /// </summary>\n    private void RemoveScopeOverlay()\n    {\n        if (_scopeOverlay != null && IsInstanceValid(_scopeOverlay))\n        {\n            _scopeOverlay.QueueFree();\n            _scopeOverlay = null;\n            _scopeCrosshair = null;\n            _scopeBackground = null;\n        }\n    }\n}\n",
    "structuredPatch": [
      {
        "oldStart": 997,
        "oldLines": 6,
        "newStart": 997,
        "newLines": 11,
        "lines": [
          "     private Vector2 _originalCameraOffset = Vector2.Zero;",
          " ",
          "     /// <summary>",
          "+    /// Gets the effective scope zoom distance including mouse fine-tune offset.",
          "+    /// </summary>",
          "+    private float EffectiveScopeZoomDistance => _scopeZoomDistance + _scopeMouseFineTuneOffset;",
          "+",
          "+    /// <summary>",
          "     /// Gets the current camera offset for scope aiming.",
          "     /// Called by the player or level scripts to position the camera.",
          "     /// </summary>"
        ]
      },
      {
        "oldStart": 1016,
        "oldLines": 13,
        "newStart": 1021,
        "newLines": 35,
        "lines": [
          "         Vector2 viewportSize = viewport.GetVisibleRect().Size;",
          "         float baseDistance = viewportSize.Length() * 0.5f;",
          " ",
          "-        // Camera offset = aim direction * zoom distance * viewport size + sway",
          "-        Vector2 offset = _aimDirection * baseDistance * _scopeZoomDistance + _scopeSwayOffset;",
          "+        // Camera offset = aim direction * (zoom distance + mouse fine-tune) * viewport size + sway",
          "+        Vector2 offset = _aimDirection * baseDistance * EffectiveScopeZoomDistance + _scopeSwayOffset;",
          " ",
          "         return offset;",
          "     }",
          " ",
          "     /// <summary>",
          "+    /// Gets the world-space position that the scope crosshair center is aiming at.",
          "+    /// Used to direct bullets to the crosshair center.",
          "+    /// </summary>",
          "+    public Vector2 GetScopeAimTarget()",
          "+    {",
          "+        Viewport? viewport = GetViewport();",
          "+        if (viewport == null)",
          "+        {",
          "+            return GlobalPosition + _aimDirection * 1000.0f;",
          "+        }",
          "+",
          "+        Vector2 viewportSize = viewport.GetVisibleRect().Size;",
          "+        float baseDistance = viewportSize.Length() * 0.5f;",
          "+",
          "+        // The scope aim target is the player's position offset by the scope camera offset",
          "+        // (without sway, so bullets go to the true center, not the swaying crosshair)",
          "+        Vector2 aimTarget = GlobalPosition + _aimDirection * baseDistance * EffectiveScopeZoomDistance;",
          "+",
          "+        return aimTarget;",
          "+    }",
          "+",
          "+    /// <summary>",
          "     /// Activates the scope (called when RMB is pressed).",
          "     /// </summary>",
          "     public void ActivateScope()"
        ]
      }
    ],
    "userModified": false,
    "replaceAll": false
  }
}
[2026-02-06T20:57:28.155Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01AKqmeGwL73iVf6dVzpMEMp",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now add the `AdjustScopeFineTune` method and reset the fine-tune offset when scope activates/deactivates:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 907,
      "cache_read_input_tokens": 59530,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 907
      },
      "output_tokens": 2,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "39fc3a06-2d1e-4f60-b4eb-53fca14a0c49"
}
[2026-02-06T20:57:37.558Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01AKqmeGwL73iVf6dVzpMEMp",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_015gzyuz3P8pdT8q8cnnSX4t",
        "name": "Edit",
        "input": {
          "replace_all": false,
          "file_path": "/tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs",
          "old_string": "    /// <summary>\n    /// Adjusts the scope zoom distance (called on mouse wheel while scoping).\n    /// </summary>\n    public void AdjustScopeZoom(float direction)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        _scopeZoomDistance += direction * ScopeZoomStep;\n        _scopeZoomDistance = Mathf.Clamp(_scopeZoomDistance, MinScopeZoomDistance, MaxScopeZoomDistance);\n\n        GD.Print($\"[SniperRifle] Scope zoom adjusted: {_scopeZoomDistance:F2}x\");\n    }",
          "new_string": "    /// <summary>\n    /// Adjusts the scope zoom distance (called on mouse wheel while scoping).\n    /// </summary>\n    public void AdjustScopeZoom(float direction)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        _scopeZoomDistance += direction * ScopeZoomStep;\n        _scopeZoomDistance = Mathf.Clamp(_scopeZoomDistance, MinScopeZoomDistance, MaxScopeZoomDistance);\n\n        // Reset fine-tune offset when zoom changes to avoid going out of range\n        _scopeMouseFineTuneOffset = Mathf.Clamp(_scopeMouseFineTuneOffset,\n            -ScopeMouseFineTuneRange, ScopeMouseFineTuneRange);\n\n        GD.Print($\"[SniperRifle] Scope zoom adjusted: {_scopeZoomDistance:F2}x (fine-tune: {_scopeMouseFineTuneOffset:F2})\");\n    }\n\n    /// <summary>\n    /// Adjusts the scope fine-tune offset based on mouse movement along the aim direction.\n    /// Allows the player to look slightly closer or further (about 1/3 viewport range).\n    /// Called from Player.cs when mouse moves while scoped.\n    /// </summary>\n    public void AdjustScopeFineTune(Vector2 mouseMotion)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        // Project mouse motion onto the aim direction to get forward/backward movement\n        // Moving mouse in the aim direction = further, opposite = closer\n        float projection = mouseMotion.Dot(_aimDirection);\n\n        // Scale the projection: mouse sensitivity for scope fine-tuning\n        // A moderate movement across the screen should give the full range\n        float sensitivity = 0.002f;\n        _scopeMouseFineTuneOffset += projection * sensitivity;\n        _scopeMouseFineTuneOffset = Mathf.Clamp(_scopeMouseFineTuneOffset,\n            -ScopeMouseFineTuneRange, ScopeMouseFineTuneRange);\n    }"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 907,
      "cache_read_input_tokens": 59530,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 907
      },
      "output_tokens": 2,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "f91f8a40-7003-428d-a57f-4b0505e660d5"
}
[2026-02-06T20:57:37.571Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_015gzyuz3P8pdT8q8cnnSX4t",
        "type": "tool_result",
        "content": "The file /tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs has been updated successfully."
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "22eca36f-fa02-4dd6-9ab7-e9ff4b3daf3a",
  "tool_use_result": {
    "filePath": "/tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs",
    "oldString": "    /// <summary>\n    /// Adjusts the scope zoom distance (called on mouse wheel while scoping).\n    /// </summary>\n    public void AdjustScopeZoom(float direction)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        _scopeZoomDistance += direction * ScopeZoomStep;\n        _scopeZoomDistance = Mathf.Clamp(_scopeZoomDistance, MinScopeZoomDistance, MaxScopeZoomDistance);\n\n        GD.Print($\"[SniperRifle] Scope zoom adjusted: {_scopeZoomDistance:F2}x\");\n    }",
    "newString": "    /// <summary>\n    /// Adjusts the scope zoom distance (called on mouse wheel while scoping).\n    /// </summary>\n    public void AdjustScopeZoom(float direction)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        _scopeZoomDistance += direction * ScopeZoomStep;\n        _scopeZoomDistance = Mathf.Clamp(_scopeZoomDistance, MinScopeZoomDistance, MaxScopeZoomDistance);\n\n        // Reset fine-tune offset when zoom changes to avoid going out of range\n        _scopeMouseFineTuneOffset = Mathf.Clamp(_scopeMouseFineTuneOffset,\n            -ScopeMouseFineTuneRange, ScopeMouseFineTuneRange);\n\n        GD.Print($\"[SniperRifle] Scope zoom adjusted: {_scopeZoomDistance:F2}x (fine-tune: {_scopeMouseFineTuneOffset:F2})\");\n    }\n\n    /// <summary>\n    /// Adjusts the scope fine-tune offset based on mouse movement along the aim direction.\n    /// Allows the player to look slightly closer or further (about 1/3 viewport range).\n    /// Called from Player.cs when mouse moves while scoped.\n    /// </summary>\n    public void AdjustScopeFineTune(Vector2 mouseMotion)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        // Project mouse motion onto the aim direction to get forward/backward movement\n        // Moving mouse in the aim direction = further, opposite = closer\n        float projection = mouseMotion.Dot(_aimDirection);\n\n        // Scale the projection: mouse sensitivity for scope fine-tuning\n        // A moderate movement across the screen should give the full range\n        float sensitivity = 0.002f;\n        _scopeMouseFineTuneOffset += projection * sensitivity;\n        _scopeMouseFineTuneOffset = Mathf.Clamp(_scopeMouseFineTuneOffset,\n            -ScopeMouseFineTuneRange, ScopeMouseFineTuneRange);\n    }",
    "originalFile": "using Godot;\nusing GodotTopDownTemplate.AbstractClasses;\nusing GodotTopDownTemplate.Projectiles;\n\nnamespace GodotTopDownTemplate.Weapons;\n\n/// <summary>\n/// Bolt-action charging state for the ASVK sniper rifle.\n/// Before each shot, the player must complete a 4-step bolt-action sequence:\n/// Down (pull bolt back) ‚Üí Left (open bolt) ‚Üí Down (close bolt) ‚Üí Up (chamber round)\n/// </summary>\npublic enum BoltActionStep\n{\n    /// <summary>\n    /// Bolt is ready - weapon can fire. After firing, transitions to NeedsBoltCycle.\n    /// </summary>\n    Ready,\n\n    /// <summary>\n    /// Just fired - needs bolt cycling before next shot.\n    /// Waiting for Down arrow (pull bolt back).\n    /// </summary>\n    NeedsBoltCycle,\n\n    /// <summary>\n    /// Step 1 complete (bolt pulled back). Waiting for Left arrow (open bolt).\n    /// </summary>\n    WaitOpenBolt,\n\n    /// <summary>\n    /// Step 2 complete (bolt opened). Waiting for Down arrow (close bolt).\n    /// </summary>\n    WaitCloseBolt,\n\n    /// <summary>\n    /// Step 3 complete (bolt closed). Waiting for Up arrow (chamber round).\n    /// </summary>\n    WaitChamberRound\n}\n\n/// <summary>\n/// ASVK sniper rifle - heavy anti-materiel bolt-action rifle.\n/// Features:\n/// - 12.7x108mm ammunition dealing 50 damage per shot\n/// - Penetrates through 2 walls and through enemies\n/// - Instant bullet speed with smoky dissipating tracer trail\n/// - Very high turn sensitivity\n/// - 5-round magazine with M16-style swap reload\n/// - Single-shot bolt-action with manual charging sequence (Down‚ÜíLeft‚ÜíDown‚ÜíUp)\n/// - Red laser sight for aiming\n/// Reference: ASVK (–ê–°–í–ö) anti-materiel sniper rifle\n/// </summary>\npublic partial class SniperRifle : BaseWeapon\n{\n    // =========================================================================\n    // Bolt-Action State\n    // =========================================================================\n\n    /// <summary>\n    /// Current bolt-action charging step.\n    /// </summary>\n    private BoltActionStep _boltStep = BoltActionStep.Ready;\n\n    /// <summary>\n    /// Whether the bolt action is ready to fire (chambered).\n    /// Initially true so first shot can be fired immediately.\n    /// </summary>\n    public bool IsBoltReady => _boltStep == BoltActionStep.Ready;\n\n    /// <summary>\n    /// Whether the weapon needs bolt cycling before it can fire again.\n    /// </summary>\n    public bool NeedsBoltCycle => _boltStep != BoltActionStep.Ready;\n\n    /// <summary>\n    /// Signal emitted when bolt-action step changes.\n    /// </summary>\n    [Signal]\n    public delegate void BoltStepChangedEventHandler(int step, int totalSteps);\n\n    // =========================================================================\n    // Smoky Tracer Trail\n    // =========================================================================\n\n    /// <summary>\n    /// Scene for the smoky tracer trail effect.\n    /// Created programmatically as a Line2D with smoke-like appearance.\n    /// </summary>\n    private Line2D? _lastTracerTrail;\n\n    // =========================================================================\n    // Laser Sight Configuration\n    // =========================================================================\n\n    /// <summary>\n    /// Whether the laser sight is enabled.\n    /// </summary>\n    [Export]\n    public bool LaserSightEnabled { get; set; } = true;\n\n    /// <summary>\n    /// Maximum length of the laser sight in pixels.\n    /// </summary>\n    [Export]\n    public float LaserSightLength { get; set; } = 500.0f;\n\n    /// <summary>\n    /// Color of the laser sight (red for sniper).\n    /// </summary>\n    [Export]\n    public Color LaserSightColor { get; set; } = new Color(1.0f, 0.0f, 0.0f, 0.5f);\n\n    /// <summary>\n    /// Width of the laser sight line.\n    /// </summary>\n    [Export]\n    public float LaserSightWidth { get; set; } = 2.0f;\n\n    /// <summary>\n    /// Reference to the Line2D node for the laser sight.\n    /// </summary>\n    private Line2D? _laserSight;\n\n    /// <summary>\n    /// Reference to the Sprite2D node for the rifle visual.\n    /// </summary>\n    private Sprite2D? _rifleSprite;\n\n    /// <summary>\n    /// Current aim direction based on laser sight.\n    /// </summary>\n    private Vector2 _aimDirection = Vector2.Right;\n\n    /// <summary>\n    /// Current aim angle in radians.\n    /// </summary>\n    private float _currentAimAngle = 0.0f;\n\n    /// <summary>\n    /// Whether the aim angle has been initialized.\n    /// </summary>\n    private bool _aimAngleInitialized = false;\n\n    /// <summary>\n    /// Current recoil offset angle in radians.\n    /// Heavy sniper recoil.\n    /// </summary>\n    private float _recoilOffset = 0.0f;\n\n    /// <summary>\n    /// Time since the last shot was fired, used for recoil recovery.\n    /// </summary>\n    private float _timeSinceLastShot = 0.0f;\n\n    /// <summary>\n    /// Time in seconds before recoil starts recovering.\n    /// Long delay for heavy sniper.\n    /// </summary>\n    private const float RecoilRecoveryDelay = 0.5f;\n\n    /// <summary>\n    /// Speed at which recoil recovers (radians per second).\n    /// </summary>\n    private const float RecoilRecoverySpeed = 3.0f;\n\n    /// <summary>\n    /// Maximum recoil offset in radians (about 15 degrees).\n    /// </summary>\n    private const float MaxRecoilOffset = 0.26f;\n\n    /// <summary>\n    /// Recoil amount per shot in radians.\n    /// Heavy kick for 12.7mm.\n    /// </summary>\n    private const float RecoilPerShot = 0.15f;\n\n    /// <summary>\n    /// Number of walls this bullet can penetrate through.\n    /// The bullet continues flying after penetrating walls.\n    /// </summary>\n    private const int MaxWallPenetrations = 2;\n\n    public override void _Ready()\n    {\n        base._Ready();\n\n        // Get the rifle sprite for visual representation\n        _rifleSprite = GetNodeOrNull<Sprite2D>(\"RifleSprite\");\n\n        if (_rifleSprite != null)\n        {\n            var texture = _rifleSprite.Texture;\n            GD.Print($\"[SniperRifle] RifleSprite found: visible={_rifleSprite.Visible}, z_index={_rifleSprite.ZIndex}, texture={(texture != null ? \"loaded\" : \"NULL\")}\");\n        }\n        else\n        {\n            GD.PrintErr(\"[SniperRifle] WARNING: RifleSprite node not found!\");\n        }\n\n        // Check for Power Fantasy mode blue laser\n        var difficultyManager = GetNodeOrNull(\"/root/DifficultyManager\");\n        if (difficultyManager != null)\n        {\n            var shouldForceBlueLaser = difficultyManager.Call(\"should_force_blue_laser_sight\");\n            if (shouldForceBlueLaser.AsBool())\n            {\n                var blueColorVariant = difficultyManager.Call(\"get_power_fantasy_laser_color\");\n                LaserSightColor = blueColorVariant.AsColor();\n                GD.Print($\"[SniperRifle] Power Fantasy mode: laser color set to blue {LaserSightColor}\");\n            }\n        }\n\n        // Get or create the laser sight Line2D\n        _laserSight = GetNodeOrNull<Line2D>(\"LaserSight\");\n\n        if (_laserSight == null && LaserSightEnabled)\n        {\n            CreateLaserSight();\n        }\n        else if (_laserSight != null)\n        {\n            _laserSight.Width = LaserSightWidth;\n            _laserSight.DefaultColor = LaserSightColor;\n            _laserSight.BeginCapMode = Line2D.LineCapMode.Round;\n            _laserSight.EndCapMode = Line2D.LineCapMode.Round;\n\n            if (_laserSight.GetPointCount() < 2)\n            {\n                _laserSight.ClearPoints();\n                _laserSight.AddPoint(Vector2.Zero);\n                _laserSight.AddPoint(Vector2.Right * LaserSightLength);\n            }\n        }\n\n        UpdateLaserSightVisibility();\n        GD.Print(\"[SniperRifle] ASVK initialized - bolt ready, laser sight enabled\");\n    }\n\n    public override void _ExitTree()\n    {\n        // Clean up scope overlay when weapon is removed from scene tree\n        if (_isScopeActive)\n        {\n            DeactivateScope();\n        }\n        base._ExitTree();\n    }\n\n    public override void _Process(double delta)\n    {\n        base._Process(delta);\n\n        // Update time since last shot for recoil recovery\n        _timeSinceLastShot += (float)delta;\n\n        // Recover recoil after delay\n        if (_timeSinceLastShot >= RecoilRecoveryDelay && _recoilOffset != 0)\n        {\n            float recoveryAmount = RecoilRecoverySpeed * (float)delta;\n            _recoilOffset = Mathf.MoveToward(_recoilOffset, 0, recoveryAmount);\n        }\n\n        // Always update aim direction and rifle sprite rotation\n        UpdateAimDirection();\n\n        // Update laser sight to point towards mouse (with recoil offset)\n        if (LaserSightEnabled && _laserSight != null)\n        {\n            UpdateLaserSight();\n        }\n\n        // Handle bolt-action input\n        HandleBoltActionInput();\n\n        // Update scope system (sway, camera offset, overlay)\n        UpdateScope((float)delta);\n    }\n\n    // =========================================================================\n    // Bolt-Action Charging Mechanics\n    // =========================================================================\n\n    /// <summary>\n    /// Handles the bolt-action charging input sequence.\n    /// Sequence: Down (pull bolt) ‚Üí Left (open bolt) ‚Üí Down (close bolt) ‚Üí Up (chamber round)\n    /// Uses the arrow keys / WASD movement input actions.\n    /// </summary>\n    private void HandleBoltActionInput()\n    {\n        switch (_boltStep)\n        {\n            case BoltActionStep.NeedsBoltCycle:\n                // Step 1: Down arrow - pull bolt back\n                if (Input.IsActionJustPressed(\"move_down\"))\n                {\n                    _boltStep = BoltActionStep.WaitOpenBolt;\n                    EmitSignal(SignalName.BoltStepChanged, 1, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 1/4: Bolt pulled back\");\n                }\n                break;\n\n            case BoltActionStep.WaitOpenBolt:\n                // Step 2: Left arrow - open bolt\n                if (Input.IsActionJustPressed(\"move_left\"))\n                {\n                    _boltStep = BoltActionStep.WaitCloseBolt;\n                    EmitSignal(SignalName.BoltStepChanged, 2, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 2/4: Bolt opened\");\n                }\n                break;\n\n            case BoltActionStep.WaitCloseBolt:\n                // Step 3: Down arrow - close bolt\n                if (Input.IsActionJustPressed(\"move_down\"))\n                {\n                    _boltStep = BoltActionStep.WaitChamberRound;\n                    EmitSignal(SignalName.BoltStepChanged, 3, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 3/4: Bolt closed\");\n                }\n                break;\n\n            case BoltActionStep.WaitChamberRound:\n                // Step 4: Up arrow - chamber round\n                if (Input.IsActionJustPressed(\"move_up\"))\n                {\n                    _boltStep = BoltActionStep.Ready;\n                    EmitSignal(SignalName.BoltStepChanged, 4, 4);\n                    PlayBoltChamberSound();\n                    GD.Print(\"[SniperRifle] Bolt step 4/4: Round chambered - READY TO FIRE\");\n                }\n                break;\n\n            case BoltActionStep.Ready:\n                // Already ready, no bolt action needed\n                break;\n        }\n    }\n\n    /// <summary>\n    /// Plays the bolt manipulation sound.\n    /// </summary>\n    private void PlayBoltSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_bolt\"))\n        {\n            audioManager.Call(\"play_m16_bolt\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Plays the bolt chamber/ready sound.\n    /// </summary>\n    private void PlayBoltChamberSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_bolt\"))\n        {\n            audioManager.Call(\"play_m16_bolt\", GlobalPosition);\n        }\n    }\n\n    // =========================================================================\n    // Aiming and Laser Sight\n    // =========================================================================\n\n    /// <summary>\n    /// Updates the aim direction and rifle sprite rotation.\n    /// </summary>\n    private void UpdateAimDirection()\n    {\n        Vector2 mousePos = GetGlobalMousePosition();\n        Vector2 toMouse = mousePos - GlobalPosition;\n        float targetAngle = toMouse.Angle();\n\n        if (!_aimAngleInitialized)\n        {\n            _currentAimAngle = targetAngle;\n            _aimAngleInitialized = true;\n        }\n\n        Vector2 direction;\n\n        // Apply sensitivity for the sniper rifle\n        if (WeaponData != null && WeaponData.Sensitivity > 0)\n        {\n            float angleDiff = Mathf.Wrap(targetAngle - _currentAimAngle, -Mathf.Pi, Mathf.Pi);\n            float rotationSpeed = WeaponData.Sensitivity * 10.0f;\n            float delta = (float)GetProcessDeltaTime();\n            float maxRotation = rotationSpeed * delta;\n            float actualRotation = Mathf.Clamp(angleDiff, -maxRotation, maxRotation);\n            _currentAimAngle += actualRotation;\n            direction = new Vector2(Mathf.Cos(_currentAimAngle), Mathf.Sin(_currentAimAngle));\n        }\n        else\n        {\n            if (toMouse.LengthSquared() > 0.001f)\n            {\n                direction = toMouse.Normalized();\n                _currentAimAngle = targetAngle;\n            }\n            else\n            {\n                direction = _aimDirection;\n            }\n        }\n\n        _aimDirection = direction;\n        UpdateRifleSpriteRotation(direction);\n    }\n\n    /// <summary>\n    /// Creates the laser sight Line2D programmatically.\n    /// </summary>\n    private void CreateLaserSight()\n    {\n        _laserSight = new Line2D\n        {\n            Name = \"LaserSight\",\n            Width = LaserSightWidth,\n            DefaultColor = LaserSightColor,\n            BeginCapMode = Line2D.LineCapMode.Round,\n            EndCapMode = Line2D.LineCapMode.Round\n        };\n\n        _laserSight.AddPoint(Vector2.Zero);\n        _laserSight.AddPoint(Vector2.Right * LaserSightLength);\n\n        AddChild(_laserSight);\n    }\n\n    /// <summary>\n    /// Updates the laser sight visualization with recoil offset.\n    /// Uses raycasting to stop at obstacles.\n    /// </summary>\n    private void UpdateLaserSight()\n    {\n        if (_laserSight == null)\n        {\n            return;\n        }\n\n        Vector2 laserDirection = _aimDirection.Rotated(_recoilOffset);\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float maxLaserLength = viewportSize.Length();\n\n        Vector2 endPoint = laserDirection * maxLaserLength;\n\n        var spaceState = GetWorld2D().DirectSpaceState;\n        var query = PhysicsRayQueryParameters2D.Create(\n            GlobalPosition,\n            GlobalPosition + endPoint,\n            4 // Collision mask for obstacles (layer 3 = value 4)\n        );\n\n        var result = spaceState.IntersectRay(query);\n\n        if (result.Count > 0)\n        {\n            Vector2 hitPosition = (Vector2)result[\"position\"];\n            endPoint = hitPosition - GlobalPosition;\n        }\n\n        _laserSight.SetPointPosition(0, Vector2.Zero);\n        _laserSight.SetPointPosition(1, endPoint);\n    }\n\n    /// <summary>\n    /// Updates the visibility of the laser sight.\n    /// </summary>\n    private void UpdateLaserSightVisibility()\n    {\n        if (_laserSight != null)\n        {\n            _laserSight.Visible = LaserSightEnabled;\n        }\n    }\n\n    /// <summary>\n    /// Updates the rifle sprite rotation to match aim direction.\n    /// </summary>\n    private void UpdateRifleSpriteRotation(Vector2 direction)\n    {\n        if (_rifleSprite == null)\n        {\n            return;\n        }\n\n        float angle = direction.Angle();\n        _rifleSprite.Rotation = angle;\n\n        bool aimingLeft = Mathf.Abs(angle) > Mathf.Pi / 2;\n        _rifleSprite.FlipV = aimingLeft;\n    }\n\n    /// <summary>\n    /// Enables or disables the laser sight.\n    /// </summary>\n    public void SetLaserSightEnabled(bool enabled)\n    {\n        LaserSightEnabled = enabled;\n        UpdateLaserSightVisibility();\n    }\n\n    // =========================================================================\n    // Firing\n    // =========================================================================\n\n    /// <summary>\n    /// Fires the sniper rifle. Only fires if bolt is ready.\n    /// After firing, transitions to NeedsBoltCycle state.\n    /// </summary>\n    public override bool Fire(Vector2 direction)\n    {\n        // Check for empty magazine\n        if (CurrentAmmo <= 0)\n        {\n            PlayEmptyClickSound();\n            return false;\n        }\n\n        // Check if bolt is ready\n        if (!IsBoltReady)\n        {\n            // Play a click to indicate bolt not cycled\n            PlayEmptyClickSound();\n            return false;\n        }\n\n        // Check standard fire conditions\n        if (!CanFire || WeaponData == null || BulletScene == null)\n        {\n            return false;\n        }\n\n        // Apply recoil to aim direction\n        Vector2 spreadDirection = ApplyRecoil(_aimDirection);\n        bool result = base.Fire(spreadDirection);\n\n        if (result)\n        {\n            // Transition to needs bolt cycle\n            _boltStep = BoltActionStep.NeedsBoltCycle;\n            EmitSignal(SignalName.BoltStepChanged, 0, 4);\n\n            // Play sniper shot sound\n            PlaySniperShotSound();\n            // Emit gunshot sound for enemy detection\n            EmitGunshotSound();\n            // Play shell casing with delay\n            PlayShellCasingDelayed();\n            // Trigger heavy screen shake\n            TriggerScreenShake(spreadDirection);\n\n            // Spawn smoky tracer trail\n            SpawnSmokyTracer(GlobalPosition, spreadDirection);\n\n            GD.Print(\"[SniperRifle] FIRED! Bolt needs cycling. Ammo remaining: \" + CurrentAmmo);\n        }\n\n        return result;\n    }\n\n    /// <summary>\n    /// Override SpawnBullet to configure the SniperBullet for sniper behavior:\n    /// - Very high damage (50)\n    /// - Passes through enemies (doesn't destroy on hit)\n    /// - Penetrates through 2 walls (wall-count based, not distance-based)\n    /// </summary>\n    protected override void SpawnBullet(Vector2 direction)\n    {\n        if (BulletScene == null)\n        {\n            return;\n        }\n\n        // Check bullet spawn path\n        var (isBlocked, hitPosition, hitNormal) = CheckBulletSpawnPath(direction);\n\n        Vector2 spawnPosition;\n        if (isBlocked)\n        {\n            spawnPosition = GlobalPosition + direction * 2.0f;\n            GD.Print(\"[SniperRifle] Point-blank shot: spawning for penetration\");\n        }\n        else\n        {\n            spawnPosition = GlobalPosition + direction * BulletSpawnOffset;\n        }\n\n        var bulletNode = BulletScene.Instantiate<Node2D>();\n        bulletNode.GlobalPosition = spawnPosition;\n\n        // Try to cast to C# SniperBullet for direct property access\n        var sniperBullet = bulletNode as SniperBullet;\n\n        if (sniperBullet != null)\n        {\n            // SniperBullet - set properties directly\n            sniperBullet.Direction = direction;\n            if (WeaponData != null)\n            {\n                sniperBullet.Speed = WeaponData.BulletSpeed;\n                sniperBullet.Damage = WeaponData.Damage;\n            }\n            var owner = GetParent();\n            if (owner != null)\n            {\n                sniperBullet.ShooterId = owner.GetInstanceId();\n            }\n            sniperBullet.ShooterPosition = GlobalPosition;\n            sniperBullet.MaxWallPenetrations = MaxWallPenetrations;\n            GD.Print($\"[SniperRifle] Spawned SniperBullet: Damage={sniperBullet.Damage}, Speed={sniperBullet.Speed}, MaxWallPen={MaxWallPenetrations}\");\n        }\n        else\n        {\n            // Fallback for any bullet type\n            if (bulletNode.HasMethod(\"SetDirection\"))\n            {\n                bulletNode.Call(\"SetDirection\", direction);\n            }\n            else\n            {\n                bulletNode.Set(\"Direction\", direction);\n                bulletNode.Set(\"direction\", direction);\n            }\n\n            if (WeaponData != null)\n            {\n                bulletNode.Set(\"Speed\", WeaponData.BulletSpeed);\n                bulletNode.Set(\"speed\", WeaponData.BulletSpeed);\n                bulletNode.Set(\"Damage\", WeaponData.Damage);\n                bulletNode.Set(\"damage\", WeaponData.Damage);\n            }\n\n            var owner = GetParent();\n            if (owner != null)\n            {\n                bulletNode.Set(\"ShooterId\", owner.GetInstanceId());\n                bulletNode.Set(\"shooter_id\", owner.GetInstanceId());\n            }\n\n            bulletNode.Set(\"ShooterPosition\", GlobalPosition);\n            bulletNode.Set(\"shooter_position\", GlobalPosition);\n        }\n\n        GetTree().CurrentScene.AddChild(bulletNode);\n\n        // Spawn muzzle flash effect - large flash for 12.7mm\n        SpawnMuzzleFlash(spawnPosition, direction, WeaponData?.Caliber);\n\n        // Spawn casing\n        SpawnCasing(direction, WeaponData?.Caliber);\n    }\n\n    // =========================================================================\n    // Smoky Tracer Trail\n    // =========================================================================\n\n    /// <summary>\n    /// Spawns a smoky dissipating tracer trail from the fire position\n    /// in the shooting direction across the entire map.\n    /// The tracer is an instant visual effect (like a contrail from a plane)\n    /// that fades out over time.\n    /// </summary>\n    private void SpawnSmokyTracer(Vector2 fromPosition, Vector2 direction)\n    {\n        // Calculate tracer end point - extend to edge of map (very far)\n        float tracerLength = 5000.0f; // Far enough to reach any map edge\n        Vector2 endPosition = fromPosition + direction * tracerLength;\n\n        // Create the tracer as a Line2D with smoke-like appearance\n        var tracer = new Line2D\n        {\n            Name = \"SniperTracer\",\n            Width = 6.0f,\n            DefaultColor = new Color(0.8f, 0.8f, 0.8f, 0.7f),\n            BeginCapMode = Line2D.LineCapMode.Round,\n            EndCapMode = Line2D.LineCapMode.Round,\n            TopLevel = true,\n            Position = Vector2.Zero,\n            ZIndex = -1 // Behind other elements\n        };\n\n        // Set up width curve - wider at start, tapers to narrower at end\n        var widthCurve = new Curve();\n        widthCurve.AddPoint(new Vector2(0.0f, 1.0f));\n        widthCurve.AddPoint(new Vector2(0.3f, 0.8f));\n        widthCurve.AddPoint(new Vector2(1.0f, 0.3f));\n        tracer.WidthCurve = widthCurve;\n\n        // Set up gradient - smoky white/gray that fades out\n        var gradient = new Gradient();\n        gradient.SetColor(0, new Color(0.9f, 0.9f, 0.85f, 0.8f));\n        gradient.AddPoint(0.5f, new Color(0.7f, 0.7f, 0.65f, 0.5f));\n        gradient.SetColor(gradient.GetPointCount() - 1, new Color(0.5f, 0.5f, 0.5f, 0.2f));\n        tracer.Gradient = gradient;\n\n        // Add the tracer line points (using global coordinates since TopLevel=true)\n        tracer.AddPoint(fromPosition + direction * BulletSpawnOffset);\n        tracer.AddPoint(endPosition);\n\n        // Add to scene\n        GetTree().CurrentScene.AddChild(tracer);\n\n        // Start the fade-out animation\n        FadeOutTracer(tracer);\n    }\n\n    /// <summary>\n    /// Animates the tracer trail fading out and dissipating over time.\n    /// The tracer gradually becomes more transparent and wider (simulating smoke dissipation).\n    /// </summary>\n    private async void FadeOutTracer(Line2D tracer)\n    {\n        float fadeDuration = 2.0f;\n        float elapsed = 0.0f;\n\n        float initialWidth = tracer.Width;\n\n        while (elapsed < fadeDuration && IsInstanceValid(tracer))\n        {\n            elapsed += (float)GetProcessDeltaTime();\n            float progress = elapsed / fadeDuration;\n\n            // Fade the alpha\n            float alpha = Mathf.Lerp(0.7f, 0.0f, progress);\n            tracer.DefaultColor = new Color(0.8f, 0.8f, 0.8f, alpha);\n\n            // Widen slightly to simulate smoke dissipation\n            tracer.Width = initialWidth + progress * 4.0f;\n\n            // Update gradient alpha\n            var gradient = new Gradient();\n            gradient.SetColor(0, new Color(0.9f, 0.9f, 0.85f, alpha));\n            gradient.AddPoint(0.5f, new Color(0.7f, 0.7f, 0.65f, alpha * 0.6f));\n            gradient.SetColor(gradient.GetPointCount() - 1, new Color(0.5f, 0.5f, 0.5f, alpha * 0.3f));\n            tracer.Gradient = gradient;\n\n            await ToSignal(GetTree(), \"process_frame\");\n        }\n\n        // Remove the tracer after fade completes\n        if (IsInstanceValid(tracer))\n        {\n            tracer.QueueFree();\n        }\n    }\n\n    // =========================================================================\n    // Sound and Effects\n    // =========================================================================\n\n    /// <summary>\n    /// Plays the sniper shot sound via AudioManager.\n    /// </summary>\n    private void PlaySniperShotSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        // Use M16 shot as a placeholder sound for the sniper\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_shot\"))\n        {\n            audioManager.Call(\"play_m16_shot\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Plays the empty gun click sound.\n    /// </summary>\n    private void PlayEmptyClickSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_empty_click\"))\n        {\n            audioManager.Call(\"play_empty_click\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Emits gunshot sound for enemy detection via SoundPropagation.\n    /// Very loud for the 12.7mm round.\n    /// </summary>\n    private void EmitGunshotSound()\n    {\n        var soundPropagation = GetNodeOrNull(\"/root/SoundPropagation\");\n        if (soundPropagation != null && soundPropagation.HasMethod(\"emit_sound\"))\n        {\n            float loudness = WeaponData?.Loudness ?? 3000.0f;\n            soundPropagation.Call(\"emit_sound\", 0, GlobalPosition, 0, this, loudness);\n        }\n    }\n\n    /// <summary>\n    /// Plays shell casing sound with a delay.\n    /// </summary>\n    private async void PlayShellCasingDelayed()\n    {\n        await ToSignal(GetTree().CreateTimer(0.2), \"timeout\");\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_shell_rifle\"))\n        {\n            audioManager.Call(\"play_shell_rifle\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Applies recoil to shooting direction.\n    /// </summary>\n    private Vector2 ApplyRecoil(Vector2 direction)\n    {\n        // Apply current recoil offset\n        Vector2 result = direction.Rotated(_recoilOffset);\n\n        // Add strong recoil for next shot (heavy 12.7mm kick)\n        float recoilDirection = (float)GD.RandRange(-1.0, 1.0);\n        _recoilOffset += recoilDirection * RecoilPerShot;\n        _recoilOffset = Mathf.Clamp(_recoilOffset, -MaxRecoilOffset, MaxRecoilOffset);\n\n        _timeSinceLastShot = 0;\n\n        return result;\n    }\n\n    /// <summary>\n    /// Triggers screen shake from sniper shot.\n    /// Heavy shake for 12.7mm round.\n    /// </summary>\n    private void TriggerScreenShake(Vector2 shootDirection)\n    {\n        if (WeaponData == null || WeaponData.ScreenShakeIntensity <= 0)\n        {\n            return;\n        }\n\n        var screenShakeManager = GetNodeOrNull(\"/root/ScreenShakeManager\");\n        if (screenShakeManager == null || !screenShakeManager.HasMethod(\"add_shake\"))\n        {\n            return;\n        }\n\n        // Heavy shake for sniper\n        float fireRate = WeaponData.FireRate;\n        float shakeIntensity;\n        if (fireRate > 0)\n        {\n            shakeIntensity = WeaponData.ScreenShakeIntensity / fireRate * 10.0f;\n        }\n        else\n        {\n            shakeIntensity = WeaponData.ScreenShakeIntensity;\n        }\n\n        float recoveryTime = WeaponData.ScreenShakeMinRecoveryTime;\n\n        screenShakeManager.Call(\"add_shake\", shootDirection, shakeIntensity, recoveryTime);\n    }\n\n    /// <summary>\n    /// Fires the bullet in the chamber during reload sequence.\n    /// </summary>\n    public override bool FireChamberBullet(Vector2 direction)\n    {\n        // Sniper rifle doesn't support chamber bullet during reload\n        // (bolt-action requires full cycle)\n        return false;\n    }\n\n    /// <summary>\n    /// Gets the current aim direction.\n    /// </summary>\n    public Vector2 AimDirection => _aimDirection;\n\n    /// <summary>\n    /// Gets the current bolt-action step.\n    /// </summary>\n    public BoltActionStep CurrentBoltStep => _boltStep;\n\n    /// <summary>\n    /// Resets the bolt to ready state (e.g., after reload with a new magazine).\n    /// </summary>\n    public void ResetBolt()\n    {\n        _boltStep = BoltActionStep.Ready;\n        EmitSignal(SignalName.BoltStepChanged, 4, 4);\n        GD.Print(\"[SniperRifle] Bolt reset to ready state\");\n    }\n\n    // =========================================================================\n    // Scope / Aiming System (RMB)\n    // =========================================================================\n\n    /// <summary>\n    /// Whether the scope is currently active (RMB held).\n    /// </summary>\n    private bool _isScopeActive = false;\n\n    /// <summary>\n    /// Whether the scope is active (read-only property for external access).\n    /// </summary>\n    public bool IsScopeActive => _isScopeActive;\n\n    /// <summary>\n    /// Signal emitted when scope state changes.\n    /// </summary>\n    [Signal]\n    public delegate void ScopeStateChangedEventHandler(bool isActive);\n\n    /// <summary>\n    /// Current scope zoom distance multiplier (how far beyond viewport the player can see).\n    /// 1.0 = one viewport distance, 2.0 = two viewport distances.\n    /// Controlled by mouse wheel while scoping.\n    /// </summary>\n    private float _scopeZoomDistance = 1.0f;\n\n    /// <summary>\n    /// Minimum scope zoom distance (viewport multiplier).\n    /// Set to 1.0 so the scope always looks beyond the normal viewport.\n    /// </summary>\n    private const float MinScopeZoomDistance = 1.0f;\n\n    /// <summary>\n    /// Maximum scope zoom distance (viewport multiplier).\n    /// </summary>\n    private const float MaxScopeZoomDistance = 3.0f;\n\n    /// <summary>\n    /// Step size for mouse wheel zoom adjustment.\n    /// </summary>\n    private const float ScopeZoomStep = 0.25f;\n\n    /// <summary>\n    /// Base sway amplitude in pixels at 1 viewport distance.\n    /// </summary>\n    private const float BaseScopeSwayAmplitude = 8.0f;\n\n    /// <summary>\n    /// Speed of the sway oscillation.\n    /// </summary>\n    private const float ScopeSwaySpeed = 2.5f;\n\n    /// <summary>\n    /// Maximum range (in viewport fraction) that the player can fine-tune the scope\n    /// distance via mouse movement while scoped. About 1/3 of the viewport.\n    /// </summary>\n    private const float ScopeMouseFineTuneRange = 0.33f;\n\n    /// <summary>\n    /// Current mouse fine-tune offset applied to scope distance.\n    /// Ranges from -ScopeMouseFineTuneRange to +ScopeMouseFineTuneRange (viewport fraction).\n    /// Positive = further, negative = closer.\n    /// </summary>\n    private float _scopeMouseFineTuneOffset = 0.0f;\n\n    /// <summary>\n    /// Current scope sway time accumulator.\n    /// </summary>\n    private float _scopeSwayTime = 0.0f;\n\n    /// <summary>\n    /// Current scope sway offset in pixels (applied to camera).\n    /// </summary>\n    private Vector2 _scopeSwayOffset = Vector2.Zero;\n\n    /// <summary>\n    /// Reference to the scope overlay CanvasLayer (created when scope activates).\n    /// </summary>\n    private CanvasLayer? _scopeOverlay = null;\n\n    /// <summary>\n    /// Reference to the scope crosshair control node.\n    /// </summary>\n    private Control? _scopeCrosshair = null;\n\n    /// <summary>\n    /// Reference to the scope darkening background.\n    /// </summary>\n    private ColorRect? _scopeBackground = null;\n\n    /// <summary>\n    /// Cached reference to the player's Camera2D node.\n    /// </summary>\n    private Camera2D? _playerCamera = null;\n\n    /// <summary>\n    /// Original camera offset before scoping (to restore on exit).\n    /// </summary>\n    private Vector2 _originalCameraOffset = Vector2.Zero;\n\n    /// <summary>\n    /// Gets the effective scope zoom distance including mouse fine-tune offset.\n    /// </summary>\n    private float EffectiveScopeZoomDistance => _scopeZoomDistance + _scopeMouseFineTuneOffset;\n\n    /// <summary>\n    /// Gets the current camera offset for scope aiming.\n    /// Called by the player or level scripts to position the camera.\n    /// </summary>\n    public Vector2 GetScopeCameraOffset()\n    {\n        if (!_isScopeActive)\n        {\n            return Vector2.Zero;\n        }\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return Vector2.Zero;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float baseDistance = viewportSize.Length() * 0.5f;\n\n        // Camera offset = aim direction * (zoom distance + mouse fine-tune) * viewport size + sway\n        Vector2 offset = _aimDirection * baseDistance * EffectiveScopeZoomDistance + _scopeSwayOffset;\n\n        return offset;\n    }\n\n    /// <summary>\n    /// Gets the world-space position that the scope crosshair center is aiming at.\n    /// Used to direct bullets to the crosshair center.\n    /// </summary>\n    public Vector2 GetScopeAimTarget()\n    {\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return GlobalPosition + _aimDirection * 1000.0f;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float baseDistance = viewportSize.Length() * 0.5f;\n\n        // The scope aim target is the player's position offset by the scope camera offset\n        // (without sway, so bullets go to the true center, not the swaying crosshair)\n        Vector2 aimTarget = GlobalPosition + _aimDirection * baseDistance * EffectiveScopeZoomDistance;\n\n        return aimTarget;\n    }\n\n    /// <summary>\n    /// Activates the scope (called when RMB is pressed).\n    /// </summary>\n    public void ActivateScope()\n    {\n        if (_isScopeActive)\n        {\n            return;\n        }\n\n        _isScopeActive = true;\n        _scopeSwayTime = 0.0f;\n\n        // Find and cache the player's Camera2D\n        FindPlayerCamera();\n\n        // Store original camera offset\n        if (_playerCamera != null)\n        {\n            _originalCameraOffset = _playerCamera.Offset;\n        }\n\n        // Create the scope overlay\n        CreateScopeOverlay();\n\n        EmitSignal(SignalName.ScopeStateChanged, true);\n        GD.Print($\"[SniperRifle] Scope activated. Zoom distance: {_scopeZoomDistance:F1}x\");\n    }\n\n    /// <summary>\n    /// Deactivates the scope (called when RMB is released).\n    /// </summary>\n    public void DeactivateScope()\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        _isScopeActive = false;\n\n        // Restore original camera offset\n        if (_playerCamera != null)\n        {\n            _playerCamera.Offset = _originalCameraOffset;\n        }\n\n        // Remove scope overlay\n        RemoveScopeOverlay();\n\n        EmitSignal(SignalName.ScopeStateChanged, false);\n        GD.Print(\"[SniperRifle] Scope deactivated.\");\n    }\n\n    /// <summary>\n    /// Adjusts the scope zoom distance (called on mouse wheel while scoping).\n    /// </summary>\n    public void AdjustScopeZoom(float direction)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        _scopeZoomDistance += direction * ScopeZoomStep;\n        _scopeZoomDistance = Mathf.Clamp(_scopeZoomDistance, MinScopeZoomDistance, MaxScopeZoomDistance);\n\n        GD.Print($\"[SniperRifle] Scope zoom adjusted: {_scopeZoomDistance:F2}x\");\n    }\n\n    /// <summary>\n    /// Finds the player's Camera2D node by traversing up to the parent (player).\n    /// </summary>\n    private void FindPlayerCamera()\n    {\n        if (_playerCamera != null)\n        {\n            return;\n        }\n\n        var parent = GetParent();\n        if (parent != null)\n        {\n            _playerCamera = parent.GetNodeOrNull<Camera2D>(\"Camera2D\");\n        }\n    }\n\n    /// <summary>\n    /// Updates the scope system each frame (called from _Process).\n    /// </summary>\n    private void UpdateScope(float delta)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        // Update sway\n        _scopeSwayTime += delta;\n        float swayAmplitude = BaseScopeSwayAmplitude * _scopeZoomDistance;\n\n        // Use two sine waves at different frequencies for natural-looking sway\n        float swayX = Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 1.0f) * swayAmplitude\n                    + Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 2.3f) * swayAmplitude * 0.3f;\n        float swayY = Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 1.4f) * swayAmplitude\n                    + Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 0.7f) * swayAmplitude * 0.4f;\n\n        _scopeSwayOffset = new Vector2(swayX, swayY);\n\n        // Update camera offset for scope view\n        if (_playerCamera != null)\n        {\n            _playerCamera.Offset = _originalCameraOffset + GetScopeCameraOffset();\n        }\n\n        // Update scope overlay crosshair position with sway\n        UpdateScopeOverlayPosition();\n    }\n\n    /// <summary>\n    /// Creates the scope overlay UI with crosshair and darkened edges.\n    /// </summary>\n    private void CreateScopeOverlay()\n    {\n        RemoveScopeOverlay();\n\n        _scopeOverlay = new CanvasLayer\n        {\n            Name = \"ScopeOverlay\",\n            Layer = 10\n        };\n\n        Viewport? viewport = GetViewport();\n        Vector2 viewportSize = viewport?.GetVisibleRect().Size ?? new Vector2(1280, 720);\n\n        // Dark background with circular cutout effect (vignette)\n        _scopeBackground = new ColorRect\n        {\n            Name = \"ScopeBackground\",\n            Color = new Color(0.0f, 0.0f, 0.0f, 0.5f),\n            Size = viewportSize,\n            Position = Vector2.Zero,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        _scopeOverlay.AddChild(_scopeBackground);\n\n        // Create the crosshair as a Control node\n        _scopeCrosshair = new Control\n        {\n            Name = \"ScopeCrosshair\",\n            Position = viewportSize / 2,\n            Size = Vector2.Zero,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        _scopeOverlay.AddChild(_scopeCrosshair);\n\n        // Add crosshair lines - based on the reference image from the issue\n        // The scope has a classic crosshair with circle and mil-dots\n\n        // Outer circle\n        float circleRadius = Mathf.Min(viewportSize.X, viewportSize.Y) * 0.35f;\n        int segments = 64;\n        var outerCircle = new Line2D\n        {\n            Name = \"OuterCircle\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f),\n            Antialiased = true\n        };\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            outerCircle.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * circleRadius);\n        }\n        _scopeCrosshair.AddChild(outerCircle);\n\n        // Inner thin circle\n        float innerRadius = circleRadius * 0.05f;\n        var innerCircle = new Line2D\n        {\n            Name = \"InnerCircle\",\n            Width = 1.5f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f),\n            Antialiased = true\n        };\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            innerCircle.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * innerRadius);\n        }\n        _scopeCrosshair.AddChild(innerCircle);\n\n        // Horizontal crosshair line (left)\n        var hLineLeft = new Line2D\n        {\n            Name = \"HLineLeft\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        hLineLeft.AddPoint(new Vector2(-circleRadius, 0));\n        hLineLeft.AddPoint(new Vector2(-innerRadius, 0));\n        _scopeCrosshair.AddChild(hLineLeft);\n\n        // Horizontal crosshair line (right)\n        var hLineRight = new Line2D\n        {\n            Name = \"HLineRight\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        hLineRight.AddPoint(new Vector2(innerRadius, 0));\n        hLineRight.AddPoint(new Vector2(circleRadius, 0));\n        _scopeCrosshair.AddChild(hLineRight);\n\n        // Vertical crosshair line (top)\n        var vLineTop = new Line2D\n        {\n            Name = \"VLineTop\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        vLineTop.AddPoint(new Vector2(0, -circleRadius));\n        vLineTop.AddPoint(new Vector2(0, -innerRadius));\n        _scopeCrosshair.AddChild(vLineTop);\n\n        // Vertical crosshair line (bottom) with mil-dots\n        var vLineBottom = new Line2D\n        {\n            Name = \"VLineBottom\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        vLineBottom.AddPoint(new Vector2(0, innerRadius));\n        vLineBottom.AddPoint(new Vector2(0, circleRadius));\n        _scopeCrosshair.AddChild(vLineBottom);\n\n        // Add mil-dot markers on the bottom crosshair (range estimation)\n        float dotSpacing = circleRadius * 0.15f;\n        for (int i = 1; i <= 4; i++)\n        {\n            float dotY = dotSpacing * i;\n            var dot = new Line2D\n            {\n                Name = $\"MilDot_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            float dotWidth = 4.0f - i * 0.5f; // Dots get smaller further from center\n            dot.AddPoint(new Vector2(-dotWidth, dotY));\n            dot.AddPoint(new Vector2(dotWidth, dotY));\n            _scopeCrosshair.AddChild(dot);\n        }\n\n        // Add mil-dot markers on horizontal lines\n        for (int i = 1; i <= 3; i++)\n        {\n            float dotX = dotSpacing * i;\n            // Right side dots\n            var dotRight = new Line2D\n            {\n                Name = $\"HMilDotRight_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            float dotHeight = 4.0f - i * 0.5f;\n            dotRight.AddPoint(new Vector2(dotX, -dotHeight));\n            dotRight.AddPoint(new Vector2(dotX, dotHeight));\n            _scopeCrosshair.AddChild(dotRight);\n\n            // Left side dots\n            var dotLeft = new Line2D\n            {\n                Name = $\"HMilDotLeft_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            dotLeft.AddPoint(new Vector2(-dotX, -dotHeight));\n            dotLeft.AddPoint(new Vector2(-dotX, dotHeight));\n            _scopeCrosshair.AddChild(dotLeft);\n        }\n\n        // Add thick outer ring to mask edges (simulate scope tube)\n        var scopeRing = new Line2D\n        {\n            Name = \"ScopeRing\",\n            Width = 6.0f,\n            DefaultColor = new Color(0.1f, 0.1f, 0.1f, 0.95f),\n            Antialiased = true\n        };\n        float ringRadius = circleRadius + 3.0f;\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            scopeRing.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * ringRadius);\n        }\n        _scopeCrosshair.AddChild(scopeRing);\n\n        // Zoom distance indicator text\n        var zoomLabel = new Label\n        {\n            Name = \"ZoomLabel\",\n            Position = new Vector2(circleRadius * 0.5f, circleRadius * 0.7f),\n            Text = $\"{_scopeZoomDistance:F1}x\",\n            HorizontalAlignment = HorizontalAlignment.Center,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        zoomLabel.AddThemeColorOverride(\"font_color\", new Color(0.0f, 0.0f, 0.0f, 0.6f));\n        zoomLabel.AddThemeFontSizeOverride(\"font_size\", 12);\n        _scopeCrosshair.AddChild(zoomLabel);\n\n        GetTree().CurrentScene.AddChild(_scopeOverlay);\n    }\n\n    /// <summary>\n    /// Updates the scope overlay crosshair position with sway applied.\n    /// </summary>\n    private void UpdateScopeOverlayPosition()\n    {\n        if (_scopeCrosshair == null || _scopeOverlay == null)\n        {\n            return;\n        }\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n\n        // Crosshair stays centered but sways\n        _scopeCrosshair.Position = viewportSize / 2 + _scopeSwayOffset;\n\n        // Update zoom label\n        var zoomLabel = _scopeCrosshair.GetNodeOrNull<Label>(\"ZoomLabel\");\n        if (zoomLabel != null)\n        {\n            zoomLabel.Text = $\"{_scopeZoomDistance:F1}x\";\n        }\n    }\n\n    /// <summary>\n    /// Removes the scope overlay from the scene.\n    /// </summary>\n    private void RemoveScopeOverlay()\n    {\n        if (_scopeOverlay != null && IsInstanceValid(_scopeOverlay))\n        {\n            _scopeOverlay.QueueFree();\n            _scopeOverlay = null;\n            _scopeCrosshair = null;\n            _scopeBackground = null;\n        }\n    }\n}\n",
    "structuredPatch": [
      {
        "oldStart": 1116,
        "oldLines": 10,
        "newStart": 1116,
        "newLines": 38,
        "lines": [
          "         _scopeZoomDistance += direction * ScopeZoomStep;",
          "         _scopeZoomDistance = Mathf.Clamp(_scopeZoomDistance, MinScopeZoomDistance, MaxScopeZoomDistance);",
          " ",
          "-        GD.Print($\"[SniperRifle] Scope zoom adjusted: {_scopeZoomDistance:F2}x\");",
          "+        // Reset fine-tune offset when zoom changes to avoid going out of range",
          "+        _scopeMouseFineTuneOffset = Mathf.Clamp(_scopeMouseFineTuneOffset,",
          "+            -ScopeMouseFineTuneRange, ScopeMouseFineTuneRange);",
          "+",
          "+        GD.Print($\"[SniperRifle] Scope zoom adjusted: {_scopeZoomDistance:F2}x (fine-tune: {_scopeMouseFineTuneOffset:F2})\");",
          "     }",
          " ",
          "     /// <summary>",
          "+    /// Adjusts the scope fine-tune offset based on mouse movement along the aim direction.",
          "+    /// Allows the player to look slightly closer or further (about 1/3 viewport range).",
          "+    /// Called from Player.cs when mouse moves while scoped.",
          "+    /// </summary>",
          "+    public void AdjustScopeFineTune(Vector2 mouseMotion)",
          "+    {",
          "+        if (!_isScopeActive)",
          "+        {",
          "+            return;",
          "+        }",
          "+",
          "+        // Project mouse motion onto the aim direction to get forward/backward movement",
          "+        // Moving mouse in the aim direction = further, opposite = closer",
          "+        float projection = mouseMotion.Dot(_aimDirection);",
          "+",
          "+        // Scale the projection: mouse sensitivity for scope fine-tuning",
          "+        // A moderate movement across the screen should give the full range",
          "+        float sensitivity = 0.002f;",
          "+        _scopeMouseFineTuneOffset += projection * sensitivity;",
          "+        _scopeMouseFineTuneOffset = Mathf.Clamp(_scopeMouseFineTuneOffset,",
          "+            -ScopeMouseFineTuneRange, ScopeMouseFineTuneRange);",
          "+    }",
          "+",
          "+    /// <summary>",
          "     /// Finds the player's Camera2D node by traversing up to the parent (player).",
          "     /// </summary>",
          "     private void FindPlayerCamera()"
        ]
      }
    ],
    "userModified": false,
    "replaceAll": false
  }
}
[2026-02-06T20:57:39.885Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01SDaUxU2EfpAJmq8EZ2iNVS",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now reset the fine-tune offset when the scope activates:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 903,
      "cache_read_input_tokens": 60437,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 903
      },
      "output_tokens": 2,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "407d7d2c-df5f-4eec-9b85-43abd352cc62"
}
[2026-02-06T20:57:41.406Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01SDaUxU2EfpAJmq8EZ2iNVS",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01JvJDNaFvT1FxsfwzrfYFX1",
        "name": "Edit",
        "input": {
          "replace_all": false,
          "file_path": "/tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs",
          "old_string": "        _isScopeActive = true;\n        _scopeSwayTime = 0.0f;",
          "new_string": "        _isScopeActive = true;\n        _scopeSwayTime = 0.0f;\n        _scopeMouseFineTuneOffset = 0.0f;"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 903,
      "cache_read_input_tokens": 60437,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 903
      },
      "output_tokens": 2,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "51f51a15-7cd2-402a-a1fb-32b24b6aa127"
}
[2026-02-06T20:57:41.416Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01JvJDNaFvT1FxsfwzrfYFX1",
        "type": "tool_result",
        "content": "The file /tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs has been updated successfully."
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "e2c86853-8d07-4684-b74c-ecd9f34fdc7d",
  "tool_use_result": {
    "filePath": "/tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs",
    "oldString": "        _isScopeActive = true;\n        _scopeSwayTime = 0.0f;",
    "newString": "        _isScopeActive = true;\n        _scopeSwayTime = 0.0f;\n        _scopeMouseFineTuneOffset = 0.0f;",
    "originalFile": "using Godot;\nusing GodotTopDownTemplate.AbstractClasses;\nusing GodotTopDownTemplate.Projectiles;\n\nnamespace GodotTopDownTemplate.Weapons;\n\n/// <summary>\n/// Bolt-action charging state for the ASVK sniper rifle.\n/// Before each shot, the player must complete a 4-step bolt-action sequence:\n/// Down (pull bolt back) ‚Üí Left (open bolt) ‚Üí Down (close bolt) ‚Üí Up (chamber round)\n/// </summary>\npublic enum BoltActionStep\n{\n    /// <summary>\n    /// Bolt is ready - weapon can fire. After firing, transitions to NeedsBoltCycle.\n    /// </summary>\n    Ready,\n\n    /// <summary>\n    /// Just fired - needs bolt cycling before next shot.\n    /// Waiting for Down arrow (pull bolt back).\n    /// </summary>\n    NeedsBoltCycle,\n\n    /// <summary>\n    /// Step 1 complete (bolt pulled back). Waiting for Left arrow (open bolt).\n    /// </summary>\n    WaitOpenBolt,\n\n    /// <summary>\n    /// Step 2 complete (bolt opened). Waiting for Down arrow (close bolt).\n    /// </summary>\n    WaitCloseBolt,\n\n    /// <summary>\n    /// Step 3 complete (bolt closed). Waiting for Up arrow (chamber round).\n    /// </summary>\n    WaitChamberRound\n}\n\n/// <summary>\n/// ASVK sniper rifle - heavy anti-materiel bolt-action rifle.\n/// Features:\n/// - 12.7x108mm ammunition dealing 50 damage per shot\n/// - Penetrates through 2 walls and through enemies\n/// - Instant bullet speed with smoky dissipating tracer trail\n/// - Very high turn sensitivity\n/// - 5-round magazine with M16-style swap reload\n/// - Single-shot bolt-action with manual charging sequence (Down‚ÜíLeft‚ÜíDown‚ÜíUp)\n/// - Red laser sight for aiming\n/// Reference: ASVK (–ê–°–í–ö) anti-materiel sniper rifle\n/// </summary>\npublic partial class SniperRifle : BaseWeapon\n{\n    // =========================================================================\n    // Bolt-Action State\n    // =========================================================================\n\n    /// <summary>\n    /// Current bolt-action charging step.\n    /// </summary>\n    private BoltActionStep _boltStep = BoltActionStep.Ready;\n\n    /// <summary>\n    /// Whether the bolt action is ready to fire (chambered).\n    /// Initially true so first shot can be fired immediately.\n    /// </summary>\n    public bool IsBoltReady => _boltStep == BoltActionStep.Ready;\n\n    /// <summary>\n    /// Whether the weapon needs bolt cycling before it can fire again.\n    /// </summary>\n    public bool NeedsBoltCycle => _boltStep != BoltActionStep.Ready;\n\n    /// <summary>\n    /// Signal emitted when bolt-action step changes.\n    /// </summary>\n    [Signal]\n    public delegate void BoltStepChangedEventHandler(int step, int totalSteps);\n\n    // =========================================================================\n    // Smoky Tracer Trail\n    // =========================================================================\n\n    /// <summary>\n    /// Scene for the smoky tracer trail effect.\n    /// Created programmatically as a Line2D with smoke-like appearance.\n    /// </summary>\n    private Line2D? _lastTracerTrail;\n\n    // =========================================================================\n    // Laser Sight Configuration\n    // =========================================================================\n\n    /// <summary>\n    /// Whether the laser sight is enabled.\n    /// </summary>\n    [Export]\n    public bool LaserSightEnabled { get; set; } = true;\n\n    /// <summary>\n    /// Maximum length of the laser sight in pixels.\n    /// </summary>\n    [Export]\n    public float LaserSightLength { get; set; } = 500.0f;\n\n    /// <summary>\n    /// Color of the laser sight (red for sniper).\n    /// </summary>\n    [Export]\n    public Color LaserSightColor { get; set; } = new Color(1.0f, 0.0f, 0.0f, 0.5f);\n\n    /// <summary>\n    /// Width of the laser sight line.\n    /// </summary>\n    [Export]\n    public float LaserSightWidth { get; set; } = 2.0f;\n\n    /// <summary>\n    /// Reference to the Line2D node for the laser sight.\n    /// </summary>\n    private Line2D? _laserSight;\n\n    /// <summary>\n    /// Reference to the Sprite2D node for the rifle visual.\n    /// </summary>\n    private Sprite2D? _rifleSprite;\n\n    /// <summary>\n    /// Current aim direction based on laser sight.\n    /// </summary>\n    private Vector2 _aimDirection = Vector2.Right;\n\n    /// <summary>\n    /// Current aim angle in radians.\n    /// </summary>\n    private float _currentAimAngle = 0.0f;\n\n    /// <summary>\n    /// Whether the aim angle has been initialized.\n    /// </summary>\n    private bool _aimAngleInitialized = false;\n\n    /// <summary>\n    /// Current recoil offset angle in radians.\n    /// Heavy sniper recoil.\n    /// </summary>\n    private float _recoilOffset = 0.0f;\n\n    /// <summary>\n    /// Time since the last shot was fired, used for recoil recovery.\n    /// </summary>\n    private float _timeSinceLastShot = 0.0f;\n\n    /// <summary>\n    /// Time in seconds before recoil starts recovering.\n    /// Long delay for heavy sniper.\n    /// </summary>\n    private const float RecoilRecoveryDelay = 0.5f;\n\n    /// <summary>\n    /// Speed at which recoil recovers (radians per second).\n    /// </summary>\n    private const float RecoilRecoverySpeed = 3.0f;\n\n    /// <summary>\n    /// Maximum recoil offset in radians (about 15 degrees).\n    /// </summary>\n    private const float MaxRecoilOffset = 0.26f;\n\n    /// <summary>\n    /// Recoil amount per shot in radians.\n    /// Heavy kick for 12.7mm.\n    /// </summary>\n    private const float RecoilPerShot = 0.15f;\n\n    /// <summary>\n    /// Number of walls this bullet can penetrate through.\n    /// The bullet continues flying after penetrating walls.\n    /// </summary>\n    private const int MaxWallPenetrations = 2;\n\n    public override void _Ready()\n    {\n        base._Ready();\n\n        // Get the rifle sprite for visual representation\n        _rifleSprite = GetNodeOrNull<Sprite2D>(\"RifleSprite\");\n\n        if (_rifleSprite != null)\n        {\n            var texture = _rifleSprite.Texture;\n            GD.Print($\"[SniperRifle] RifleSprite found: visible={_rifleSprite.Visible}, z_index={_rifleSprite.ZIndex}, texture={(texture != null ? \"loaded\" : \"NULL\")}\");\n        }\n        else\n        {\n            GD.PrintErr(\"[SniperRifle] WARNING: RifleSprite node not found!\");\n        }\n\n        // Check for Power Fantasy mode blue laser\n        var difficultyManager = GetNodeOrNull(\"/root/DifficultyManager\");\n        if (difficultyManager != null)\n        {\n            var shouldForceBlueLaser = difficultyManager.Call(\"should_force_blue_laser_sight\");\n            if (shouldForceBlueLaser.AsBool())\n            {\n                var blueColorVariant = difficultyManager.Call(\"get_power_fantasy_laser_color\");\n                LaserSightColor = blueColorVariant.AsColor();\n                GD.Print($\"[SniperRifle] Power Fantasy mode: laser color set to blue {LaserSightColor}\");\n            }\n        }\n\n        // Get or create the laser sight Line2D\n        _laserSight = GetNodeOrNull<Line2D>(\"LaserSight\");\n\n        if (_laserSight == null && LaserSightEnabled)\n        {\n            CreateLaserSight();\n        }\n        else if (_laserSight != null)\n        {\n            _laserSight.Width = LaserSightWidth;\n            _laserSight.DefaultColor = LaserSightColor;\n            _laserSight.BeginCapMode = Line2D.LineCapMode.Round;\n            _laserSight.EndCapMode = Line2D.LineCapMode.Round;\n\n            if (_laserSight.GetPointCount() < 2)\n            {\n                _laserSight.ClearPoints();\n                _laserSight.AddPoint(Vector2.Zero);\n                _laserSight.AddPoint(Vector2.Right * LaserSightLength);\n            }\n        }\n\n        UpdateLaserSightVisibility();\n        GD.Print(\"[SniperRifle] ASVK initialized - bolt ready, laser sight enabled\");\n    }\n\n    public override void _ExitTree()\n    {\n        // Clean up scope overlay when weapon is removed from scene tree\n        if (_isScopeActive)\n        {\n            DeactivateScope();\n        }\n        base._ExitTree();\n    }\n\n    public override void _Process(double delta)\n    {\n        base._Process(delta);\n\n        // Update time since last shot for recoil recovery\n        _timeSinceLastShot += (float)delta;\n\n        // Recover recoil after delay\n        if (_timeSinceLastShot >= RecoilRecoveryDelay && _recoilOffset != 0)\n        {\n            float recoveryAmount = RecoilRecoverySpeed * (float)delta;\n            _recoilOffset = Mathf.MoveToward(_recoilOffset, 0, recoveryAmount);\n        }\n\n        // Always update aim direction and rifle sprite rotation\n        UpdateAimDirection();\n\n        // Update laser sight to point towards mouse (with recoil offset)\n        if (LaserSightEnabled && _laserSight != null)\n        {\n            UpdateLaserSight();\n        }\n\n        // Handle bolt-action input\n        HandleBoltActionInput();\n\n        // Update scope system (sway, camera offset, overlay)\n        UpdateScope((float)delta);\n    }\n\n    // =========================================================================\n    // Bolt-Action Charging Mechanics\n    // =========================================================================\n\n    /// <summary>\n    /// Handles the bolt-action charging input sequence.\n    /// Sequence: Down (pull bolt) ‚Üí Left (open bolt) ‚Üí Down (close bolt) ‚Üí Up (chamber round)\n    /// Uses the arrow keys / WASD movement input actions.\n    /// </summary>\n    private void HandleBoltActionInput()\n    {\n        switch (_boltStep)\n        {\n            case BoltActionStep.NeedsBoltCycle:\n                // Step 1: Down arrow - pull bolt back\n                if (Input.IsActionJustPressed(\"move_down\"))\n                {\n                    _boltStep = BoltActionStep.WaitOpenBolt;\n                    EmitSignal(SignalName.BoltStepChanged, 1, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 1/4: Bolt pulled back\");\n                }\n                break;\n\n            case BoltActionStep.WaitOpenBolt:\n                // Step 2: Left arrow - open bolt\n                if (Input.IsActionJustPressed(\"move_left\"))\n                {\n                    _boltStep = BoltActionStep.WaitCloseBolt;\n                    EmitSignal(SignalName.BoltStepChanged, 2, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 2/4: Bolt opened\");\n                }\n                break;\n\n            case BoltActionStep.WaitCloseBolt:\n                // Step 3: Down arrow - close bolt\n                if (Input.IsActionJustPressed(\"move_down\"))\n                {\n                    _boltStep = BoltActionStep.WaitChamberRound;\n                    EmitSignal(SignalName.BoltStepChanged, 3, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 3/4: Bolt closed\");\n                }\n                break;\n\n            case BoltActionStep.WaitChamberRound:\n                // Step 4: Up arrow - chamber round\n                if (Input.IsActionJustPressed(\"move_up\"))\n                {\n                    _boltStep = BoltActionStep.Ready;\n                    EmitSignal(SignalName.BoltStepChanged, 4, 4);\n                    PlayBoltChamberSound();\n                    GD.Print(\"[SniperRifle] Bolt step 4/4: Round chambered - READY TO FIRE\");\n                }\n                break;\n\n            case BoltActionStep.Ready:\n                // Already ready, no bolt action needed\n                break;\n        }\n    }\n\n    /// <summary>\n    /// Plays the bolt manipulation sound.\n    /// </summary>\n    private void PlayBoltSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_bolt\"))\n        {\n            audioManager.Call(\"play_m16_bolt\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Plays the bolt chamber/ready sound.\n    /// </summary>\n    private void PlayBoltChamberSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_bolt\"))\n        {\n            audioManager.Call(\"play_m16_bolt\", GlobalPosition);\n        }\n    }\n\n    // =========================================================================\n    // Aiming and Laser Sight\n    // =========================================================================\n\n    /// <summary>\n    /// Updates the aim direction and rifle sprite rotation.\n    /// </summary>\n    private void UpdateAimDirection()\n    {\n        Vector2 mousePos = GetGlobalMousePosition();\n        Vector2 toMouse = mousePos - GlobalPosition;\n        float targetAngle = toMouse.Angle();\n\n        if (!_aimAngleInitialized)\n        {\n            _currentAimAngle = targetAngle;\n            _aimAngleInitialized = true;\n        }\n\n        Vector2 direction;\n\n        // Apply sensitivity for the sniper rifle\n        if (WeaponData != null && WeaponData.Sensitivity > 0)\n        {\n            float angleDiff = Mathf.Wrap(targetAngle - _currentAimAngle, -Mathf.Pi, Mathf.Pi);\n            float rotationSpeed = WeaponData.Sensitivity * 10.0f;\n            float delta = (float)GetProcessDeltaTime();\n            float maxRotation = rotationSpeed * delta;\n            float actualRotation = Mathf.Clamp(angleDiff, -maxRotation, maxRotation);\n            _currentAimAngle += actualRotation;\n            direction = new Vector2(Mathf.Cos(_currentAimAngle), Mathf.Sin(_currentAimAngle));\n        }\n        else\n        {\n            if (toMouse.LengthSquared() > 0.001f)\n            {\n                direction = toMouse.Normalized();\n                _currentAimAngle = targetAngle;\n            }\n            else\n            {\n                direction = _aimDirection;\n            }\n        }\n\n        _aimDirection = direction;\n        UpdateRifleSpriteRotation(direction);\n    }\n\n    /// <summary>\n    /// Creates the laser sight Line2D programmatically.\n    /// </summary>\n    private void CreateLaserSight()\n    {\n        _laserSight = new Line2D\n        {\n            Name = \"LaserSight\",\n            Width = LaserSightWidth,\n            DefaultColor = LaserSightColor,\n            BeginCapMode = Line2D.LineCapMode.Round,\n            EndCapMode = Line2D.LineCapMode.Round\n        };\n\n        _laserSight.AddPoint(Vector2.Zero);\n        _laserSight.AddPoint(Vector2.Right * LaserSightLength);\n\n        AddChild(_laserSight);\n    }\n\n    /// <summary>\n    /// Updates the laser sight visualization with recoil offset.\n    /// Uses raycasting to stop at obstacles.\n    /// </summary>\n    private void UpdateLaserSight()\n    {\n        if (_laserSight == null)\n        {\n            return;\n        }\n\n        Vector2 laserDirection = _aimDirection.Rotated(_recoilOffset);\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float maxLaserLength = viewportSize.Length();\n\n        Vector2 endPoint = laserDirection * maxLaserLength;\n\n        var spaceState = GetWorld2D().DirectSpaceState;\n        var query = PhysicsRayQueryParameters2D.Create(\n            GlobalPosition,\n            GlobalPosition + endPoint,\n            4 // Collision mask for obstacles (layer 3 = value 4)\n        );\n\n        var result = spaceState.IntersectRay(query);\n\n        if (result.Count > 0)\n        {\n            Vector2 hitPosition = (Vector2)result[\"position\"];\n            endPoint = hitPosition - GlobalPosition;\n        }\n\n        _laserSight.SetPointPosition(0, Vector2.Zero);\n        _laserSight.SetPointPosition(1, endPoint);\n    }\n\n    /// <summary>\n    /// Updates the visibility of the laser sight.\n    /// </summary>\n    private void UpdateLaserSightVisibility()\n    {\n        if (_laserSight != null)\n        {\n            _laserSight.Visible = LaserSightEnabled;\n        }\n    }\n\n    /// <summary>\n    /// Updates the rifle sprite rotation to match aim direction.\n    /// </summary>\n    private void UpdateRifleSpriteRotation(Vector2 direction)\n    {\n        if (_rifleSprite == null)\n        {\n            return;\n        }\n\n        float angle = direction.Angle();\n        _rifleSprite.Rotation = angle;\n\n        bool aimingLeft = Mathf.Abs(angle) > Mathf.Pi / 2;\n        _rifleSprite.FlipV = aimingLeft;\n    }\n\n    /// <summary>\n    /// Enables or disables the laser sight.\n    /// </summary>\n    public void SetLaserSightEnabled(bool enabled)\n    {\n        LaserSightEnabled = enabled;\n        UpdateLaserSightVisibility();\n    }\n\n    // =========================================================================\n    // Firing\n    // =========================================================================\n\n    /// <summary>\n    /// Fires the sniper rifle. Only fires if bolt is ready.\n    /// After firing, transitions to NeedsBoltCycle state.\n    /// </summary>\n    public override bool Fire(Vector2 direction)\n    {\n        // Check for empty magazine\n        if (CurrentAmmo <= 0)\n        {\n            PlayEmptyClickSound();\n            return false;\n        }\n\n        // Check if bolt is ready\n        if (!IsBoltReady)\n        {\n            // Play a click to indicate bolt not cycled\n            PlayEmptyClickSound();\n            return false;\n        }\n\n        // Check standard fire conditions\n        if (!CanFire || WeaponData == null || BulletScene == null)\n        {\n            return false;\n        }\n\n        // Apply recoil to aim direction\n        Vector2 spreadDirection = ApplyRecoil(_aimDirection);\n        bool result = base.Fire(spreadDirection);\n\n        if (result)\n        {\n            // Transition to needs bolt cycle\n            _boltStep = BoltActionStep.NeedsBoltCycle;\n            EmitSignal(SignalName.BoltStepChanged, 0, 4);\n\n            // Play sniper shot sound\n            PlaySniperShotSound();\n            // Emit gunshot sound for enemy detection\n            EmitGunshotSound();\n            // Play shell casing with delay\n            PlayShellCasingDelayed();\n            // Trigger heavy screen shake\n            TriggerScreenShake(spreadDirection);\n\n            // Spawn smoky tracer trail\n            SpawnSmokyTracer(GlobalPosition, spreadDirection);\n\n            GD.Print(\"[SniperRifle] FIRED! Bolt needs cycling. Ammo remaining: \" + CurrentAmmo);\n        }\n\n        return result;\n    }\n\n    /// <summary>\n    /// Override SpawnBullet to configure the SniperBullet for sniper behavior:\n    /// - Very high damage (50)\n    /// - Passes through enemies (doesn't destroy on hit)\n    /// - Penetrates through 2 walls (wall-count based, not distance-based)\n    /// </summary>\n    protected override void SpawnBullet(Vector2 direction)\n    {\n        if (BulletScene == null)\n        {\n            return;\n        }\n\n        // Check bullet spawn path\n        var (isBlocked, hitPosition, hitNormal) = CheckBulletSpawnPath(direction);\n\n        Vector2 spawnPosition;\n        if (isBlocked)\n        {\n            spawnPosition = GlobalPosition + direction * 2.0f;\n            GD.Print(\"[SniperRifle] Point-blank shot: spawning for penetration\");\n        }\n        else\n        {\n            spawnPosition = GlobalPosition + direction * BulletSpawnOffset;\n        }\n\n        var bulletNode = BulletScene.Instantiate<Node2D>();\n        bulletNode.GlobalPosition = spawnPosition;\n\n        // Try to cast to C# SniperBullet for direct property access\n        var sniperBullet = bulletNode as SniperBullet;\n\n        if (sniperBullet != null)\n        {\n            // SniperBullet - set properties directly\n            sniperBullet.Direction = direction;\n            if (WeaponData != null)\n            {\n                sniperBullet.Speed = WeaponData.BulletSpeed;\n                sniperBullet.Damage = WeaponData.Damage;\n            }\n            var owner = GetParent();\n            if (owner != null)\n            {\n                sniperBullet.ShooterId = owner.GetInstanceId();\n            }\n            sniperBullet.ShooterPosition = GlobalPosition;\n            sniperBullet.MaxWallPenetrations = MaxWallPenetrations;\n            GD.Print($\"[SniperRifle] Spawned SniperBullet: Damage={sniperBullet.Damage}, Speed={sniperBullet.Speed}, MaxWallPen={MaxWallPenetrations}\");\n        }\n        else\n        {\n            // Fallback for any bullet type\n            if (bulletNode.HasMethod(\"SetDirection\"))\n            {\n                bulletNode.Call(\"SetDirection\", direction);\n            }\n            else\n            {\n                bulletNode.Set(\"Direction\", direction);\n                bulletNode.Set(\"direction\", direction);\n            }\n\n            if (WeaponData != null)\n            {\n                bulletNode.Set(\"Speed\", WeaponData.BulletSpeed);\n                bulletNode.Set(\"speed\", WeaponData.BulletSpeed);\n                bulletNode.Set(\"Damage\", WeaponData.Damage);\n                bulletNode.Set(\"damage\", WeaponData.Damage);\n            }\n\n            var owner = GetParent();\n            if (owner != null)\n            {\n                bulletNode.Set(\"ShooterId\", owner.GetInstanceId());\n                bulletNode.Set(\"shooter_id\", owner.GetInstanceId());\n            }\n\n            bulletNode.Set(\"ShooterPosition\", GlobalPosition);\n            bulletNode.Set(\"shooter_position\", GlobalPosition);\n        }\n\n        GetTree().CurrentScene.AddChild(bulletNode);\n\n        // Spawn muzzle flash effect - large flash for 12.7mm\n        SpawnMuzzleFlash(spawnPosition, direction, WeaponData?.Caliber);\n\n        // Spawn casing\n        SpawnCasing(direction, WeaponData?.Caliber);\n    }\n\n    // =========================================================================\n    // Smoky Tracer Trail\n    // =========================================================================\n\n    /// <summary>\n    /// Spawns a smoky dissipating tracer trail from the fire position\n    /// in the shooting direction across the entire map.\n    /// The tracer is an instant visual effect (like a contrail from a plane)\n    /// that fades out over time.\n    /// </summary>\n    private void SpawnSmokyTracer(Vector2 fromPosition, Vector2 direction)\n    {\n        // Calculate tracer end point - extend to edge of map (very far)\n        float tracerLength = 5000.0f; // Far enough to reach any map edge\n        Vector2 endPosition = fromPosition + direction * tracerLength;\n\n        // Create the tracer as a Line2D with smoke-like appearance\n        var tracer = new Line2D\n        {\n            Name = \"SniperTracer\",\n            Width = 6.0f,\n            DefaultColor = new Color(0.8f, 0.8f, 0.8f, 0.7f),\n            BeginCapMode = Line2D.LineCapMode.Round,\n            EndCapMode = Line2D.LineCapMode.Round,\n            TopLevel = true,\n            Position = Vector2.Zero,\n            ZIndex = -1 // Behind other elements\n        };\n\n        // Set up width curve - wider at start, tapers to narrower at end\n        var widthCurve = new Curve();\n        widthCurve.AddPoint(new Vector2(0.0f, 1.0f));\n        widthCurve.AddPoint(new Vector2(0.3f, 0.8f));\n        widthCurve.AddPoint(new Vector2(1.0f, 0.3f));\n        tracer.WidthCurve = widthCurve;\n\n        // Set up gradient - smoky white/gray that fades out\n        var gradient = new Gradient();\n        gradient.SetColor(0, new Color(0.9f, 0.9f, 0.85f, 0.8f));\n        gradient.AddPoint(0.5f, new Color(0.7f, 0.7f, 0.65f, 0.5f));\n        gradient.SetColor(gradient.GetPointCount() - 1, new Color(0.5f, 0.5f, 0.5f, 0.2f));\n        tracer.Gradient = gradient;\n\n        // Add the tracer line points (using global coordinates since TopLevel=true)\n        tracer.AddPoint(fromPosition + direction * BulletSpawnOffset);\n        tracer.AddPoint(endPosition);\n\n        // Add to scene\n        GetTree().CurrentScene.AddChild(tracer);\n\n        // Start the fade-out animation\n        FadeOutTracer(tracer);\n    }\n\n    /// <summary>\n    /// Animates the tracer trail fading out and dissipating over time.\n    /// The tracer gradually becomes more transparent and wider (simulating smoke dissipation).\n    /// </summary>\n    private async void FadeOutTracer(Line2D tracer)\n    {\n        float fadeDuration = 2.0f;\n        float elapsed = 0.0f;\n\n        float initialWidth = tracer.Width;\n\n        while (elapsed < fadeDuration && IsInstanceValid(tracer))\n        {\n            elapsed += (float)GetProcessDeltaTime();\n            float progress = elapsed / fadeDuration;\n\n            // Fade the alpha\n            float alpha = Mathf.Lerp(0.7f, 0.0f, progress);\n            tracer.DefaultColor = new Color(0.8f, 0.8f, 0.8f, alpha);\n\n            // Widen slightly to simulate smoke dissipation\n            tracer.Width = initialWidth + progress * 4.0f;\n\n            // Update gradient alpha\n            var gradient = new Gradient();\n            gradient.SetColor(0, new Color(0.9f, 0.9f, 0.85f, alpha));\n            gradient.AddPoint(0.5f, new Color(0.7f, 0.7f, 0.65f, alpha * 0.6f));\n            gradient.SetColor(gradient.GetPointCount() - 1, new Color(0.5f, 0.5f, 0.5f, alpha * 0.3f));\n            tracer.Gradient = gradient;\n\n            await ToSignal(GetTree(), \"process_frame\");\n        }\n\n        // Remove the tracer after fade completes\n        if (IsInstanceValid(tracer))\n        {\n            tracer.QueueFree();\n        }\n    }\n\n    // =========================================================================\n    // Sound and Effects\n    // =========================================================================\n\n    /// <summary>\n    /// Plays the sniper shot sound via AudioManager.\n    /// </summary>\n    private void PlaySniperShotSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        // Use M16 shot as a placeholder sound for the sniper\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_shot\"))\n        {\n            audioManager.Call(\"play_m16_shot\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Plays the empty gun click sound.\n    /// </summary>\n    private void PlayEmptyClickSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_empty_click\"))\n        {\n            audioManager.Call(\"play_empty_click\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Emits gunshot sound for enemy detection via SoundPropagation.\n    /// Very loud for the 12.7mm round.\n    /// </summary>\n    private void EmitGunshotSound()\n    {\n        var soundPropagation = GetNodeOrNull(\"/root/SoundPropagation\");\n        if (soundPropagation != null && soundPropagation.HasMethod(\"emit_sound\"))\n        {\n            float loudness = WeaponData?.Loudness ?? 3000.0f;\n            soundPropagation.Call(\"emit_sound\", 0, GlobalPosition, 0, this, loudness);\n        }\n    }\n\n    /// <summary>\n    /// Plays shell casing sound with a delay.\n    /// </summary>\n    private async void PlayShellCasingDelayed()\n    {\n        await ToSignal(GetTree().CreateTimer(0.2), \"timeout\");\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_shell_rifle\"))\n        {\n            audioManager.Call(\"play_shell_rifle\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Applies recoil to shooting direction.\n    /// </summary>\n    private Vector2 ApplyRecoil(Vector2 direction)\n    {\n        // Apply current recoil offset\n        Vector2 result = direction.Rotated(_recoilOffset);\n\n        // Add strong recoil for next shot (heavy 12.7mm kick)\n        float recoilDirection = (float)GD.RandRange(-1.0, 1.0);\n        _recoilOffset += recoilDirection * RecoilPerShot;\n        _recoilOffset = Mathf.Clamp(_recoilOffset, -MaxRecoilOffset, MaxRecoilOffset);\n\n        _timeSinceLastShot = 0;\n\n        return result;\n    }\n\n    /// <summary>\n    /// Triggers screen shake from sniper shot.\n    /// Heavy shake for 12.7mm round.\n    /// </summary>\n    private void TriggerScreenShake(Vector2 shootDirection)\n    {\n        if (WeaponData == null || WeaponData.ScreenShakeIntensity <= 0)\n        {\n            return;\n        }\n\n        var screenShakeManager = GetNodeOrNull(\"/root/ScreenShakeManager\");\n        if (screenShakeManager == null || !screenShakeManager.HasMethod(\"add_shake\"))\n        {\n            return;\n        }\n\n        // Heavy shake for sniper\n        float fireRate = WeaponData.FireRate;\n        float shakeIntensity;\n        if (fireRate > 0)\n        {\n            shakeIntensity = WeaponData.ScreenShakeIntensity / fireRate * 10.0f;\n        }\n        else\n        {\n            shakeIntensity = WeaponData.ScreenShakeIntensity;\n        }\n\n        float recoveryTime = WeaponData.ScreenShakeMinRecoveryTime;\n\n        screenShakeManager.Call(\"add_shake\", shootDirection, shakeIntensity, recoveryTime);\n    }\n\n    /// <summary>\n    /// Fires the bullet in the chamber during reload sequence.\n    /// </summary>\n    public override bool FireChamberBullet(Vector2 direction)\n    {\n        // Sniper rifle doesn't support chamber bullet during reload\n        // (bolt-action requires full cycle)\n        return false;\n    }\n\n    /// <summary>\n    /// Gets the current aim direction.\n    /// </summary>\n    public Vector2 AimDirection => _aimDirection;\n\n    /// <summary>\n    /// Gets the current bolt-action step.\n    /// </summary>\n    public BoltActionStep CurrentBoltStep => _boltStep;\n\n    /// <summary>\n    /// Resets the bolt to ready state (e.g., after reload with a new magazine).\n    /// </summary>\n    public void ResetBolt()\n    {\n        _boltStep = BoltActionStep.Ready;\n        EmitSignal(SignalName.BoltStepChanged, 4, 4);\n        GD.Print(\"[SniperRifle] Bolt reset to ready state\");\n    }\n\n    // =========================================================================\n    // Scope / Aiming System (RMB)\n    // =========================================================================\n\n    /// <summary>\n    /// Whether the scope is currently active (RMB held).\n    /// </summary>\n    private bool _isScopeActive = false;\n\n    /// <summary>\n    /// Whether the scope is active (read-only property for external access).\n    /// </summary>\n    public bool IsScopeActive => _isScopeActive;\n\n    /// <summary>\n    /// Signal emitted when scope state changes.\n    /// </summary>\n    [Signal]\n    public delegate void ScopeStateChangedEventHandler(bool isActive);\n\n    /// <summary>\n    /// Current scope zoom distance multiplier (how far beyond viewport the player can see).\n    /// 1.0 = one viewport distance, 2.0 = two viewport distances.\n    /// Controlled by mouse wheel while scoping.\n    /// </summary>\n    private float _scopeZoomDistance = 1.0f;\n\n    /// <summary>\n    /// Minimum scope zoom distance (viewport multiplier).\n    /// Set to 1.0 so the scope always looks beyond the normal viewport.\n    /// </summary>\n    private const float MinScopeZoomDistance = 1.0f;\n\n    /// <summary>\n    /// Maximum scope zoom distance (viewport multiplier).\n    /// </summary>\n    private const float MaxScopeZoomDistance = 3.0f;\n\n    /// <summary>\n    /// Step size for mouse wheel zoom adjustment.\n    /// </summary>\n    private const float ScopeZoomStep = 0.25f;\n\n    /// <summary>\n    /// Base sway amplitude in pixels at 1 viewport distance.\n    /// </summary>\n    private const float BaseScopeSwayAmplitude = 8.0f;\n\n    /// <summary>\n    /// Speed of the sway oscillation.\n    /// </summary>\n    private const float ScopeSwaySpeed = 2.5f;\n\n    /// <summary>\n    /// Maximum range (in viewport fraction) that the player can fine-tune the scope\n    /// distance via mouse movement while scoped. About 1/3 of the viewport.\n    /// </summary>\n    private const float ScopeMouseFineTuneRange = 0.33f;\n\n    /// <summary>\n    /// Current mouse fine-tune offset applied to scope distance.\n    /// Ranges from -ScopeMouseFineTuneRange to +ScopeMouseFineTuneRange (viewport fraction).\n    /// Positive = further, negative = closer.\n    /// </summary>\n    private float _scopeMouseFineTuneOffset = 0.0f;\n\n    /// <summary>\n    /// Current scope sway time accumulator.\n    /// </summary>\n    private float _scopeSwayTime = 0.0f;\n\n    /// <summary>\n    /// Current scope sway offset in pixels (applied to camera).\n    /// </summary>\n    private Vector2 _scopeSwayOffset = Vector2.Zero;\n\n    /// <summary>\n    /// Reference to the scope overlay CanvasLayer (created when scope activates).\n    /// </summary>\n    private CanvasLayer? _scopeOverlay = null;\n\n    /// <summary>\n    /// Reference to the scope crosshair control node.\n    /// </summary>\n    private Control? _scopeCrosshair = null;\n\n    /// <summary>\n    /// Reference to the scope darkening background.\n    /// </summary>\n    private ColorRect? _scopeBackground = null;\n\n    /// <summary>\n    /// Cached reference to the player's Camera2D node.\n    /// </summary>\n    private Camera2D? _playerCamera = null;\n\n    /// <summary>\n    /// Original camera offset before scoping (to restore on exit).\n    /// </summary>\n    private Vector2 _originalCameraOffset = Vector2.Zero;\n\n    /// <summary>\n    /// Gets the effective scope zoom distance including mouse fine-tune offset.\n    /// </summary>\n    private float EffectiveScopeZoomDistance => _scopeZoomDistance + _scopeMouseFineTuneOffset;\n\n    /// <summary>\n    /// Gets the current camera offset for scope aiming.\n    /// Called by the player or level scripts to position the camera.\n    /// </summary>\n    public Vector2 GetScopeCameraOffset()\n    {\n        if (!_isScopeActive)\n        {\n            return Vector2.Zero;\n        }\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return Vector2.Zero;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float baseDistance = viewportSize.Length() * 0.5f;\n\n        // Camera offset = aim direction * (zoom distance + mouse fine-tune) * viewport size + sway\n        Vector2 offset = _aimDirection * baseDistance * EffectiveScopeZoomDistance + _scopeSwayOffset;\n\n        return offset;\n    }\n\n    /// <summary>\n    /// Gets the world-space position that the scope crosshair center is aiming at.\n    /// Used to direct bullets to the crosshair center.\n    /// </summary>\n    public Vector2 GetScopeAimTarget()\n    {\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return GlobalPosition + _aimDirection * 1000.0f;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float baseDistance = viewportSize.Length() * 0.5f;\n\n        // The scope aim target is the player's position offset by the scope camera offset\n        // (without sway, so bullets go to the true center, not the swaying crosshair)\n        Vector2 aimTarget = GlobalPosition + _aimDirection * baseDistance * EffectiveScopeZoomDistance;\n\n        return aimTarget;\n    }\n\n    /// <summary>\n    /// Activates the scope (called when RMB is pressed).\n    /// </summary>\n    public void ActivateScope()\n    {\n        if (_isScopeActive)\n        {\n            return;\n        }\n\n        _isScopeActive = true;\n        _scopeSwayTime = 0.0f;\n\n        // Find and cache the player's Camera2D\n        FindPlayerCamera();\n\n        // Store original camera offset\n        if (_playerCamera != null)\n        {\n            _originalCameraOffset = _playerCamera.Offset;\n        }\n\n        // Create the scope overlay\n        CreateScopeOverlay();\n\n        EmitSignal(SignalName.ScopeStateChanged, true);\n        GD.Print($\"[SniperRifle] Scope activated. Zoom distance: {_scopeZoomDistance:F1}x\");\n    }\n\n    /// <summary>\n    /// Deactivates the scope (called when RMB is released).\n    /// </summary>\n    public void DeactivateScope()\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        _isScopeActive = false;\n\n        // Restore original camera offset\n        if (_playerCamera != null)\n        {\n            _playerCamera.Offset = _originalCameraOffset;\n        }\n\n        // Remove scope overlay\n        RemoveScopeOverlay();\n\n        EmitSignal(SignalName.ScopeStateChanged, false);\n        GD.Print(\"[SniperRifle] Scope deactivated.\");\n    }\n\n    /// <summary>\n    /// Adjusts the scope zoom distance (called on mouse wheel while scoping).\n    /// </summary>\n    public void AdjustScopeZoom(float direction)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        _scopeZoomDistance += direction * ScopeZoomStep;\n        _scopeZoomDistance = Mathf.Clamp(_scopeZoomDistance, MinScopeZoomDistance, MaxScopeZoomDistance);\n\n        // Reset fine-tune offset when zoom changes to avoid going out of range\n        _scopeMouseFineTuneOffset = Mathf.Clamp(_scopeMouseFineTuneOffset,\n            -ScopeMouseFineTuneRange, ScopeMouseFineTuneRange);\n\n        GD.Print($\"[SniperRifle] Scope zoom adjusted: {_scopeZoomDistance:F2}x (fine-tune: {_scopeMouseFineTuneOffset:F2})\");\n    }\n\n    /// <summary>\n    /// Adjusts the scope fine-tune offset based on mouse movement along the aim direction.\n    /// Allows the player to look slightly closer or further (about 1/3 viewport range).\n    /// Called from Player.cs when mouse moves while scoped.\n    /// </summary>\n    public void AdjustScopeFineTune(Vector2 mouseMotion)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        // Project mouse motion onto the aim direction to get forward/backward movement\n        // Moving mouse in the aim direction = further, opposite = closer\n        float projection = mouseMotion.Dot(_aimDirection);\n\n        // Scale the projection: mouse sensitivity for scope fine-tuning\n        // A moderate movement across the screen should give the full range\n        float sensitivity = 0.002f;\n        _scopeMouseFineTuneOffset += projection * sensitivity;\n        _scopeMouseFineTuneOffset = Mathf.Clamp(_scopeMouseFineTuneOffset,\n            -ScopeMouseFineTuneRange, ScopeMouseFineTuneRange);\n    }\n\n    /// <summary>\n    /// Finds the player's Camera2D node by traversing up to the parent (player).\n    /// </summary>\n    private void FindPlayerCamera()\n    {\n        if (_playerCamera != null)\n        {\n            return;\n        }\n\n        var parent = GetParent();\n        if (parent != null)\n        {\n            _playerCamera = parent.GetNodeOrNull<Camera2D>(\"Camera2D\");\n        }\n    }\n\n    /// <summary>\n    /// Updates the scope system each frame (called from _Process).\n    /// </summary>\n    private void UpdateScope(float delta)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        // Update sway\n        _scopeSwayTime += delta;\n        float swayAmplitude = BaseScopeSwayAmplitude * _scopeZoomDistance;\n\n        // Use two sine waves at different frequencies for natural-looking sway\n        float swayX = Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 1.0f) * swayAmplitude\n                    + Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 2.3f) * swayAmplitude * 0.3f;\n        float swayY = Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 1.4f) * swayAmplitude\n                    + Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 0.7f) * swayAmplitude * 0.4f;\n\n        _scopeSwayOffset = new Vector2(swayX, swayY);\n\n        // Update camera offset for scope view\n        if (_playerCamera != null)\n        {\n            _playerCamera.Offset = _originalCameraOffset + GetScopeCameraOffset();\n        }\n\n        // Update scope overlay crosshair position with sway\n        UpdateScopeOverlayPosition();\n    }\n\n    /// <summary>\n    /// Creates the scope overlay UI with crosshair and darkened edges.\n    /// </summary>\n    private void CreateScopeOverlay()\n    {\n        RemoveScopeOverlay();\n\n        _scopeOverlay = new CanvasLayer\n        {\n            Name = \"ScopeOverlay\",\n            Layer = 10\n        };\n\n        Viewport? viewport = GetViewport();\n        Vector2 viewportSize = viewport?.GetVisibleRect().Size ?? new Vector2(1280, 720);\n\n        // Dark background with circular cutout effect (vignette)\n        _scopeBackground = new ColorRect\n        {\n            Name = \"ScopeBackground\",\n            Color = new Color(0.0f, 0.0f, 0.0f, 0.5f),\n            Size = viewportSize,\n            Position = Vector2.Zero,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        _scopeOverlay.AddChild(_scopeBackground);\n\n        // Create the crosshair as a Control node\n        _scopeCrosshair = new Control\n        {\n            Name = \"ScopeCrosshair\",\n            Position = viewportSize / 2,\n            Size = Vector2.Zero,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        _scopeOverlay.AddChild(_scopeCrosshair);\n\n        // Add crosshair lines - based on the reference image from the issue\n        // The scope has a classic crosshair with circle and mil-dots\n\n        // Outer circle\n        float circleRadius = Mathf.Min(viewportSize.X, viewportSize.Y) * 0.35f;\n        int segments = 64;\n        var outerCircle = new Line2D\n        {\n            Name = \"OuterCircle\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f),\n            Antialiased = true\n        };\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            outerCircle.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * circleRadius);\n        }\n        _scopeCrosshair.AddChild(outerCircle);\n\n        // Inner thin circle\n        float innerRadius = circleRadius * 0.05f;\n        var innerCircle = new Line2D\n        {\n            Name = \"InnerCircle\",\n            Width = 1.5f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f),\n            Antialiased = true\n        };\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            innerCircle.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * innerRadius);\n        }\n        _scopeCrosshair.AddChild(innerCircle);\n\n        // Horizontal crosshair line (left)\n        var hLineLeft = new Line2D\n        {\n            Name = \"HLineLeft\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        hLineLeft.AddPoint(new Vector2(-circleRadius, 0));\n        hLineLeft.AddPoint(new Vector2(-innerRadius, 0));\n        _scopeCrosshair.AddChild(hLineLeft);\n\n        // Horizontal crosshair line (right)\n        var hLineRight = new Line2D\n        {\n            Name = \"HLineRight\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        hLineRight.AddPoint(new Vector2(innerRadius, 0));\n        hLineRight.AddPoint(new Vector2(circleRadius, 0));\n        _scopeCrosshair.AddChild(hLineRight);\n\n        // Vertical crosshair line (top)\n        var vLineTop = new Line2D\n        {\n            Name = \"VLineTop\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        vLineTop.AddPoint(new Vector2(0, -circleRadius));\n        vLineTop.AddPoint(new Vector2(0, -innerRadius));\n        _scopeCrosshair.AddChild(vLineTop);\n\n        // Vertical crosshair line (bottom) with mil-dots\n        var vLineBottom = new Line2D\n        {\n            Name = \"VLineBottom\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        vLineBottom.AddPoint(new Vector2(0, innerRadius));\n        vLineBottom.AddPoint(new Vector2(0, circleRadius));\n        _scopeCrosshair.AddChild(vLineBottom);\n\n        // Add mil-dot markers on the bottom crosshair (range estimation)\n        float dotSpacing = circleRadius * 0.15f;\n        for (int i = 1; i <= 4; i++)\n        {\n            float dotY = dotSpacing * i;\n            var dot = new Line2D\n            {\n                Name = $\"MilDot_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            float dotWidth = 4.0f - i * 0.5f; // Dots get smaller further from center\n            dot.AddPoint(new Vector2(-dotWidth, dotY));\n            dot.AddPoint(new Vector2(dotWidth, dotY));\n            _scopeCrosshair.AddChild(dot);\n        }\n\n        // Add mil-dot markers on horizontal lines\n        for (int i = 1; i <= 3; i++)\n        {\n            float dotX = dotSpacing * i;\n            // Right side dots\n            var dotRight = new Line2D\n            {\n                Name = $\"HMilDotRight_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            float dotHeight = 4.0f - i * 0.5f;\n            dotRight.AddPoint(new Vector2(dotX, -dotHeight));\n            dotRight.AddPoint(new Vector2(dotX, dotHeight));\n            _scopeCrosshair.AddChild(dotRight);\n\n            // Left side dots\n            var dotLeft = new Line2D\n            {\n                Name = $\"HMilDotLeft_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            dotLeft.AddPoint(new Vector2(-dotX, -dotHeight));\n            dotLeft.AddPoint(new Vector2(-dotX, dotHeight));\n            _scopeCrosshair.AddChild(dotLeft);\n        }\n\n        // Add thick outer ring to mask edges (simulate scope tube)\n        var scopeRing = new Line2D\n        {\n            Name = \"ScopeRing\",\n            Width = 6.0f,\n            DefaultColor = new Color(0.1f, 0.1f, 0.1f, 0.95f),\n            Antialiased = true\n        };\n        float ringRadius = circleRadius + 3.0f;\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            scopeRing.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * ringRadius);\n        }\n        _scopeCrosshair.AddChild(scopeRing);\n\n        // Zoom distance indicator text\n        var zoomLabel = new Label\n        {\n            Name = \"ZoomLabel\",\n            Position = new Vector2(circleRadius * 0.5f, circleRadius * 0.7f),\n            Text = $\"{_scopeZoomDistance:F1}x\",\n            HorizontalAlignment = HorizontalAlignment.Center,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        zoomLabel.AddThemeColorOverride(\"font_color\", new Color(0.0f, 0.0f, 0.0f, 0.6f));\n        zoomLabel.AddThemeFontSizeOverride(\"font_size\", 12);\n        _scopeCrosshair.AddChild(zoomLabel);\n\n        GetTree().CurrentScene.AddChild(_scopeOverlay);\n    }\n\n    /// <summary>\n    /// Updates the scope overlay crosshair position with sway applied.\n    /// </summary>\n    private void UpdateScopeOverlayPosition()\n    {\n        if (_scopeCrosshair == null || _scopeOverlay == null)\n        {\n            return;\n        }\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n\n        // Crosshair stays centered but sways\n        _scopeCrosshair.Position = viewportSize / 2 + _scopeSwayOffset;\n\n        // Update zoom label\n        var zoomLabel = _scopeCrosshair.GetNodeOrNull<Label>(\"ZoomLabel\");\n        if (zoomLabel != null)\n        {\n            zoomLabel.Text = $\"{_scopeZoomDistance:F1}x\";\n        }\n    }\n\n    /// <summary>\n    /// Removes the scope overlay from the scene.\n    /// </summary>\n    private void RemoveScopeOverlay()\n    {\n        if (_scopeOverlay != null && IsInstanceValid(_scopeOverlay))\n        {\n            _scopeOverlay.QueueFree();\n            _scopeOverlay = null;\n            _scopeCrosshair = null;\n            _scopeBackground = null;\n        }\n    }\n}\n",
    "structuredPatch": [
      {
        "oldStart": 1061,
        "oldLines": 6,
        "newStart": 1061,
        "newLines": 7,
        "lines": [
          " ",
          "         _isScopeActive = true;",
          "         _scopeSwayTime = 0.0f;",
          "+        _scopeMouseFineTuneOffset = 0.0f;",
          " ",
          "         // Find and cache the player's Camera2D",
          "         FindPlayerCamera();"
        ]
      }
    ],
    "userModified": false,
    "replaceAll": false
  }
}
[2026-02-06T20:57:43.913Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01YWRDyaCgT3QgNQPj357S5q",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now update the sway calculation to use `EffectiveScopeZoomDistance`:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 530,
      "cache_read_input_tokens": 61340,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 530
      },
      "output_tokens": 2,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "a108306f-7f17-4a64-b4f1-c1b931020eae"
}
[2026-02-06T20:57:46.011Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01YWRDyaCgT3QgNQPj357S5q",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01MqD1VghRMLDRbTDY53tZM3",
        "name": "Edit",
        "input": {
          "replace_all": false,
          "file_path": "/tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs",
          "old_string": "        // Update sway\n        _scopeSwayTime += delta;\n        float swayAmplitude = BaseScopeSwayAmplitude * _scopeZoomDistance;",
          "new_string": "        // Update sway (scales with effective distance including fine-tune offset)\n        _scopeSwayTime += delta;\n        float swayAmplitude = BaseScopeSwayAmplitude * EffectiveScopeZoomDistance;"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 530,
      "cache_read_input_tokens": 61340,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 530
      },
      "output_tokens": 2,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "85f660e6-86df-4ee6-8217-6c14d3890472"
}
[2026-02-06T20:57:46.021Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01MqD1VghRMLDRbTDY53tZM3",
        "type": "tool_result",
        "content": "The file /tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs has been updated successfully."
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "37bc172f-7b72-45f9-82bf-1218a948999c",
  "tool_use_result": {
    "filePath": "/tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs",
    "oldString": "        // Update sway\n        _scopeSwayTime += delta;\n        float swayAmplitude = BaseScopeSwayAmplitude * _scopeZoomDistance;",
    "newString": "        // Update sway (scales with effective distance including fine-tune offset)\n        _scopeSwayTime += delta;\n        float swayAmplitude = BaseScopeSwayAmplitude * EffectiveScopeZoomDistance;",
    "originalFile": "using Godot;\nusing GodotTopDownTemplate.AbstractClasses;\nusing GodotTopDownTemplate.Projectiles;\n\nnamespace GodotTopDownTemplate.Weapons;\n\n/// <summary>\n/// Bolt-action charging state for the ASVK sniper rifle.\n/// Before each shot, the player must complete a 4-step bolt-action sequence:\n/// Down (pull bolt back) ‚Üí Left (open bolt) ‚Üí Down (close bolt) ‚Üí Up (chamber round)\n/// </summary>\npublic enum BoltActionStep\n{\n    /// <summary>\n    /// Bolt is ready - weapon can fire. After firing, transitions to NeedsBoltCycle.\n    /// </summary>\n    Ready,\n\n    /// <summary>\n    /// Just fired - needs bolt cycling before next shot.\n    /// Waiting for Down arrow (pull bolt back).\n    /// </summary>\n    NeedsBoltCycle,\n\n    /// <summary>\n    /// Step 1 complete (bolt pulled back). Waiting for Left arrow (open bolt).\n    /// </summary>\n    WaitOpenBolt,\n\n    /// <summary>\n    /// Step 2 complete (bolt opened). Waiting for Down arrow (close bolt).\n    /// </summary>\n    WaitCloseBolt,\n\n    /// <summary>\n    /// Step 3 complete (bolt closed). Waiting for Up arrow (chamber round).\n    /// </summary>\n    WaitChamberRound\n}\n\n/// <summary>\n/// ASVK sniper rifle - heavy anti-materiel bolt-action rifle.\n/// Features:\n/// - 12.7x108mm ammunition dealing 50 damage per shot\n/// - Penetrates through 2 walls and through enemies\n/// - Instant bullet speed with smoky dissipating tracer trail\n/// - Very high turn sensitivity\n/// - 5-round magazine with M16-style swap reload\n/// - Single-shot bolt-action with manual charging sequence (Down‚ÜíLeft‚ÜíDown‚ÜíUp)\n/// - Red laser sight for aiming\n/// Reference: ASVK (–ê–°–í–ö) anti-materiel sniper rifle\n/// </summary>\npublic partial class SniperRifle : BaseWeapon\n{\n    // =========================================================================\n    // Bolt-Action State\n    // =========================================================================\n\n    /// <summary>\n    /// Current bolt-action charging step.\n    /// </summary>\n    private BoltActionStep _boltStep = BoltActionStep.Ready;\n\n    /// <summary>\n    /// Whether the bolt action is ready to fire (chambered).\n    /// Initially true so first shot can be fired immediately.\n    /// </summary>\n    public bool IsBoltReady => _boltStep == BoltActionStep.Ready;\n\n    /// <summary>\n    /// Whether the weapon needs bolt cycling before it can fire again.\n    /// </summary>\n    public bool NeedsBoltCycle => _boltStep != BoltActionStep.Ready;\n\n    /// <summary>\n    /// Signal emitted when bolt-action step changes.\n    /// </summary>\n    [Signal]\n    public delegate void BoltStepChangedEventHandler(int step, int totalSteps);\n\n    // =========================================================================\n    // Smoky Tracer Trail\n    // =========================================================================\n\n    /// <summary>\n    /// Scene for the smoky tracer trail effect.\n    /// Created programmatically as a Line2D with smoke-like appearance.\n    /// </summary>\n    private Line2D? _lastTracerTrail;\n\n    // =========================================================================\n    // Laser Sight Configuration\n    // =========================================================================\n\n    /// <summary>\n    /// Whether the laser sight is enabled.\n    /// </summary>\n    [Export]\n    public bool LaserSightEnabled { get; set; } = true;\n\n    /// <summary>\n    /// Maximum length of the laser sight in pixels.\n    /// </summary>\n    [Export]\n    public float LaserSightLength { get; set; } = 500.0f;\n\n    /// <summary>\n    /// Color of the laser sight (red for sniper).\n    /// </summary>\n    [Export]\n    public Color LaserSightColor { get; set; } = new Color(1.0f, 0.0f, 0.0f, 0.5f);\n\n    /// <summary>\n    /// Width of the laser sight line.\n    /// </summary>\n    [Export]\n    public float LaserSightWidth { get; set; } = 2.0f;\n\n    /// <summary>\n    /// Reference to the Line2D node for the laser sight.\n    /// </summary>\n    private Line2D? _laserSight;\n\n    /// <summary>\n    /// Reference to the Sprite2D node for the rifle visual.\n    /// </summary>\n    private Sprite2D? _rifleSprite;\n\n    /// <summary>\n    /// Current aim direction based on laser sight.\n    /// </summary>\n    private Vector2 _aimDirection = Vector2.Right;\n\n    /// <summary>\n    /// Current aim angle in radians.\n    /// </summary>\n    private float _currentAimAngle = 0.0f;\n\n    /// <summary>\n    /// Whether the aim angle has been initialized.\n    /// </summary>\n    private bool _aimAngleInitialized = false;\n\n    /// <summary>\n    /// Current recoil offset angle in radians.\n    /// Heavy sniper recoil.\n    /// </summary>\n    private float _recoilOffset = 0.0f;\n\n    /// <summary>\n    /// Time since the last shot was fired, used for recoil recovery.\n    /// </summary>\n    private float _timeSinceLastShot = 0.0f;\n\n    /// <summary>\n    /// Time in seconds before recoil starts recovering.\n    /// Long delay for heavy sniper.\n    /// </summary>\n    private const float RecoilRecoveryDelay = 0.5f;\n\n    /// <summary>\n    /// Speed at which recoil recovers (radians per second).\n    /// </summary>\n    private const float RecoilRecoverySpeed = 3.0f;\n\n    /// <summary>\n    /// Maximum recoil offset in radians (about 15 degrees).\n    /// </summary>\n    private const float MaxRecoilOffset = 0.26f;\n\n    /// <summary>\n    /// Recoil amount per shot in radians.\n    /// Heavy kick for 12.7mm.\n    /// </summary>\n    private const float RecoilPerShot = 0.15f;\n\n    /// <summary>\n    /// Number of walls this bullet can penetrate through.\n    /// The bullet continues flying after penetrating walls.\n    /// </summary>\n    private const int MaxWallPenetrations = 2;\n\n    public override void _Ready()\n    {\n        base._Ready();\n\n        // Get the rifle sprite for visual representation\n        _rifleSprite = GetNodeOrNull<Sprite2D>(\"RifleSprite\");\n\n        if (_rifleSprite != null)\n        {\n            var texture = _rifleSprite.Texture;\n            GD.Print($\"[SniperRifle] RifleSprite found: visible={_rifleSprite.Visible}, z_index={_rifleSprite.ZIndex}, texture={(texture != null ? \"loaded\" : \"NULL\")}\");\n        }\n        else\n        {\n            GD.PrintErr(\"[SniperRifle] WARNING: RifleSprite node not found!\");\n        }\n\n        // Check for Power Fantasy mode blue laser\n        var difficultyManager = GetNodeOrNull(\"/root/DifficultyManager\");\n        if (difficultyManager != null)\n        {\n            var shouldForceBlueLaser = difficultyManager.Call(\"should_force_blue_laser_sight\");\n            if (shouldForceBlueLaser.AsBool())\n            {\n                var blueColorVariant = difficultyManager.Call(\"get_power_fantasy_laser_color\");\n                LaserSightColor = blueColorVariant.AsColor();\n                GD.Print($\"[SniperRifle] Power Fantasy mode: laser color set to blue {LaserSightColor}\");\n            }\n        }\n\n        // Get or create the laser sight Line2D\n        _laserSight = GetNodeOrNull<Line2D>(\"LaserSight\");\n\n        if (_laserSight == null && LaserSightEnabled)\n        {\n            CreateLaserSight();\n        }\n        else if (_laserSight != null)\n        {\n            _laserSight.Width = LaserSightWidth;\n            _laserSight.DefaultColor = LaserSightColor;\n            _laserSight.BeginCapMode = Line2D.LineCapMode.Round;\n            _laserSight.EndCapMode = Line2D.LineCapMode.Round;\n\n            if (_laserSight.GetPointCount() < 2)\n            {\n                _laserSight.ClearPoints();\n                _laserSight.AddPoint(Vector2.Zero);\n                _laserSight.AddPoint(Vector2.Right * LaserSightLength);\n            }\n        }\n\n        UpdateLaserSightVisibility();\n        GD.Print(\"[SniperRifle] ASVK initialized - bolt ready, laser sight enabled\");\n    }\n\n    public override void _ExitTree()\n    {\n        // Clean up scope overlay when weapon is removed from scene tree\n        if (_isScopeActive)\n        {\n            DeactivateScope();\n        }\n        base._ExitTree();\n    }\n\n    public override void _Process(double delta)\n    {\n        base._Process(delta);\n\n        // Update time since last shot for recoil recovery\n        _timeSinceLastShot += (float)delta;\n\n        // Recover recoil after delay\n        if (_timeSinceLastShot >= RecoilRecoveryDelay && _recoilOffset != 0)\n        {\n            float recoveryAmount = RecoilRecoverySpeed * (float)delta;\n            _recoilOffset = Mathf.MoveToward(_recoilOffset, 0, recoveryAmount);\n        }\n\n        // Always update aim direction and rifle sprite rotation\n        UpdateAimDirection();\n\n        // Update laser sight to point towards mouse (with recoil offset)\n        if (LaserSightEnabled && _laserSight != null)\n        {\n            UpdateLaserSight();\n        }\n\n        // Handle bolt-action input\n        HandleBoltActionInput();\n\n        // Update scope system (sway, camera offset, overlay)\n        UpdateScope((float)delta);\n    }\n\n    // =========================================================================\n    // Bolt-Action Charging Mechanics\n    // =========================================================================\n\n    /// <summary>\n    /// Handles the bolt-action charging input sequence.\n    /// Sequence: Down (pull bolt) ‚Üí Left (open bolt) ‚Üí Down (close bolt) ‚Üí Up (chamber round)\n    /// Uses the arrow keys / WASD movement input actions.\n    /// </summary>\n    private void HandleBoltActionInput()\n    {\n        switch (_boltStep)\n        {\n            case BoltActionStep.NeedsBoltCycle:\n                // Step 1: Down arrow - pull bolt back\n                if (Input.IsActionJustPressed(\"move_down\"))\n                {\n                    _boltStep = BoltActionStep.WaitOpenBolt;\n                    EmitSignal(SignalName.BoltStepChanged, 1, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 1/4: Bolt pulled back\");\n                }\n                break;\n\n            case BoltActionStep.WaitOpenBolt:\n                // Step 2: Left arrow - open bolt\n                if (Input.IsActionJustPressed(\"move_left\"))\n                {\n                    _boltStep = BoltActionStep.WaitCloseBolt;\n                    EmitSignal(SignalName.BoltStepChanged, 2, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 2/4: Bolt opened\");\n                }\n                break;\n\n            case BoltActionStep.WaitCloseBolt:\n                // Step 3: Down arrow - close bolt\n                if (Input.IsActionJustPressed(\"move_down\"))\n                {\n                    _boltStep = BoltActionStep.WaitChamberRound;\n                    EmitSignal(SignalName.BoltStepChanged, 3, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 3/4: Bolt closed\");\n                }\n                break;\n\n            case BoltActionStep.WaitChamberRound:\n                // Step 4: Up arrow - chamber round\n                if (Input.IsActionJustPressed(\"move_up\"))\n                {\n                    _boltStep = BoltActionStep.Ready;\n                    EmitSignal(SignalName.BoltStepChanged, 4, 4);\n                    PlayBoltChamberSound();\n                    GD.Print(\"[SniperRifle] Bolt step 4/4: Round chambered - READY TO FIRE\");\n                }\n                break;\n\n            case BoltActionStep.Ready:\n                // Already ready, no bolt action needed\n                break;\n        }\n    }\n\n    /// <summary>\n    /// Plays the bolt manipulation sound.\n    /// </summary>\n    private void PlayBoltSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_bolt\"))\n        {\n            audioManager.Call(\"play_m16_bolt\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Plays the bolt chamber/ready sound.\n    /// </summary>\n    private void PlayBoltChamberSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_bolt\"))\n        {\n            audioManager.Call(\"play_m16_bolt\", GlobalPosition);\n        }\n    }\n\n    // =========================================================================\n    // Aiming and Laser Sight\n    // =========================================================================\n\n    /// <summary>\n    /// Updates the aim direction and rifle sprite rotation.\n    /// </summary>\n    private void UpdateAimDirection()\n    {\n        Vector2 mousePos = GetGlobalMousePosition();\n        Vector2 toMouse = mousePos - GlobalPosition;\n        float targetAngle = toMouse.Angle();\n\n        if (!_aimAngleInitialized)\n        {\n            _currentAimAngle = targetAngle;\n            _aimAngleInitialized = true;\n        }\n\n        Vector2 direction;\n\n        // Apply sensitivity for the sniper rifle\n        if (WeaponData != null && WeaponData.Sensitivity > 0)\n        {\n            float angleDiff = Mathf.Wrap(targetAngle - _currentAimAngle, -Mathf.Pi, Mathf.Pi);\n            float rotationSpeed = WeaponData.Sensitivity * 10.0f;\n            float delta = (float)GetProcessDeltaTime();\n            float maxRotation = rotationSpeed * delta;\n            float actualRotation = Mathf.Clamp(angleDiff, -maxRotation, maxRotation);\n            _currentAimAngle += actualRotation;\n            direction = new Vector2(Mathf.Cos(_currentAimAngle), Mathf.Sin(_currentAimAngle));\n        }\n        else\n        {\n            if (toMouse.LengthSquared() > 0.001f)\n            {\n                direction = toMouse.Normalized();\n                _currentAimAngle = targetAngle;\n            }\n            else\n            {\n                direction = _aimDirection;\n            }\n        }\n\n        _aimDirection = direction;\n        UpdateRifleSpriteRotation(direction);\n    }\n\n    /// <summary>\n    /// Creates the laser sight Line2D programmatically.\n    /// </summary>\n    private void CreateLaserSight()\n    {\n        _laserSight = new Line2D\n        {\n            Name = \"LaserSight\",\n            Width = LaserSightWidth,\n            DefaultColor = LaserSightColor,\n            BeginCapMode = Line2D.LineCapMode.Round,\n            EndCapMode = Line2D.LineCapMode.Round\n        };\n\n        _laserSight.AddPoint(Vector2.Zero);\n        _laserSight.AddPoint(Vector2.Right * LaserSightLength);\n\n        AddChild(_laserSight);\n    }\n\n    /// <summary>\n    /// Updates the laser sight visualization with recoil offset.\n    /// Uses raycasting to stop at obstacles.\n    /// </summary>\n    private void UpdateLaserSight()\n    {\n        if (_laserSight == null)\n        {\n            return;\n        }\n\n        Vector2 laserDirection = _aimDirection.Rotated(_recoilOffset);\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float maxLaserLength = viewportSize.Length();\n\n        Vector2 endPoint = laserDirection * maxLaserLength;\n\n        var spaceState = GetWorld2D().DirectSpaceState;\n        var query = PhysicsRayQueryParameters2D.Create(\n            GlobalPosition,\n            GlobalPosition + endPoint,\n            4 // Collision mask for obstacles (layer 3 = value 4)\n        );\n\n        var result = spaceState.IntersectRay(query);\n\n        if (result.Count > 0)\n        {\n            Vector2 hitPosition = (Vector2)result[\"position\"];\n            endPoint = hitPosition - GlobalPosition;\n        }\n\n        _laserSight.SetPointPosition(0, Vector2.Zero);\n        _laserSight.SetPointPosition(1, endPoint);\n    }\n\n    /// <summary>\n    /// Updates the visibility of the laser sight.\n    /// </summary>\n    private void UpdateLaserSightVisibility()\n    {\n        if (_laserSight != null)\n        {\n            _laserSight.Visible = LaserSightEnabled;\n        }\n    }\n\n    /// <summary>\n    /// Updates the rifle sprite rotation to match aim direction.\n    /// </summary>\n    private void UpdateRifleSpriteRotation(Vector2 direction)\n    {\n        if (_rifleSprite == null)\n        {\n            return;\n        }\n\n        float angle = direction.Angle();\n        _rifleSprite.Rotation = angle;\n\n        bool aimingLeft = Mathf.Abs(angle) > Mathf.Pi / 2;\n        _rifleSprite.FlipV = aimingLeft;\n    }\n\n    /// <summary>\n    /// Enables or disables the laser sight.\n    /// </summary>\n    public void SetLaserSightEnabled(bool enabled)\n    {\n        LaserSightEnabled = enabled;\n        UpdateLaserSightVisibility();\n    }\n\n    // =========================================================================\n    // Firing\n    // =========================================================================\n\n    /// <summary>\n    /// Fires the sniper rifle. Only fires if bolt is ready.\n    /// After firing, transitions to NeedsBoltCycle state.\n    /// </summary>\n    public override bool Fire(Vector2 direction)\n    {\n        // Check for empty magazine\n        if (CurrentAmmo <= 0)\n        {\n            PlayEmptyClickSound();\n            return false;\n        }\n\n        // Check if bolt is ready\n        if (!IsBoltReady)\n        {\n            // Play a click to indicate bolt not cycled\n            PlayEmptyClickSound();\n            return false;\n        }\n\n        // Check standard fire conditions\n        if (!CanFire || WeaponData == null || BulletScene == null)\n        {\n            return false;\n        }\n\n        // Apply recoil to aim direction\n        Vector2 spreadDirection = ApplyRecoil(_aimDirection);\n        bool result = base.Fire(spreadDirection);\n\n        if (result)\n        {\n            // Transition to needs bolt cycle\n            _boltStep = BoltActionStep.NeedsBoltCycle;\n            EmitSignal(SignalName.BoltStepChanged, 0, 4);\n\n            // Play sniper shot sound\n            PlaySniperShotSound();\n            // Emit gunshot sound for enemy detection\n            EmitGunshotSound();\n            // Play shell casing with delay\n            PlayShellCasingDelayed();\n            // Trigger heavy screen shake\n            TriggerScreenShake(spreadDirection);\n\n            // Spawn smoky tracer trail\n            SpawnSmokyTracer(GlobalPosition, spreadDirection);\n\n            GD.Print(\"[SniperRifle] FIRED! Bolt needs cycling. Ammo remaining: \" + CurrentAmmo);\n        }\n\n        return result;\n    }\n\n    /// <summary>\n    /// Override SpawnBullet to configure the SniperBullet for sniper behavior:\n    /// - Very high damage (50)\n    /// - Passes through enemies (doesn't destroy on hit)\n    /// - Penetrates through 2 walls (wall-count based, not distance-based)\n    /// </summary>\n    protected override void SpawnBullet(Vector2 direction)\n    {\n        if (BulletScene == null)\n        {\n            return;\n        }\n\n        // Check bullet spawn path\n        var (isBlocked, hitPosition, hitNormal) = CheckBulletSpawnPath(direction);\n\n        Vector2 spawnPosition;\n        if (isBlocked)\n        {\n            spawnPosition = GlobalPosition + direction * 2.0f;\n            GD.Print(\"[SniperRifle] Point-blank shot: spawning for penetration\");\n        }\n        else\n        {\n            spawnPosition = GlobalPosition + direction * BulletSpawnOffset;\n        }\n\n        var bulletNode = BulletScene.Instantiate<Node2D>();\n        bulletNode.GlobalPosition = spawnPosition;\n\n        // Try to cast to C# SniperBullet for direct property access\n        var sniperBullet = bulletNode as SniperBullet;\n\n        if (sniperBullet != null)\n        {\n            // SniperBullet - set properties directly\n            sniperBullet.Direction = direction;\n            if (WeaponData != null)\n            {\n                sniperBullet.Speed = WeaponData.BulletSpeed;\n                sniperBullet.Damage = WeaponData.Damage;\n            }\n            var owner = GetParent();\n            if (owner != null)\n            {\n                sniperBullet.ShooterId = owner.GetInstanceId();\n            }\n            sniperBullet.ShooterPosition = GlobalPosition;\n            sniperBullet.MaxWallPenetrations = MaxWallPenetrations;\n            GD.Print($\"[SniperRifle] Spawned SniperBullet: Damage={sniperBullet.Damage}, Speed={sniperBullet.Speed}, MaxWallPen={MaxWallPenetrations}\");\n        }\n        else\n        {\n            // Fallback for any bullet type\n            if (bulletNode.HasMethod(\"SetDirection\"))\n            {\n                bulletNode.Call(\"SetDirection\", direction);\n            }\n            else\n            {\n                bulletNode.Set(\"Direction\", direction);\n                bulletNode.Set(\"direction\", direction);\n            }\n\n            if (WeaponData != null)\n            {\n                bulletNode.Set(\"Speed\", WeaponData.BulletSpeed);\n                bulletNode.Set(\"speed\", WeaponData.BulletSpeed);\n                bulletNode.Set(\"Damage\", WeaponData.Damage);\n                bulletNode.Set(\"damage\", WeaponData.Damage);\n            }\n\n            var owner = GetParent();\n            if (owner != null)\n            {\n                bulletNode.Set(\"ShooterId\", owner.GetInstanceId());\n                bulletNode.Set(\"shooter_id\", owner.GetInstanceId());\n            }\n\n            bulletNode.Set(\"ShooterPosition\", GlobalPosition);\n            bulletNode.Set(\"shooter_position\", GlobalPosition);\n        }\n\n        GetTree().CurrentScene.AddChild(bulletNode);\n\n        // Spawn muzzle flash effect - large flash for 12.7mm\n        SpawnMuzzleFlash(spawnPosition, direction, WeaponData?.Caliber);\n\n        // Spawn casing\n        SpawnCasing(direction, WeaponData?.Caliber);\n    }\n\n    // =========================================================================\n    // Smoky Tracer Trail\n    // =========================================================================\n\n    /// <summary>\n    /// Spawns a smoky dissipating tracer trail from the fire position\n    /// in the shooting direction across the entire map.\n    /// The tracer is an instant visual effect (like a contrail from a plane)\n    /// that fades out over time.\n    /// </summary>\n    private void SpawnSmokyTracer(Vector2 fromPosition, Vector2 direction)\n    {\n        // Calculate tracer end point - extend to edge of map (very far)\n        float tracerLength = 5000.0f; // Far enough to reach any map edge\n        Vector2 endPosition = fromPosition + direction * tracerLength;\n\n        // Create the tracer as a Line2D with smoke-like appearance\n        var tracer = new Line2D\n        {\n            Name = \"SniperTracer\",\n            Width = 6.0f,\n            DefaultColor = new Color(0.8f, 0.8f, 0.8f, 0.7f),\n            BeginCapMode = Line2D.LineCapMode.Round,\n            EndCapMode = Line2D.LineCapMode.Round,\n            TopLevel = true,\n            Position = Vector2.Zero,\n            ZIndex = -1 // Behind other elements\n        };\n\n        // Set up width curve - wider at start, tapers to narrower at end\n        var widthCurve = new Curve();\n        widthCurve.AddPoint(new Vector2(0.0f, 1.0f));\n        widthCurve.AddPoint(new Vector2(0.3f, 0.8f));\n        widthCurve.AddPoint(new Vector2(1.0f, 0.3f));\n        tracer.WidthCurve = widthCurve;\n\n        // Set up gradient - smoky white/gray that fades out\n        var gradient = new Gradient();\n        gradient.SetColor(0, new Color(0.9f, 0.9f, 0.85f, 0.8f));\n        gradient.AddPoint(0.5f, new Color(0.7f, 0.7f, 0.65f, 0.5f));\n        gradient.SetColor(gradient.GetPointCount() - 1, new Color(0.5f, 0.5f, 0.5f, 0.2f));\n        tracer.Gradient = gradient;\n\n        // Add the tracer line points (using global coordinates since TopLevel=true)\n        tracer.AddPoint(fromPosition + direction * BulletSpawnOffset);\n        tracer.AddPoint(endPosition);\n\n        // Add to scene\n        GetTree().CurrentScene.AddChild(tracer);\n\n        // Start the fade-out animation\n        FadeOutTracer(tracer);\n    }\n\n    /// <summary>\n    /// Animates the tracer trail fading out and dissipating over time.\n    /// The tracer gradually becomes more transparent and wider (simulating smoke dissipation).\n    /// </summary>\n    private async void FadeOutTracer(Line2D tracer)\n    {\n        float fadeDuration = 2.0f;\n        float elapsed = 0.0f;\n\n        float initialWidth = tracer.Width;\n\n        while (elapsed < fadeDuration && IsInstanceValid(tracer))\n        {\n            elapsed += (float)GetProcessDeltaTime();\n            float progress = elapsed / fadeDuration;\n\n            // Fade the alpha\n            float alpha = Mathf.Lerp(0.7f, 0.0f, progress);\n            tracer.DefaultColor = new Color(0.8f, 0.8f, 0.8f, alpha);\n\n            // Widen slightly to simulate smoke dissipation\n            tracer.Width = initialWidth + progress * 4.0f;\n\n            // Update gradient alpha\n            var gradient = new Gradient();\n            gradient.SetColor(0, new Color(0.9f, 0.9f, 0.85f, alpha));\n            gradient.AddPoint(0.5f, new Color(0.7f, 0.7f, 0.65f, alpha * 0.6f));\n            gradient.SetColor(gradient.GetPointCount() - 1, new Color(0.5f, 0.5f, 0.5f, alpha * 0.3f));\n            tracer.Gradient = gradient;\n\n            await ToSignal(GetTree(), \"process_frame\");\n        }\n\n        // Remove the tracer after fade completes\n        if (IsInstanceValid(tracer))\n        {\n            tracer.QueueFree();\n        }\n    }\n\n    // =========================================================================\n    // Sound and Effects\n    // =========================================================================\n\n    /// <summary>\n    /// Plays the sniper shot sound via AudioManager.\n    /// </summary>\n    private void PlaySniperShotSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        // Use M16 shot as a placeholder sound for the sniper\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_shot\"))\n        {\n            audioManager.Call(\"play_m16_shot\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Plays the empty gun click sound.\n    /// </summary>\n    private void PlayEmptyClickSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_empty_click\"))\n        {\n            audioManager.Call(\"play_empty_click\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Emits gunshot sound for enemy detection via SoundPropagation.\n    /// Very loud for the 12.7mm round.\n    /// </summary>\n    private void EmitGunshotSound()\n    {\n        var soundPropagation = GetNodeOrNull(\"/root/SoundPropagation\");\n        if (soundPropagation != null && soundPropagation.HasMethod(\"emit_sound\"))\n        {\n            float loudness = WeaponData?.Loudness ?? 3000.0f;\n            soundPropagation.Call(\"emit_sound\", 0, GlobalPosition, 0, this, loudness);\n        }\n    }\n\n    /// <summary>\n    /// Plays shell casing sound with a delay.\n    /// </summary>\n    private async void PlayShellCasingDelayed()\n    {\n        await ToSignal(GetTree().CreateTimer(0.2), \"timeout\");\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_shell_rifle\"))\n        {\n            audioManager.Call(\"play_shell_rifle\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Applies recoil to shooting direction.\n    /// </summary>\n    private Vector2 ApplyRecoil(Vector2 direction)\n    {\n        // Apply current recoil offset\n        Vector2 result = direction.Rotated(_recoilOffset);\n\n        // Add strong recoil for next shot (heavy 12.7mm kick)\n        float recoilDirection = (float)GD.RandRange(-1.0, 1.0);\n        _recoilOffset += recoilDirection * RecoilPerShot;\n        _recoilOffset = Mathf.Clamp(_recoilOffset, -MaxRecoilOffset, MaxRecoilOffset);\n\n        _timeSinceLastShot = 0;\n\n        return result;\n    }\n\n    /// <summary>\n    /// Triggers screen shake from sniper shot.\n    /// Heavy shake for 12.7mm round.\n    /// </summary>\n    private void TriggerScreenShake(Vector2 shootDirection)\n    {\n        if (WeaponData == null || WeaponData.ScreenShakeIntensity <= 0)\n        {\n            return;\n        }\n\n        var screenShakeManager = GetNodeOrNull(\"/root/ScreenShakeManager\");\n        if (screenShakeManager == null || !screenShakeManager.HasMethod(\"add_shake\"))\n        {\n            return;\n        }\n\n        // Heavy shake for sniper\n        float fireRate = WeaponData.FireRate;\n        float shakeIntensity;\n        if (fireRate > 0)\n        {\n            shakeIntensity = WeaponData.ScreenShakeIntensity / fireRate * 10.0f;\n        }\n        else\n        {\n            shakeIntensity = WeaponData.ScreenShakeIntensity;\n        }\n\n        float recoveryTime = WeaponData.ScreenShakeMinRecoveryTime;\n\n        screenShakeManager.Call(\"add_shake\", shootDirection, shakeIntensity, recoveryTime);\n    }\n\n    /// <summary>\n    /// Fires the bullet in the chamber during reload sequence.\n    /// </summary>\n    public override bool FireChamberBullet(Vector2 direction)\n    {\n        // Sniper rifle doesn't support chamber bullet during reload\n        // (bolt-action requires full cycle)\n        return false;\n    }\n\n    /// <summary>\n    /// Gets the current aim direction.\n    /// </summary>\n    public Vector2 AimDirection => _aimDirection;\n\n    /// <summary>\n    /// Gets the current bolt-action step.\n    /// </summary>\n    public BoltActionStep CurrentBoltStep => _boltStep;\n\n    /// <summary>\n    /// Resets the bolt to ready state (e.g., after reload with a new magazine).\n    /// </summary>\n    public void ResetBolt()\n    {\n        _boltStep = BoltActionStep.Ready;\n        EmitSignal(SignalName.BoltStepChanged, 4, 4);\n        GD.Print(\"[SniperRifle] Bolt reset to ready state\");\n    }\n\n    // =========================================================================\n    // Scope / Aiming System (RMB)\n    // =========================================================================\n\n    /// <summary>\n    /// Whether the scope is currently active (RMB held).\n    /// </summary>\n    private bool _isScopeActive = false;\n\n    /// <summary>\n    /// Whether the scope is active (read-only property for external access).\n    /// </summary>\n    public bool IsScopeActive => _isScopeActive;\n\n    /// <summary>\n    /// Signal emitted when scope state changes.\n    /// </summary>\n    [Signal]\n    public delegate void ScopeStateChangedEventHandler(bool isActive);\n\n    /// <summary>\n    /// Current scope zoom distance multiplier (how far beyond viewport the player can see).\n    /// 1.0 = one viewport distance, 2.0 = two viewport distances.\n    /// Controlled by mouse wheel while scoping.\n    /// </summary>\n    private float _scopeZoomDistance = 1.0f;\n\n    /// <summary>\n    /// Minimum scope zoom distance (viewport multiplier).\n    /// Set to 1.0 so the scope always looks beyond the normal viewport.\n    /// </summary>\n    private const float MinScopeZoomDistance = 1.0f;\n\n    /// <summary>\n    /// Maximum scope zoom distance (viewport multiplier).\n    /// </summary>\n    private const float MaxScopeZoomDistance = 3.0f;\n\n    /// <summary>\n    /// Step size for mouse wheel zoom adjustment.\n    /// </summary>\n    private const float ScopeZoomStep = 0.25f;\n\n    /// <summary>\n    /// Base sway amplitude in pixels at 1 viewport distance.\n    /// </summary>\n    private const float BaseScopeSwayAmplitude = 8.0f;\n\n    /// <summary>\n    /// Speed of the sway oscillation.\n    /// </summary>\n    private const float ScopeSwaySpeed = 2.5f;\n\n    /// <summary>\n    /// Maximum range (in viewport fraction) that the player can fine-tune the scope\n    /// distance via mouse movement while scoped. About 1/3 of the viewport.\n    /// </summary>\n    private const float ScopeMouseFineTuneRange = 0.33f;\n\n    /// <summary>\n    /// Current mouse fine-tune offset applied to scope distance.\n    /// Ranges from -ScopeMouseFineTuneRange to +ScopeMouseFineTuneRange (viewport fraction).\n    /// Positive = further, negative = closer.\n    /// </summary>\n    private float _scopeMouseFineTuneOffset = 0.0f;\n\n    /// <summary>\n    /// Current scope sway time accumulator.\n    /// </summary>\n    private float _scopeSwayTime = 0.0f;\n\n    /// <summary>\n    /// Current scope sway offset in pixels (applied to camera).\n    /// </summary>\n    private Vector2 _scopeSwayOffset = Vector2.Zero;\n\n    /// <summary>\n    /// Reference to the scope overlay CanvasLayer (created when scope activates).\n    /// </summary>\n    private CanvasLayer? _scopeOverlay = null;\n\n    /// <summary>\n    /// Reference to the scope crosshair control node.\n    /// </summary>\n    private Control? _scopeCrosshair = null;\n\n    /// <summary>\n    /// Reference to the scope darkening background.\n    /// </summary>\n    private ColorRect? _scopeBackground = null;\n\n    /// <summary>\n    /// Cached reference to the player's Camera2D node.\n    /// </summary>\n    private Camera2D? _playerCamera = null;\n\n    /// <summary>\n    /// Original camera offset before scoping (to restore on exit).\n    /// </summary>\n    private Vector2 _originalCameraOffset = Vector2.Zero;\n\n    /// <summary>\n    /// Gets the effective scope zoom distance including mouse fine-tune offset.\n    /// </summary>\n    private float EffectiveScopeZoomDistance => _scopeZoomDistance + _scopeMouseFineTuneOffset;\n\n    /// <summary>\n    /// Gets the current camera offset for scope aiming.\n    /// Called by the player or level scripts to position the camera.\n    /// </summary>\n    public Vector2 GetScopeCameraOffset()\n    {\n        if (!_isScopeActive)\n        {\n            return Vector2.Zero;\n        }\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return Vector2.Zero;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float baseDistance = viewportSize.Length() * 0.5f;\n\n        // Camera offset = aim direction * (zoom distance + mouse fine-tune) * viewport size + sway\n        Vector2 offset = _aimDirection * baseDistance * EffectiveScopeZoomDistance + _scopeSwayOffset;\n\n        return offset;\n    }\n\n    /// <summary>\n    /// Gets the world-space position that the scope crosshair center is aiming at.\n    /// Used to direct bullets to the crosshair center.\n    /// </summary>\n    public Vector2 GetScopeAimTarget()\n    {\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return GlobalPosition + _aimDirection * 1000.0f;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float baseDistance = viewportSize.Length() * 0.5f;\n\n        // The scope aim target is the player's position offset by the scope camera offset\n        // (without sway, so bullets go to the true center, not the swaying crosshair)\n        Vector2 aimTarget = GlobalPosition + _aimDirection * baseDistance * EffectiveScopeZoomDistance;\n\n        return aimTarget;\n    }\n\n    /// <summary>\n    /// Activates the scope (called when RMB is pressed).\n    /// </summary>\n    public void ActivateScope()\n    {\n        if (_isScopeActive)\n        {\n            return;\n        }\n\n        _isScopeActive = true;\n        _scopeSwayTime = 0.0f;\n        _scopeMouseFineTuneOffset = 0.0f;\n\n        // Find and cache the player's Camera2D\n        FindPlayerCamera();\n\n        // Store original camera offset\n        if (_playerCamera != null)\n        {\n            _originalCameraOffset = _playerCamera.Offset;\n        }\n\n        // Create the scope overlay\n        CreateScopeOverlay();\n\n        EmitSignal(SignalName.ScopeStateChanged, true);\n        GD.Print($\"[SniperRifle] Scope activated. Zoom distance: {_scopeZoomDistance:F1}x\");\n    }\n\n    /// <summary>\n    /// Deactivates the scope (called when RMB is released).\n    /// </summary>\n    public void DeactivateScope()\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        _isScopeActive = false;\n\n        // Restore original camera offset\n        if (_playerCamera != null)\n        {\n            _playerCamera.Offset = _originalCameraOffset;\n        }\n\n        // Remove scope overlay\n        RemoveScopeOverlay();\n\n        EmitSignal(SignalName.ScopeStateChanged, false);\n        GD.Print(\"[SniperRifle] Scope deactivated.\");\n    }\n\n    /// <summary>\n    /// Adjusts the scope zoom distance (called on mouse wheel while scoping).\n    /// </summary>\n    public void AdjustScopeZoom(float direction)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        _scopeZoomDistance += direction * ScopeZoomStep;\n        _scopeZoomDistance = Mathf.Clamp(_scopeZoomDistance, MinScopeZoomDistance, MaxScopeZoomDistance);\n\n        // Reset fine-tune offset when zoom changes to avoid going out of range\n        _scopeMouseFineTuneOffset = Mathf.Clamp(_scopeMouseFineTuneOffset,\n            -ScopeMouseFineTuneRange, ScopeMouseFineTuneRange);\n\n        GD.Print($\"[SniperRifle] Scope zoom adjusted: {_scopeZoomDistance:F2}x (fine-tune: {_scopeMouseFineTuneOffset:F2})\");\n    }\n\n    /// <summary>\n    /// Adjusts the scope fine-tune offset based on mouse movement along the aim direction.\n    /// Allows the player to look slightly closer or further (about 1/3 viewport range).\n    /// Called from Player.cs when mouse moves while scoped.\n    /// </summary>\n    public void AdjustScopeFineTune(Vector2 mouseMotion)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        // Project mouse motion onto the aim direction to get forward/backward movement\n        // Moving mouse in the aim direction = further, opposite = closer\n        float projection = mouseMotion.Dot(_aimDirection);\n\n        // Scale the projection: mouse sensitivity for scope fine-tuning\n        // A moderate movement across the screen should give the full range\n        float sensitivity = 0.002f;\n        _scopeMouseFineTuneOffset += projection * sensitivity;\n        _scopeMouseFineTuneOffset = Mathf.Clamp(_scopeMouseFineTuneOffset,\n            -ScopeMouseFineTuneRange, ScopeMouseFineTuneRange);\n    }\n\n    /// <summary>\n    /// Finds the player's Camera2D node by traversing up to the parent (player).\n    /// </summary>\n    private void FindPlayerCamera()\n    {\n        if (_playerCamera != null)\n        {\n            return;\n        }\n\n        var parent = GetParent();\n        if (parent != null)\n        {\n            _playerCamera = parent.GetNodeOrNull<Camera2D>(\"Camera2D\");\n        }\n    }\n\n    /// <summary>\n    /// Updates the scope system each frame (called from _Process).\n    /// </summary>\n    private void UpdateScope(float delta)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        // Update sway\n        _scopeSwayTime += delta;\n        float swayAmplitude = BaseScopeSwayAmplitude * _scopeZoomDistance;\n\n        // Use two sine waves at different frequencies for natural-looking sway\n        float swayX = Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 1.0f) * swayAmplitude\n                    + Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 2.3f) * swayAmplitude * 0.3f;\n        float swayY = Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 1.4f) * swayAmplitude\n                    + Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 0.7f) * swayAmplitude * 0.4f;\n\n        _scopeSwayOffset = new Vector2(swayX, swayY);\n\n        // Update camera offset for scope view\n        if (_playerCamera != null)\n        {\n            _playerCamera.Offset = _originalCameraOffset + GetScopeCameraOffset();\n        }\n\n        // Update scope overlay crosshair position with sway\n        UpdateScopeOverlayPosition();\n    }\n\n    /// <summary>\n    /// Creates the scope overlay UI with crosshair and darkened edges.\n    /// </summary>\n    private void CreateScopeOverlay()\n    {\n        RemoveScopeOverlay();\n\n        _scopeOverlay = new CanvasLayer\n        {\n            Name = \"ScopeOverlay\",\n            Layer = 10\n        };\n\n        Viewport? viewport = GetViewport();\n        Vector2 viewportSize = viewport?.GetVisibleRect().Size ?? new Vector2(1280, 720);\n\n        // Dark background with circular cutout effect (vignette)\n        _scopeBackground = new ColorRect\n        {\n            Name = \"ScopeBackground\",\n            Color = new Color(0.0f, 0.0f, 0.0f, 0.5f),\n            Size = viewportSize,\n            Position = Vector2.Zero,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        _scopeOverlay.AddChild(_scopeBackground);\n\n        // Create the crosshair as a Control node\n        _scopeCrosshair = new Control\n        {\n            Name = \"ScopeCrosshair\",\n            Position = viewportSize / 2,\n            Size = Vector2.Zero,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        _scopeOverlay.AddChild(_scopeCrosshair);\n\n        // Add crosshair lines - based on the reference image from the issue\n        // The scope has a classic crosshair with circle and mil-dots\n\n        // Outer circle\n        float circleRadius = Mathf.Min(viewportSize.X, viewportSize.Y) * 0.35f;\n        int segments = 64;\n        var outerCircle = new Line2D\n        {\n            Name = \"OuterCircle\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f),\n            Antialiased = true\n        };\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            outerCircle.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * circleRadius);\n        }\n        _scopeCrosshair.AddChild(outerCircle);\n\n        // Inner thin circle\n        float innerRadius = circleRadius * 0.05f;\n        var innerCircle = new Line2D\n        {\n            Name = \"InnerCircle\",\n            Width = 1.5f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f),\n            Antialiased = true\n        };\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            innerCircle.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * innerRadius);\n        }\n        _scopeCrosshair.AddChild(innerCircle);\n\n        // Horizontal crosshair line (left)\n        var hLineLeft = new Line2D\n        {\n            Name = \"HLineLeft\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        hLineLeft.AddPoint(new Vector2(-circleRadius, 0));\n        hLineLeft.AddPoint(new Vector2(-innerRadius, 0));\n        _scopeCrosshair.AddChild(hLineLeft);\n\n        // Horizontal crosshair line (right)\n        var hLineRight = new Line2D\n        {\n            Name = \"HLineRight\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        hLineRight.AddPoint(new Vector2(innerRadius, 0));\n        hLineRight.AddPoint(new Vector2(circleRadius, 0));\n        _scopeCrosshair.AddChild(hLineRight);\n\n        // Vertical crosshair line (top)\n        var vLineTop = new Line2D\n        {\n            Name = \"VLineTop\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        vLineTop.AddPoint(new Vector2(0, -circleRadius));\n        vLineTop.AddPoint(new Vector2(0, -innerRadius));\n        _scopeCrosshair.AddChild(vLineTop);\n\n        // Vertical crosshair line (bottom) with mil-dots\n        var vLineBottom = new Line2D\n        {\n            Name = \"VLineBottom\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        vLineBottom.AddPoint(new Vector2(0, innerRadius));\n        vLineBottom.AddPoint(new Vector2(0, circleRadius));\n        _scopeCrosshair.AddChild(vLineBottom);\n\n        // Add mil-dot markers on the bottom crosshair (range estimation)\n        float dotSpacing = circleRadius * 0.15f;\n        for (int i = 1; i <= 4; i++)\n        {\n            float dotY = dotSpacing * i;\n            var dot = new Line2D\n            {\n                Name = $\"MilDot_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            float dotWidth = 4.0f - i * 0.5f; // Dots get smaller further from center\n            dot.AddPoint(new Vector2(-dotWidth, dotY));\n            dot.AddPoint(new Vector2(dotWidth, dotY));\n            _scopeCrosshair.AddChild(dot);\n        }\n\n        // Add mil-dot markers on horizontal lines\n        for (int i = 1; i <= 3; i++)\n        {\n            float dotX = dotSpacing * i;\n            // Right side dots\n            var dotRight = new Line2D\n            {\n                Name = $\"HMilDotRight_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            float dotHeight = 4.0f - i * 0.5f;\n            dotRight.AddPoint(new Vector2(dotX, -dotHeight));\n            dotRight.AddPoint(new Vector2(dotX, dotHeight));\n            _scopeCrosshair.AddChild(dotRight);\n\n            // Left side dots\n            var dotLeft = new Line2D\n            {\n                Name = $\"HMilDotLeft_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            dotLeft.AddPoint(new Vector2(-dotX, -dotHeight));\n            dotLeft.AddPoint(new Vector2(-dotX, dotHeight));\n            _scopeCrosshair.AddChild(dotLeft);\n        }\n\n        // Add thick outer ring to mask edges (simulate scope tube)\n        var scopeRing = new Line2D\n        {\n            Name = \"ScopeRing\",\n            Width = 6.0f,\n            DefaultColor = new Color(0.1f, 0.1f, 0.1f, 0.95f),\n            Antialiased = true\n        };\n        float ringRadius = circleRadius + 3.0f;\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            scopeRing.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * ringRadius);\n        }\n        _scopeCrosshair.AddChild(scopeRing);\n\n        // Zoom distance indicator text\n        var zoomLabel = new Label\n        {\n            Name = \"ZoomLabel\",\n            Position = new Vector2(circleRadius * 0.5f, circleRadius * 0.7f),\n            Text = $\"{_scopeZoomDistance:F1}x\",\n            HorizontalAlignment = HorizontalAlignment.Center,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        zoomLabel.AddThemeColorOverride(\"font_color\", new Color(0.0f, 0.0f, 0.0f, 0.6f));\n        zoomLabel.AddThemeFontSizeOverride(\"font_size\", 12);\n        _scopeCrosshair.AddChild(zoomLabel);\n\n        GetTree().CurrentScene.AddChild(_scopeOverlay);\n    }\n\n    /// <summary>\n    /// Updates the scope overlay crosshair position with sway applied.\n    /// </summary>\n    private void UpdateScopeOverlayPosition()\n    {\n        if (_scopeCrosshair == null || _scopeOverlay == null)\n        {\n            return;\n        }\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n\n        // Crosshair stays centered but sways\n        _scopeCrosshair.Position = viewportSize / 2 + _scopeSwayOffset;\n\n        // Update zoom label\n        var zoomLabel = _scopeCrosshair.GetNodeOrNull<Label>(\"ZoomLabel\");\n        if (zoomLabel != null)\n        {\n            zoomLabel.Text = $\"{_scopeZoomDistance:F1}x\";\n        }\n    }\n\n    /// <summary>\n    /// Removes the scope overlay from the scene.\n    /// </summary>\n    private void RemoveScopeOverlay()\n    {\n        if (_scopeOverlay != null && IsInstanceValid(_scopeOverlay))\n        {\n            _scopeOverlay.QueueFree();\n            _scopeOverlay = null;\n            _scopeCrosshair = null;\n            _scopeBackground = null;\n        }\n    }\n}\n",
    "structuredPatch": [
      {
        "oldStart": 1175,
        "oldLines": 9,
        "newStart": 1175,
        "newLines": 9,
        "lines": [
          "             return;",
          "         }",
          " ",
          "-        // Update sway",
          "+        // Update sway (scales with effective distance including fine-tune offset)",
          "         _scopeSwayTime += delta;",
          "-        float swayAmplitude = BaseScopeSwayAmplitude * _scopeZoomDistance;",
          "+        float swayAmplitude = BaseScopeSwayAmplitude * EffectiveScopeZoomDistance;",
          " ",
          "         // Use two sine waves at different frequencies for natural-looking sway",
          "         float swayX = Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 1.0f) * swayAmplitude"
        ]
      }
    ],
    "userModified": false,
    "replaceAll": false
  }
}
[2026-02-06T20:57:48.538Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01BnopxW8HsWUATkgCXJoiXG",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Also update the default `_scopeZoomDistance` to match the new minimum:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 299,
      "cache_read_input_tokens": 61870,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 299
      },
      "output_tokens": 1,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "b0354323-045d-406c-9422-83c09995d272"
}
[2026-02-06T20:57:49.765Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01BnopxW8HsWUATkgCXJoiXG",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01V2YnSnPJpW4UC7LqLEr9NS",
        "name": "Edit",
        "input": {
          "replace_all": false,
          "file_path": "/tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs",
          "old_string": "    private float _scopeZoomDistance = 1.0f;",
          "new_string": "    private float _scopeZoomDistance = 1.5f;"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 299,
      "cache_read_input_tokens": 61870,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 299
      },
      "output_tokens": 1,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "6f852a8a-d151-4ed6-be4a-67a1a6e9c668"
}
[2026-02-06T20:57:49.774Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01V2YnSnPJpW4UC7LqLEr9NS",
        "type": "tool_result",
        "content": "The file /tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs has been updated successfully."
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "8825b5f0-57c2-4c9d-9fc2-fd66382d1505",
  "tool_use_result": {
    "filePath": "/tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs",
    "oldString": "    private float _scopeZoomDistance = 1.0f;",
    "newString": "    private float _scopeZoomDistance = 1.5f;",
    "originalFile": "using Godot;\nusing GodotTopDownTemplate.AbstractClasses;\nusing GodotTopDownTemplate.Projectiles;\n\nnamespace GodotTopDownTemplate.Weapons;\n\n/// <summary>\n/// Bolt-action charging state for the ASVK sniper rifle.\n/// Before each shot, the player must complete a 4-step bolt-action sequence:\n/// Down (pull bolt back) ‚Üí Left (open bolt) ‚Üí Down (close bolt) ‚Üí Up (chamber round)\n/// </summary>\npublic enum BoltActionStep\n{\n    /// <summary>\n    /// Bolt is ready - weapon can fire. After firing, transitions to NeedsBoltCycle.\n    /// </summary>\n    Ready,\n\n    /// <summary>\n    /// Just fired - needs bolt cycling before next shot.\n    /// Waiting for Down arrow (pull bolt back).\n    /// </summary>\n    NeedsBoltCycle,\n\n    /// <summary>\n    /// Step 1 complete (bolt pulled back). Waiting for Left arrow (open bolt).\n    /// </summary>\n    WaitOpenBolt,\n\n    /// <summary>\n    /// Step 2 complete (bolt opened). Waiting for Down arrow (close bolt).\n    /// </summary>\n    WaitCloseBolt,\n\n    /// <summary>\n    /// Step 3 complete (bolt closed). Waiting for Up arrow (chamber round).\n    /// </summary>\n    WaitChamberRound\n}\n\n/// <summary>\n/// ASVK sniper rifle - heavy anti-materiel bolt-action rifle.\n/// Features:\n/// - 12.7x108mm ammunition dealing 50 damage per shot\n/// - Penetrates through 2 walls and through enemies\n/// - Instant bullet speed with smoky dissipating tracer trail\n/// - Very high turn sensitivity\n/// - 5-round magazine with M16-style swap reload\n/// - Single-shot bolt-action with manual charging sequence (Down‚ÜíLeft‚ÜíDown‚ÜíUp)\n/// - Red laser sight for aiming\n/// Reference: ASVK (–ê–°–í–ö) anti-materiel sniper rifle\n/// </summary>\npublic partial class SniperRifle : BaseWeapon\n{\n    // =========================================================================\n    // Bolt-Action State\n    // =========================================================================\n\n    /// <summary>\n    /// Current bolt-action charging step.\n    /// </summary>\n    private BoltActionStep _boltStep = BoltActionStep.Ready;\n\n    /// <summary>\n    /// Whether the bolt action is ready to fire (chambered).\n    /// Initially true so first shot can be fired immediately.\n    /// </summary>\n    public bool IsBoltReady => _boltStep == BoltActionStep.Ready;\n\n    /// <summary>\n    /// Whether the weapon needs bolt cycling before it can fire again.\n    /// </summary>\n    public bool NeedsBoltCycle => _boltStep != BoltActionStep.Ready;\n\n    /// <summary>\n    /// Signal emitted when bolt-action step changes.\n    /// </summary>\n    [Signal]\n    public delegate void BoltStepChangedEventHandler(int step, int totalSteps);\n\n    // =========================================================================\n    // Smoky Tracer Trail\n    // =========================================================================\n\n    /// <summary>\n    /// Scene for the smoky tracer trail effect.\n    /// Created programmatically as a Line2D with smoke-like appearance.\n    /// </summary>\n    private Line2D? _lastTracerTrail;\n\n    // =========================================================================\n    // Laser Sight Configuration\n    // =========================================================================\n\n    /// <summary>\n    /// Whether the laser sight is enabled.\n    /// </summary>\n    [Export]\n    public bool LaserSightEnabled { get; set; } = true;\n\n    /// <summary>\n    /// Maximum length of the laser sight in pixels.\n    /// </summary>\n    [Export]\n    public float LaserSightLength { get; set; } = 500.0f;\n\n    /// <summary>\n    /// Color of the laser sight (red for sniper).\n    /// </summary>\n    [Export]\n    public Color LaserSightColor { get; set; } = new Color(1.0f, 0.0f, 0.0f, 0.5f);\n\n    /// <summary>\n    /// Width of the laser sight line.\n    /// </summary>\n    [Export]\n    public float LaserSightWidth { get; set; } = 2.0f;\n\n    /// <summary>\n    /// Reference to the Line2D node for the laser sight.\n    /// </summary>\n    private Line2D? _laserSight;\n\n    /// <summary>\n    /// Reference to the Sprite2D node for the rifle visual.\n    /// </summary>\n    private Sprite2D? _rifleSprite;\n\n    /// <summary>\n    /// Current aim direction based on laser sight.\n    /// </summary>\n    private Vector2 _aimDirection = Vector2.Right;\n\n    /// <summary>\n    /// Current aim angle in radians.\n    /// </summary>\n    private float _currentAimAngle = 0.0f;\n\n    /// <summary>\n    /// Whether the aim angle has been initialized.\n    /// </summary>\n    private bool _aimAngleInitialized = false;\n\n    /// <summary>\n    /// Current recoil offset angle in radians.\n    /// Heavy sniper recoil.\n    /// </summary>\n    private float _recoilOffset = 0.0f;\n\n    /// <summary>\n    /// Time since the last shot was fired, used for recoil recovery.\n    /// </summary>\n    private float _timeSinceLastShot = 0.0f;\n\n    /// <summary>\n    /// Time in seconds before recoil starts recovering.\n    /// Long delay for heavy sniper.\n    /// </summary>\n    private const float RecoilRecoveryDelay = 0.5f;\n\n    /// <summary>\n    /// Speed at which recoil recovers (radians per second).\n    /// </summary>\n    private const float RecoilRecoverySpeed = 3.0f;\n\n    /// <summary>\n    /// Maximum recoil offset in radians (about 15 degrees).\n    /// </summary>\n    private const float MaxRecoilOffset = 0.26f;\n\n    /// <summary>\n    /// Recoil amount per shot in radians.\n    /// Heavy kick for 12.7mm.\n    /// </summary>\n    private const float RecoilPerShot = 0.15f;\n\n    /// <summary>\n    /// Number of walls this bullet can penetrate through.\n    /// The bullet continues flying after penetrating walls.\n    /// </summary>\n    private const int MaxWallPenetrations = 2;\n\n    public override void _Ready()\n    {\n        base._Ready();\n\n        // Get the rifle sprite for visual representation\n        _rifleSprite = GetNodeOrNull<Sprite2D>(\"RifleSprite\");\n\n        if (_rifleSprite != null)\n        {\n            var texture = _rifleSprite.Texture;\n            GD.Print($\"[SniperRifle] RifleSprite found: visible={_rifleSprite.Visible}, z_index={_rifleSprite.ZIndex}, texture={(texture != null ? \"loaded\" : \"NULL\")}\");\n        }\n        else\n        {\n            GD.PrintErr(\"[SniperRifle] WARNING: RifleSprite node not found!\");\n        }\n\n        // Check for Power Fantasy mode blue laser\n        var difficultyManager = GetNodeOrNull(\"/root/DifficultyManager\");\n        if (difficultyManager != null)\n        {\n            var shouldForceBlueLaser = difficultyManager.Call(\"should_force_blue_laser_sight\");\n            if (shouldForceBlueLaser.AsBool())\n            {\n                var blueColorVariant = difficultyManager.Call(\"get_power_fantasy_laser_color\");\n                LaserSightColor = blueColorVariant.AsColor();\n                GD.Print($\"[SniperRifle] Power Fantasy mode: laser color set to blue {LaserSightColor}\");\n            }\n        }\n\n        // Get or create the laser sight Line2D\n        _laserSight = GetNodeOrNull<Line2D>(\"LaserSight\");\n\n        if (_laserSight == null && LaserSightEnabled)\n        {\n            CreateLaserSight();\n        }\n        else if (_laserSight != null)\n        {\n            _laserSight.Width = LaserSightWidth;\n            _laserSight.DefaultColor = LaserSightColor;\n            _laserSight.BeginCapMode = Line2D.LineCapMode.Round;\n            _laserSight.EndCapMode = Line2D.LineCapMode.Round;\n\n            if (_laserSight.GetPointCount() < 2)\n            {\n                _laserSight.ClearPoints();\n                _laserSight.AddPoint(Vector2.Zero);\n                _laserSight.AddPoint(Vector2.Right * LaserSightLength);\n            }\n        }\n\n        UpdateLaserSightVisibility();\n        GD.Print(\"[SniperRifle] ASVK initialized - bolt ready, laser sight enabled\");\n    }\n\n    public override void _ExitTree()\n    {\n        // Clean up scope overlay when weapon is removed from scene tree\n        if (_isScopeActive)\n        {\n            DeactivateScope();\n        }\n        base._ExitTree();\n    }\n\n    public override void _Process(double delta)\n    {\n        base._Process(delta);\n\n        // Update time since last shot for recoil recovery\n        _timeSinceLastShot += (float)delta;\n\n        // Recover recoil after delay\n        if (_timeSinceLastShot >= RecoilRecoveryDelay && _recoilOffset != 0)\n        {\n            float recoveryAmount = RecoilRecoverySpeed * (float)delta;\n            _recoilOffset = Mathf.MoveToward(_recoilOffset, 0, recoveryAmount);\n        }\n\n        // Always update aim direction and rifle sprite rotation\n        UpdateAimDirection();\n\n        // Update laser sight to point towards mouse (with recoil offset)\n        if (LaserSightEnabled && _laserSight != null)\n        {\n            UpdateLaserSight();\n        }\n\n        // Handle bolt-action input\n        HandleBoltActionInput();\n\n        // Update scope system (sway, camera offset, overlay)\n        UpdateScope((float)delta);\n    }\n\n    // =========================================================================\n    // Bolt-Action Charging Mechanics\n    // =========================================================================\n\n    /// <summary>\n    /// Handles the bolt-action charging input sequence.\n    /// Sequence: Down (pull bolt) ‚Üí Left (open bolt) ‚Üí Down (close bolt) ‚Üí Up (chamber round)\n    /// Uses the arrow keys / WASD movement input actions.\n    /// </summary>\n    private void HandleBoltActionInput()\n    {\n        switch (_boltStep)\n        {\n            case BoltActionStep.NeedsBoltCycle:\n                // Step 1: Down arrow - pull bolt back\n                if (Input.IsActionJustPressed(\"move_down\"))\n                {\n                    _boltStep = BoltActionStep.WaitOpenBolt;\n                    EmitSignal(SignalName.BoltStepChanged, 1, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 1/4: Bolt pulled back\");\n                }\n                break;\n\n            case BoltActionStep.WaitOpenBolt:\n                // Step 2: Left arrow - open bolt\n                if (Input.IsActionJustPressed(\"move_left\"))\n                {\n                    _boltStep = BoltActionStep.WaitCloseBolt;\n                    EmitSignal(SignalName.BoltStepChanged, 2, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 2/4: Bolt opened\");\n                }\n                break;\n\n            case BoltActionStep.WaitCloseBolt:\n                // Step 3: Down arrow - close bolt\n                if (Input.IsActionJustPressed(\"move_down\"))\n                {\n                    _boltStep = BoltActionStep.WaitChamberRound;\n                    EmitSignal(SignalName.BoltStepChanged, 3, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 3/4: Bolt closed\");\n                }\n                break;\n\n            case BoltActionStep.WaitChamberRound:\n                // Step 4: Up arrow - chamber round\n                if (Input.IsActionJustPressed(\"move_up\"))\n                {\n                    _boltStep = BoltActionStep.Ready;\n                    EmitSignal(SignalName.BoltStepChanged, 4, 4);\n                    PlayBoltChamberSound();\n                    GD.Print(\"[SniperRifle] Bolt step 4/4: Round chambered - READY TO FIRE\");\n                }\n                break;\n\n            case BoltActionStep.Ready:\n                // Already ready, no bolt action needed\n                break;\n        }\n    }\n\n    /// <summary>\n    /// Plays the bolt manipulation sound.\n    /// </summary>\n    private void PlayBoltSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_bolt\"))\n        {\n            audioManager.Call(\"play_m16_bolt\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Plays the bolt chamber/ready sound.\n    /// </summary>\n    private void PlayBoltChamberSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_bolt\"))\n        {\n            audioManager.Call(\"play_m16_bolt\", GlobalPosition);\n        }\n    }\n\n    // =========================================================================\n    // Aiming and Laser Sight\n    // =========================================================================\n\n    /// <summary>\n    /// Updates the aim direction and rifle sprite rotation.\n    /// </summary>\n    private void UpdateAimDirection()\n    {\n        Vector2 mousePos = GetGlobalMousePosition();\n        Vector2 toMouse = mousePos - GlobalPosition;\n        float targetAngle = toMouse.Angle();\n\n        if (!_aimAngleInitialized)\n        {\n            _currentAimAngle = targetAngle;\n            _aimAngleInitialized = true;\n        }\n\n        Vector2 direction;\n\n        // Apply sensitivity for the sniper rifle\n        if (WeaponData != null && WeaponData.Sensitivity > 0)\n        {\n            float angleDiff = Mathf.Wrap(targetAngle - _currentAimAngle, -Mathf.Pi, Mathf.Pi);\n            float rotationSpeed = WeaponData.Sensitivity * 10.0f;\n            float delta = (float)GetProcessDeltaTime();\n            float maxRotation = rotationSpeed * delta;\n            float actualRotation = Mathf.Clamp(angleDiff, -maxRotation, maxRotation);\n            _currentAimAngle += actualRotation;\n            direction = new Vector2(Mathf.Cos(_currentAimAngle), Mathf.Sin(_currentAimAngle));\n        }\n        else\n        {\n            if (toMouse.LengthSquared() > 0.001f)\n            {\n                direction = toMouse.Normalized();\n                _currentAimAngle = targetAngle;\n            }\n            else\n            {\n                direction = _aimDirection;\n            }\n        }\n\n        _aimDirection = direction;\n        UpdateRifleSpriteRotation(direction);\n    }\n\n    /// <summary>\n    /// Creates the laser sight Line2D programmatically.\n    /// </summary>\n    private void CreateLaserSight()\n    {\n        _laserSight = new Line2D\n        {\n            Name = \"LaserSight\",\n            Width = LaserSightWidth,\n            DefaultColor = LaserSightColor,\n            BeginCapMode = Line2D.LineCapMode.Round,\n            EndCapMode = Line2D.LineCapMode.Round\n        };\n\n        _laserSight.AddPoint(Vector2.Zero);\n        _laserSight.AddPoint(Vector2.Right * LaserSightLength);\n\n        AddChild(_laserSight);\n    }\n\n    /// <summary>\n    /// Updates the laser sight visualization with recoil offset.\n    /// Uses raycasting to stop at obstacles.\n    /// </summary>\n    private void UpdateLaserSight()\n    {\n        if (_laserSight == null)\n        {\n            return;\n        }\n\n        Vector2 laserDirection = _aimDirection.Rotated(_recoilOffset);\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float maxLaserLength = viewportSize.Length();\n\n        Vector2 endPoint = laserDirection * maxLaserLength;\n\n        var spaceState = GetWorld2D().DirectSpaceState;\n        var query = PhysicsRayQueryParameters2D.Create(\n            GlobalPosition,\n            GlobalPosition + endPoint,\n            4 // Collision mask for obstacles (layer 3 = value 4)\n        );\n\n        var result = spaceState.IntersectRay(query);\n\n        if (result.Count > 0)\n        {\n            Vector2 hitPosition = (Vector2)result[\"position\"];\n            endPoint = hitPosition - GlobalPosition;\n        }\n\n        _laserSight.SetPointPosition(0, Vector2.Zero);\n        _laserSight.SetPointPosition(1, endPoint);\n    }\n\n    /// <summary>\n    /// Updates the visibility of the laser sight.\n    /// </summary>\n    private void UpdateLaserSightVisibility()\n    {\n        if (_laserSight != null)\n        {\n            _laserSight.Visible = LaserSightEnabled;\n        }\n    }\n\n    /// <summary>\n    /// Updates the rifle sprite rotation to match aim direction.\n    /// </summary>\n    private void UpdateRifleSpriteRotation(Vector2 direction)\n    {\n        if (_rifleSprite == null)\n        {\n            return;\n        }\n\n        float angle = direction.Angle();\n        _rifleSprite.Rotation = angle;\n\n        bool aimingLeft = Mathf.Abs(angle) > Mathf.Pi / 2;\n        _rifleSprite.FlipV = aimingLeft;\n    }\n\n    /// <summary>\n    /// Enables or disables the laser sight.\n    /// </summary>\n    public void SetLaserSightEnabled(bool enabled)\n    {\n        LaserSightEnabled = enabled;\n        UpdateLaserSightVisibility();\n    }\n\n    // =========================================================================\n    // Firing\n    // =========================================================================\n\n    /// <summary>\n    /// Fires the sniper rifle. Only fires if bolt is ready.\n    /// After firing, transitions to NeedsBoltCycle state.\n    /// </summary>\n    public override bool Fire(Vector2 direction)\n    {\n        // Check for empty magazine\n        if (CurrentAmmo <= 0)\n        {\n            PlayEmptyClickSound();\n            return false;\n        }\n\n        // Check if bolt is ready\n        if (!IsBoltReady)\n        {\n            // Play a click to indicate bolt not cycled\n            PlayEmptyClickSound();\n            return false;\n        }\n\n        // Check standard fire conditions\n        if (!CanFire || WeaponData == null || BulletScene == null)\n        {\n            return false;\n        }\n\n        // Apply recoil to aim direction\n        Vector2 spreadDirection = ApplyRecoil(_aimDirection);\n        bool result = base.Fire(spreadDirection);\n\n        if (result)\n        {\n            // Transition to needs bolt cycle\n            _boltStep = BoltActionStep.NeedsBoltCycle;\n            EmitSignal(SignalName.BoltStepChanged, 0, 4);\n\n            // Play sniper shot sound\n            PlaySniperShotSound();\n            // Emit gunshot sound for enemy detection\n            EmitGunshotSound();\n            // Play shell casing with delay\n            PlayShellCasingDelayed();\n            // Trigger heavy screen shake\n            TriggerScreenShake(spreadDirection);\n\n            // Spawn smoky tracer trail\n            SpawnSmokyTracer(GlobalPosition, spreadDirection);\n\n            GD.Print(\"[SniperRifle] FIRED! Bolt needs cycling. Ammo remaining: \" + CurrentAmmo);\n        }\n\n        return result;\n    }\n\n    /// <summary>\n    /// Override SpawnBullet to configure the SniperBullet for sniper behavior:\n    /// - Very high damage (50)\n    /// - Passes through enemies (doesn't destroy on hit)\n    /// - Penetrates through 2 walls (wall-count based, not distance-based)\n    /// </summary>\n    protected override void SpawnBullet(Vector2 direction)\n    {\n        if (BulletScene == null)\n        {\n            return;\n        }\n\n        // Check bullet spawn path\n        var (isBlocked, hitPosition, hitNormal) = CheckBulletSpawnPath(direction);\n\n        Vector2 spawnPosition;\n        if (isBlocked)\n        {\n            spawnPosition = GlobalPosition + direction * 2.0f;\n            GD.Print(\"[SniperRifle] Point-blank shot: spawning for penetration\");\n        }\n        else\n        {\n            spawnPosition = GlobalPosition + direction * BulletSpawnOffset;\n        }\n\n        var bulletNode = BulletScene.Instantiate<Node2D>();\n        bulletNode.GlobalPosition = spawnPosition;\n\n        // Try to cast to C# SniperBullet for direct property access\n        var sniperBullet = bulletNode as SniperBullet;\n\n        if (sniperBullet != null)\n        {\n            // SniperBullet - set properties directly\n            sniperBullet.Direction = direction;\n            if (WeaponData != null)\n            {\n                sniperBullet.Speed = WeaponData.BulletSpeed;\n                sniperBullet.Damage = WeaponData.Damage;\n            }\n            var owner = GetParent();\n            if (owner != null)\n            {\n                sniperBullet.ShooterId = owner.GetInstanceId();\n            }\n            sniperBullet.ShooterPosition = GlobalPosition;\n            sniperBullet.MaxWallPenetrations = MaxWallPenetrations;\n            GD.Print($\"[SniperRifle] Spawned SniperBullet: Damage={sniperBullet.Damage}, Speed={sniperBullet.Speed}, MaxWallPen={MaxWallPenetrations}\");\n        }\n        else\n        {\n            // Fallback for any bullet type\n            if (bulletNode.HasMethod(\"SetDirection\"))\n            {\n                bulletNode.Call(\"SetDirection\", direction);\n            }\n            else\n            {\n                bulletNode.Set(\"Direction\", direction);\n                bulletNode.Set(\"direction\", direction);\n            }\n\n            if (WeaponData != null)\n            {\n                bulletNode.Set(\"Speed\", WeaponData.BulletSpeed);\n                bulletNode.Set(\"speed\", WeaponData.BulletSpeed);\n                bulletNode.Set(\"Damage\", WeaponData.Damage);\n                bulletNode.Set(\"damage\", WeaponData.Damage);\n            }\n\n            var owner = GetParent();\n            if (owner != null)\n            {\n                bulletNode.Set(\"ShooterId\", owner.GetInstanceId());\n                bulletNode.Set(\"shooter_id\", owner.GetInstanceId());\n            }\n\n            bulletNode.Set(\"ShooterPosition\", GlobalPosition);\n            bulletNode.Set(\"shooter_position\", GlobalPosition);\n        }\n\n        GetTree().CurrentScene.AddChild(bulletNode);\n\n        // Spawn muzzle flash effect - large flash for 12.7mm\n        SpawnMuzzleFlash(spawnPosition, direction, WeaponData?.Caliber);\n\n        // Spawn casing\n        SpawnCasing(direction, WeaponData?.Caliber);\n    }\n\n    // =========================================================================\n    // Smoky Tracer Trail\n    // =========================================================================\n\n    /// <summary>\n    /// Spawns a smoky dissipating tracer trail from the fire position\n    /// in the shooting direction across the entire map.\n    /// The tracer is an instant visual effect (like a contrail from a plane)\n    /// that fades out over time.\n    /// </summary>\n    private void SpawnSmokyTracer(Vector2 fromPosition, Vector2 direction)\n    {\n        // Calculate tracer end point - extend to edge of map (very far)\n        float tracerLength = 5000.0f; // Far enough to reach any map edge\n        Vector2 endPosition = fromPosition + direction * tracerLength;\n\n        // Create the tracer as a Line2D with smoke-like appearance\n        var tracer = new Line2D\n        {\n            Name = \"SniperTracer\",\n            Width = 6.0f,\n            DefaultColor = new Color(0.8f, 0.8f, 0.8f, 0.7f),\n            BeginCapMode = Line2D.LineCapMode.Round,\n            EndCapMode = Line2D.LineCapMode.Round,\n            TopLevel = true,\n            Position = Vector2.Zero,\n            ZIndex = -1 // Behind other elements\n        };\n\n        // Set up width curve - wider at start, tapers to narrower at end\n        var widthCurve = new Curve();\n        widthCurve.AddPoint(new Vector2(0.0f, 1.0f));\n        widthCurve.AddPoint(new Vector2(0.3f, 0.8f));\n        widthCurve.AddPoint(new Vector2(1.0f, 0.3f));\n        tracer.WidthCurve = widthCurve;\n\n        // Set up gradient - smoky white/gray that fades out\n        var gradient = new Gradient();\n        gradient.SetColor(0, new Color(0.9f, 0.9f, 0.85f, 0.8f));\n        gradient.AddPoint(0.5f, new Color(0.7f, 0.7f, 0.65f, 0.5f));\n        gradient.SetColor(gradient.GetPointCount() - 1, new Color(0.5f, 0.5f, 0.5f, 0.2f));\n        tracer.Gradient = gradient;\n\n        // Add the tracer line points (using global coordinates since TopLevel=true)\n        tracer.AddPoint(fromPosition + direction * BulletSpawnOffset);\n        tracer.AddPoint(endPosition);\n\n        // Add to scene\n        GetTree().CurrentScene.AddChild(tracer);\n\n        // Start the fade-out animation\n        FadeOutTracer(tracer);\n    }\n\n    /// <summary>\n    /// Animates the tracer trail fading out and dissipating over time.\n    /// The tracer gradually becomes more transparent and wider (simulating smoke dissipation).\n    /// </summary>\n    private async void FadeOutTracer(Line2D tracer)\n    {\n        float fadeDuration = 2.0f;\n        float elapsed = 0.0f;\n\n        float initialWidth = tracer.Width;\n\n        while (elapsed < fadeDuration && IsInstanceValid(tracer))\n        {\n            elapsed += (float)GetProcessDeltaTime();\n            float progress = elapsed / fadeDuration;\n\n            // Fade the alpha\n            float alpha = Mathf.Lerp(0.7f, 0.0f, progress);\n            tracer.DefaultColor = new Color(0.8f, 0.8f, 0.8f, alpha);\n\n            // Widen slightly to simulate smoke dissipation\n            tracer.Width = initialWidth + progress * 4.0f;\n\n            // Update gradient alpha\n            var gradient = new Gradient();\n            gradient.SetColor(0, new Color(0.9f, 0.9f, 0.85f, alpha));\n            gradient.AddPoint(0.5f, new Color(0.7f, 0.7f, 0.65f, alpha * 0.6f));\n            gradient.SetColor(gradient.GetPointCount() - 1, new Color(0.5f, 0.5f, 0.5f, alpha * 0.3f));\n            tracer.Gradient = gradient;\n\n            await ToSignal(GetTree(), \"process_frame\");\n        }\n\n        // Remove the tracer after fade completes\n        if (IsInstanceValid(tracer))\n        {\n            tracer.QueueFree();\n        }\n    }\n\n    // =========================================================================\n    // Sound and Effects\n    // =========================================================================\n\n    /// <summary>\n    /// Plays the sniper shot sound via AudioManager.\n    /// </summary>\n    private void PlaySniperShotSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        // Use M16 shot as a placeholder sound for the sniper\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_shot\"))\n        {\n            audioManager.Call(\"play_m16_shot\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Plays the empty gun click sound.\n    /// </summary>\n    private void PlayEmptyClickSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_empty_click\"))\n        {\n            audioManager.Call(\"play_empty_click\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Emits gunshot sound for enemy detection via SoundPropagation.\n    /// Very loud for the 12.7mm round.\n    /// </summary>\n    private void EmitGunshotSound()\n    {\n        var soundPropagation = GetNodeOrNull(\"/root/SoundPropagation\");\n        if (soundPropagation != null && soundPropagation.HasMethod(\"emit_sound\"))\n        {\n            float loudness = WeaponData?.Loudness ?? 3000.0f;\n            soundPropagation.Call(\"emit_sound\", 0, GlobalPosition, 0, this, loudness);\n        }\n    }\n\n    /// <summary>\n    /// Plays shell casing sound with a delay.\n    /// </summary>\n    private async void PlayShellCasingDelayed()\n    {\n        await ToSignal(GetTree().CreateTimer(0.2), \"timeout\");\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_shell_rifle\"))\n        {\n            audioManager.Call(\"play_shell_rifle\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Applies recoil to shooting direction.\n    /// </summary>\n    private Vector2 ApplyRecoil(Vector2 direction)\n    {\n        // Apply current recoil offset\n        Vector2 result = direction.Rotated(_recoilOffset);\n\n        // Add strong recoil for next shot (heavy 12.7mm kick)\n        float recoilDirection = (float)GD.RandRange(-1.0, 1.0);\n        _recoilOffset += recoilDirection * RecoilPerShot;\n        _recoilOffset = Mathf.Clamp(_recoilOffset, -MaxRecoilOffset, MaxRecoilOffset);\n\n        _timeSinceLastShot = 0;\n\n        return result;\n    }\n\n    /// <summary>\n    /// Triggers screen shake from sniper shot.\n    /// Heavy shake for 12.7mm round.\n    /// </summary>\n    private void TriggerScreenShake(Vector2 shootDirection)\n    {\n        if (WeaponData == null || WeaponData.ScreenShakeIntensity <= 0)\n        {\n            return;\n        }\n\n        var screenShakeManager = GetNodeOrNull(\"/root/ScreenShakeManager\");\n        if (screenShakeManager == null || !screenShakeManager.HasMethod(\"add_shake\"))\n        {\n            return;\n        }\n\n        // Heavy shake for sniper\n        float fireRate = WeaponData.FireRate;\n        float shakeIntensity;\n        if (fireRate > 0)\n        {\n            shakeIntensity = WeaponData.ScreenShakeIntensity / fireRate * 10.0f;\n        }\n        else\n        {\n            shakeIntensity = WeaponData.ScreenShakeIntensity;\n        }\n\n        float recoveryTime = WeaponData.ScreenShakeMinRecoveryTime;\n\n        screenShakeManager.Call(\"add_shake\", shootDirection, shakeIntensity, recoveryTime);\n    }\n\n    /// <summary>\n    /// Fires the bullet in the chamber during reload sequence.\n    /// </summary>\n    public override bool FireChamberBullet(Vector2 direction)\n    {\n        // Sniper rifle doesn't support chamber bullet during reload\n        // (bolt-action requires full cycle)\n        return false;\n    }\n\n    /// <summary>\n    /// Gets the current aim direction.\n    /// </summary>\n    public Vector2 AimDirection => _aimDirection;\n\n    /// <summary>\n    /// Gets the current bolt-action step.\n    /// </summary>\n    public BoltActionStep CurrentBoltStep => _boltStep;\n\n    /// <summary>\n    /// Resets the bolt to ready state (e.g., after reload with a new magazine).\n    /// </summary>\n    public void ResetBolt()\n    {\n        _boltStep = BoltActionStep.Ready;\n        EmitSignal(SignalName.BoltStepChanged, 4, 4);\n        GD.Print(\"[SniperRifle] Bolt reset to ready state\");\n    }\n\n    // =========================================================================\n    // Scope / Aiming System (RMB)\n    // =========================================================================\n\n    /// <summary>\n    /// Whether the scope is currently active (RMB held).\n    /// </summary>\n    private bool _isScopeActive = false;\n\n    /// <summary>\n    /// Whether the scope is active (read-only property for external access).\n    /// </summary>\n    public bool IsScopeActive => _isScopeActive;\n\n    /// <summary>\n    /// Signal emitted when scope state changes.\n    /// </summary>\n    [Signal]\n    public delegate void ScopeStateChangedEventHandler(bool isActive);\n\n    /// <summary>\n    /// Current scope zoom distance multiplier (how far beyond viewport the player can see).\n    /// 1.0 = one viewport distance, 2.0 = two viewport distances.\n    /// Controlled by mouse wheel while scoping.\n    /// </summary>\n    private float _scopeZoomDistance = 1.0f;\n\n    /// <summary>\n    /// Minimum scope zoom distance (viewport multiplier).\n    /// Set to 1.0 so the scope always looks beyond the normal viewport.\n    /// </summary>\n    private const float MinScopeZoomDistance = 1.0f;\n\n    /// <summary>\n    /// Maximum scope zoom distance (viewport multiplier).\n    /// </summary>\n    private const float MaxScopeZoomDistance = 3.0f;\n\n    /// <summary>\n    /// Step size for mouse wheel zoom adjustment.\n    /// </summary>\n    private const float ScopeZoomStep = 0.25f;\n\n    /// <summary>\n    /// Base sway amplitude in pixels at 1 viewport distance.\n    /// </summary>\n    private const float BaseScopeSwayAmplitude = 8.0f;\n\n    /// <summary>\n    /// Speed of the sway oscillation.\n    /// </summary>\n    private const float ScopeSwaySpeed = 2.5f;\n\n    /// <summary>\n    /// Maximum range (in viewport fraction) that the player can fine-tune the scope\n    /// distance via mouse movement while scoped. About 1/3 of the viewport.\n    /// </summary>\n    private const float ScopeMouseFineTuneRange = 0.33f;\n\n    /// <summary>\n    /// Current mouse fine-tune offset applied to scope distance.\n    /// Ranges from -ScopeMouseFineTuneRange to +ScopeMouseFineTuneRange (viewport fraction).\n    /// Positive = further, negative = closer.\n    /// </summary>\n    private float _scopeMouseFineTuneOffset = 0.0f;\n\n    /// <summary>\n    /// Current scope sway time accumulator.\n    /// </summary>\n    private float _scopeSwayTime = 0.0f;\n\n    /// <summary>\n    /// Current scope sway offset in pixels (applied to camera).\n    /// </summary>\n    private Vector2 _scopeSwayOffset = Vector2.Zero;\n\n    /// <summary>\n    /// Reference to the scope overlay CanvasLayer (created when scope activates).\n    /// </summary>\n    private CanvasLayer? _scopeOverlay = null;\n\n    /// <summary>\n    /// Reference to the scope crosshair control node.\n    /// </summary>\n    private Control? _scopeCrosshair = null;\n\n    /// <summary>\n    /// Reference to the scope darkening background.\n    /// </summary>\n    private ColorRect? _scopeBackground = null;\n\n    /// <summary>\n    /// Cached reference to the player's Camera2D node.\n    /// </summary>\n    private Camera2D? _playerCamera = null;\n\n    /// <summary>\n    /// Original camera offset before scoping (to restore on exit).\n    /// </summary>\n    private Vector2 _originalCameraOffset = Vector2.Zero;\n\n    /// <summary>\n    /// Gets the effective scope zoom distance including mouse fine-tune offset.\n    /// </summary>\n    private float EffectiveScopeZoomDistance => _scopeZoomDistance + _scopeMouseFineTuneOffset;\n\n    /// <summary>\n    /// Gets the current camera offset for scope aiming.\n    /// Called by the player or level scripts to position the camera.\n    /// </summary>\n    public Vector2 GetScopeCameraOffset()\n    {\n        if (!_isScopeActive)\n        {\n            return Vector2.Zero;\n        }\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return Vector2.Zero;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float baseDistance = viewportSize.Length() * 0.5f;\n\n        // Camera offset = aim direction * (zoom distance + mouse fine-tune) * viewport size + sway\n        Vector2 offset = _aimDirection * baseDistance * EffectiveScopeZoomDistance + _scopeSwayOffset;\n\n        return offset;\n    }\n\n    /// <summary>\n    /// Gets the world-space position that the scope crosshair center is aiming at.\n    /// Used to direct bullets to the crosshair center.\n    /// </summary>\n    public Vector2 GetScopeAimTarget()\n    {\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return GlobalPosition + _aimDirection * 1000.0f;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float baseDistance = viewportSize.Length() * 0.5f;\n\n        // The scope aim target is the player's position offset by the scope camera offset\n        // (without sway, so bullets go to the true center, not the swaying crosshair)\n        Vector2 aimTarget = GlobalPosition + _aimDirection * baseDistance * EffectiveScopeZoomDistance;\n\n        return aimTarget;\n    }\n\n    /// <summary>\n    /// Activates the scope (called when RMB is pressed).\n    /// </summary>\n    public void ActivateScope()\n    {\n        if (_isScopeActive)\n        {\n            return;\n        }\n\n        _isScopeActive = true;\n        _scopeSwayTime = 0.0f;\n        _scopeMouseFineTuneOffset = 0.0f;\n\n        // Find and cache the player's Camera2D\n        FindPlayerCamera();\n\n        // Store original camera offset\n        if (_playerCamera != null)\n        {\n            _originalCameraOffset = _playerCamera.Offset;\n        }\n\n        // Create the scope overlay\n        CreateScopeOverlay();\n\n        EmitSignal(SignalName.ScopeStateChanged, true);\n        GD.Print($\"[SniperRifle] Scope activated. Zoom distance: {_scopeZoomDistance:F1}x\");\n    }\n\n    /// <summary>\n    /// Deactivates the scope (called when RMB is released).\n    /// </summary>\n    public void DeactivateScope()\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        _isScopeActive = false;\n\n        // Restore original camera offset\n        if (_playerCamera != null)\n        {\n            _playerCamera.Offset = _originalCameraOffset;\n        }\n\n        // Remove scope overlay\n        RemoveScopeOverlay();\n\n        EmitSignal(SignalName.ScopeStateChanged, false);\n        GD.Print(\"[SniperRifle] Scope deactivated.\");\n    }\n\n    /// <summary>\n    /// Adjusts the scope zoom distance (called on mouse wheel while scoping).\n    /// </summary>\n    public void AdjustScopeZoom(float direction)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        _scopeZoomDistance += direction * ScopeZoomStep;\n        _scopeZoomDistance = Mathf.Clamp(_scopeZoomDistance, MinScopeZoomDistance, MaxScopeZoomDistance);\n\n        // Reset fine-tune offset when zoom changes to avoid going out of range\n        _scopeMouseFineTuneOffset = Mathf.Clamp(_scopeMouseFineTuneOffset,\n            -ScopeMouseFineTuneRange, ScopeMouseFineTuneRange);\n\n        GD.Print($\"[SniperRifle] Scope zoom adjusted: {_scopeZoomDistance:F2}x (fine-tune: {_scopeMouseFineTuneOffset:F2})\");\n    }\n\n    /// <summary>\n    /// Adjusts the scope fine-tune offset based on mouse movement along the aim direction.\n    /// Allows the player to look slightly closer or further (about 1/3 viewport range).\n    /// Called from Player.cs when mouse moves while scoped.\n    /// </summary>\n    public void AdjustScopeFineTune(Vector2 mouseMotion)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        // Project mouse motion onto the aim direction to get forward/backward movement\n        // Moving mouse in the aim direction = further, opposite = closer\n        float projection = mouseMotion.Dot(_aimDirection);\n\n        // Scale the projection: mouse sensitivity for scope fine-tuning\n        // A moderate movement across the screen should give the full range\n        float sensitivity = 0.002f;\n        _scopeMouseFineTuneOffset += projection * sensitivity;\n        _scopeMouseFineTuneOffset = Mathf.Clamp(_scopeMouseFineTuneOffset,\n            -ScopeMouseFineTuneRange, ScopeMouseFineTuneRange);\n    }\n\n    /// <summary>\n    /// Finds the player's Camera2D node by traversing up to the parent (player).\n    /// </summary>\n    private void FindPlayerCamera()\n    {\n        if (_playerCamera != null)\n        {\n            return;\n        }\n\n        var parent = GetParent();\n        if (parent != null)\n        {\n            _playerCamera = parent.GetNodeOrNull<Camera2D>(\"Camera2D\");\n        }\n    }\n\n    /// <summary>\n    /// Updates the scope system each frame (called from _Process).\n    /// </summary>\n    private void UpdateScope(float delta)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        // Update sway (scales with effective distance including fine-tune offset)\n        _scopeSwayTime += delta;\n        float swayAmplitude = BaseScopeSwayAmplitude * EffectiveScopeZoomDistance;\n\n        // Use two sine waves at different frequencies for natural-looking sway\n        float swayX = Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 1.0f) * swayAmplitude\n                    + Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 2.3f) * swayAmplitude * 0.3f;\n        float swayY = Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 1.4f) * swayAmplitude\n                    + Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 0.7f) * swayAmplitude * 0.4f;\n\n        _scopeSwayOffset = new Vector2(swayX, swayY);\n\n        // Update camera offset for scope view\n        if (_playerCamera != null)\n        {\n            _playerCamera.Offset = _originalCameraOffset + GetScopeCameraOffset();\n        }\n\n        // Update scope overlay crosshair position with sway\n        UpdateScopeOverlayPosition();\n    }\n\n    /// <summary>\n    /// Creates the scope overlay UI with crosshair and darkened edges.\n    /// </summary>\n    private void CreateScopeOverlay()\n    {\n        RemoveScopeOverlay();\n\n        _scopeOverlay = new CanvasLayer\n        {\n            Name = \"ScopeOverlay\",\n            Layer = 10\n        };\n\n        Viewport? viewport = GetViewport();\n        Vector2 viewportSize = viewport?.GetVisibleRect().Size ?? new Vector2(1280, 720);\n\n        // Dark background with circular cutout effect (vignette)\n        _scopeBackground = new ColorRect\n        {\n            Name = \"ScopeBackground\",\n            Color = new Color(0.0f, 0.0f, 0.0f, 0.5f),\n            Size = viewportSize,\n            Position = Vector2.Zero,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        _scopeOverlay.AddChild(_scopeBackground);\n\n        // Create the crosshair as a Control node\n        _scopeCrosshair = new Control\n        {\n            Name = \"ScopeCrosshair\",\n            Position = viewportSize / 2,\n            Size = Vector2.Zero,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        _scopeOverlay.AddChild(_scopeCrosshair);\n\n        // Add crosshair lines - based on the reference image from the issue\n        // The scope has a classic crosshair with circle and mil-dots\n\n        // Outer circle\n        float circleRadius = Mathf.Min(viewportSize.X, viewportSize.Y) * 0.35f;\n        int segments = 64;\n        var outerCircle = new Line2D\n        {\n            Name = \"OuterCircle\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f),\n            Antialiased = true\n        };\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            outerCircle.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * circleRadius);\n        }\n        _scopeCrosshair.AddChild(outerCircle);\n\n        // Inner thin circle\n        float innerRadius = circleRadius * 0.05f;\n        var innerCircle = new Line2D\n        {\n            Name = \"InnerCircle\",\n            Width = 1.5f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f),\n            Antialiased = true\n        };\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            innerCircle.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * innerRadius);\n        }\n        _scopeCrosshair.AddChild(innerCircle);\n\n        // Horizontal crosshair line (left)\n        var hLineLeft = new Line2D\n        {\n            Name = \"HLineLeft\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        hLineLeft.AddPoint(new Vector2(-circleRadius, 0));\n        hLineLeft.AddPoint(new Vector2(-innerRadius, 0));\n        _scopeCrosshair.AddChild(hLineLeft);\n\n        // Horizontal crosshair line (right)\n        var hLineRight = new Line2D\n        {\n            Name = \"HLineRight\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        hLineRight.AddPoint(new Vector2(innerRadius, 0));\n        hLineRight.AddPoint(new Vector2(circleRadius, 0));\n        _scopeCrosshair.AddChild(hLineRight);\n\n        // Vertical crosshair line (top)\n        var vLineTop = new Line2D\n        {\n            Name = \"VLineTop\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        vLineTop.AddPoint(new Vector2(0, -circleRadius));\n        vLineTop.AddPoint(new Vector2(0, -innerRadius));\n        _scopeCrosshair.AddChild(vLineTop);\n\n        // Vertical crosshair line (bottom) with mil-dots\n        var vLineBottom = new Line2D\n        {\n            Name = \"VLineBottom\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        vLineBottom.AddPoint(new Vector2(0, innerRadius));\n        vLineBottom.AddPoint(new Vector2(0, circleRadius));\n        _scopeCrosshair.AddChild(vLineBottom);\n\n        // Add mil-dot markers on the bottom crosshair (range estimation)\n        float dotSpacing = circleRadius * 0.15f;\n        for (int i = 1; i <= 4; i++)\n        {\n            float dotY = dotSpacing * i;\n            var dot = new Line2D\n            {\n                Name = $\"MilDot_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            float dotWidth = 4.0f - i * 0.5f; // Dots get smaller further from center\n            dot.AddPoint(new Vector2(-dotWidth, dotY));\n            dot.AddPoint(new Vector2(dotWidth, dotY));\n            _scopeCrosshair.AddChild(dot);\n        }\n\n        // Add mil-dot markers on horizontal lines\n        for (int i = 1; i <= 3; i++)\n        {\n            float dotX = dotSpacing * i;\n            // Right side dots\n            var dotRight = new Line2D\n            {\n                Name = $\"HMilDotRight_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            float dotHeight = 4.0f - i * 0.5f;\n            dotRight.AddPoint(new Vector2(dotX, -dotHeight));\n            dotRight.AddPoint(new Vector2(dotX, dotHeight));\n            _scopeCrosshair.AddChild(dotRight);\n\n            // Left side dots\n            var dotLeft = new Line2D\n            {\n                Name = $\"HMilDotLeft_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            dotLeft.AddPoint(new Vector2(-dotX, -dotHeight));\n            dotLeft.AddPoint(new Vector2(-dotX, dotHeight));\n            _scopeCrosshair.AddChild(dotLeft);\n        }\n\n        // Add thick outer ring to mask edges (simulate scope tube)\n        var scopeRing = new Line2D\n        {\n            Name = \"ScopeRing\",\n            Width = 6.0f,\n            DefaultColor = new Color(0.1f, 0.1f, 0.1f, 0.95f),\n            Antialiased = true\n        };\n        float ringRadius = circleRadius + 3.0f;\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            scopeRing.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * ringRadius);\n        }\n        _scopeCrosshair.AddChild(scopeRing);\n\n        // Zoom distance indicator text\n        var zoomLabel = new Label\n        {\n            Name = \"ZoomLabel\",\n            Position = new Vector2(circleRadius * 0.5f, circleRadius * 0.7f),\n            Text = $\"{_scopeZoomDistance:F1}x\",\n            HorizontalAlignment = HorizontalAlignment.Center,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        zoomLabel.AddThemeColorOverride(\"font_color\", new Color(0.0f, 0.0f, 0.0f, 0.6f));\n        zoomLabel.AddThemeFontSizeOverride(\"font_size\", 12);\n        _scopeCrosshair.AddChild(zoomLabel);\n\n        GetTree().CurrentScene.AddChild(_scopeOverlay);\n    }\n\n    /// <summary>\n    /// Updates the scope overlay crosshair position with sway applied.\n    /// </summary>\n    private void UpdateScopeOverlayPosition()\n    {\n        if (_scopeCrosshair == null || _scopeOverlay == null)\n        {\n            return;\n        }\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n\n        // Crosshair stays centered but sways\n        _scopeCrosshair.Position = viewportSize / 2 + _scopeSwayOffset;\n\n        // Update zoom label\n        var zoomLabel = _scopeCrosshair.GetNodeOrNull<Label>(\"ZoomLabel\");\n        if (zoomLabel != null)\n        {\n            zoomLabel.Text = $\"{_scopeZoomDistance:F1}x\";\n        }\n    }\n\n    /// <summary>\n    /// Removes the scope overlay from the scene.\n    /// </summary>\n    private void RemoveScopeOverlay()\n    {\n        if (_scopeOverlay != null && IsInstanceValid(_scopeOverlay))\n        {\n            _scopeOverlay.QueueFree();\n            _scopeOverlay = null;\n            _scopeCrosshair = null;\n            _scopeBackground = null;\n        }\n    }\n}\n",
    "structuredPatch": [
      {
        "oldStart": 920,
        "oldLines": 7,
        "newStart": 920,
        "newLines": 7,
        "lines": [
          "     /// 1.0 = one viewport distance, 2.0 = two viewport distances.",
          "     /// Controlled by mouse wheel while scoping.",
          "     /// </summary>",
          "-    private float _scopeZoomDistance = 1.0f;",
          "+    private float _scopeZoomDistance = 1.5f;",
          " ",
          "     /// <summary>",
          "     /// Minimum scope zoom distance (viewport multiplier)."
        ]
      }
    ],
    "userModified": false,
    "replaceAll": false
  }
}
[2026-02-06T20:57:52.649Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_012F1ziLN1jRq83j8sbV3eDP",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now let me update the `Player.cs` file. I need to:\n1. Make `Shoot()` use the scope aim target when scoped\n2. Add mouse motion handling for the scope fine-tune"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 230,
      "cache_read_input_tokens": 62169,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 230
      },
      "output_tokens": 7,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "52fa80d3-f059-4a5a-bf2b-039ccd9ea4ba"
}
[2026-02-06T20:57:58.490Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_012F1ziLN1jRq83j8sbV3eDP",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01FCWU8TVwhXZ4HR2FUDQ87r",
        "name": "Edit",
        "input": {
          "replace_all": false,
          "file_path": "/tmp/gh-issue-solver-1770411323361/Scripts/Characters/Player.cs",
          "old_string": "    private void Shoot()\n    {\n        // Calculate direction towards mouse cursor\n        Vector2 mousePos = GetGlobalMousePosition();\n        Vector2 shootDirection = (mousePos - GlobalPosition).Normalized();\n\n        // If we have a weapon equipped, use it\n        if (CurrentWeapon != null)\n        {\n            CurrentWeapon.Fire(shootDirection);\n            return;\n        }\n\n        // Otherwise use direct bullet spawning (original behavior)\n        SpawnBullet(shootDirection);\n    }",
          "new_string": "    private void Shoot()\n    {\n        // Calculate direction towards mouse cursor\n        Vector2 mousePos = GetGlobalMousePosition();\n        Vector2 shootDirection = (mousePos - GlobalPosition).Normalized();\n\n        // If we have a weapon equipped, use it\n        if (CurrentWeapon != null)\n        {\n            // When SniperRifle scope is active, fire towards the scope crosshair center\n            // instead of the mouse cursor (the camera is offset, so mouse != crosshair)\n            var sniperRifle = CurrentWeapon as SniperRifle;\n            if (sniperRifle != null && sniperRifle.IsScopeActive)\n            {\n                Vector2 scopeTarget = sniperRifle.GetScopeAimTarget();\n                shootDirection = (scopeTarget - GlobalPosition).Normalized();\n            }\n\n            CurrentWeapon.Fire(shootDirection);\n            return;\n        }\n\n        // Otherwise use direct bullet spawning (original behavior)\n        SpawnBullet(shootDirection);\n    }"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 230,
      "cache_read_input_tokens": 62169,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 230
      },
      "output_tokens": 7,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "b0cdd08a-8167-4bdf-a2f0-99ceaa76b7bf"
}
[2026-02-06T20:57:58.512Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01FCWU8TVwhXZ4HR2FUDQ87r",
        "type": "tool_result",
        "content": "The file /tmp/gh-issue-solver-1770411323361/Scripts/Characters/Player.cs has been updated successfully."
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "c6636796-2e8d-45b4-b8c7-3e37eeca38cf",
  "tool_use_result": {
    "filePath": "/tmp/gh-issue-solver-1770411323361/Scripts/Characters/Player.cs",
    "oldString": "    private void Shoot()\n    {\n        // Calculate direction towards mouse cursor\n        Vector2 mousePos = GetGlobalMousePosition();\n        Vector2 shootDirection = (mousePos - GlobalPosition).Normalized();\n\n        // If we have a weapon equipped, use it\n        if (CurrentWeapon != null)\n        {\n            CurrentWeapon.Fire(shootDirection);\n            return;\n        }\n\n        // Otherwise use direct bullet spawning (original behavior)\n        SpawnBullet(shootDirection);\n    }",
    "newString": "    private void Shoot()\n    {\n        // Calculate direction towards mouse cursor\n        Vector2 mousePos = GetGlobalMousePosition();\n        Vector2 shootDirection = (mousePos - GlobalPosition).Normalized();\n\n        // If we have a weapon equipped, use it\n        if (CurrentWeapon != null)\n        {\n            // When SniperRifle scope is active, fire towards the scope crosshair center\n            // instead of the mouse cursor (the camera is offset, so mouse != crosshair)\n            var sniperRifle = CurrentWeapon as SniperRifle;\n            if (sniperRifle != null && sniperRifle.IsScopeActive)\n            {\n                Vector2 scopeTarget = sniperRifle.GetScopeAimTarget();\n                shootDirection = (scopeTarget - GlobalPosition).Normalized();\n            }\n\n            CurrentWeapon.Fire(shootDirection);\n            return;\n        }\n\n        // Otherwise use direct bullet spawning (original behavior)\n        SpawnBullet(shootDirection);\n    }",
    "originalFile": "using Godot;\nusing System;\nusing System.Collections.Generic;\nusing GodotTopDownTemplate.AbstractClasses;\nusing GodotTopDownTemplate.Weapons;\nusing GodotTopdown.Scripts.Projectiles;\n\nnamespace GodotTopDownTemplate.Characters;\n\n/// <summary>\n/// Player character controller for top-down movement and shooting.\n/// Uses physics-based movement with acceleration and friction for smooth control.\n/// Supports WASD and arrow key input via configured input actions.\n/// Shoots bullets towards the mouse cursor on left mouse button.\n/// Supports both automatic (hold to fire) and semi-automatic (click per shot) weapons.\n/// Uses R-F-R key sequence for instant reload (press R, then F, then R again).\n/// Grenade throwing: G+RMB drag right ‚Üí hold G+RMB ‚Üí release G ‚Üí drag and release RMB to throw.\n/// </summary>\npublic partial class Player : BaseCharacter\n{\n    /// <summary>\n    /// Bullet scene to instantiate when shooting.\n    /// </summary>\n    [Export]\n    public PackedScene? BulletScene { get; set; }\n\n    /// <summary>\n    /// Offset from player center for bullet spawn position.\n    /// </summary>\n    [Export]\n    public float BulletSpawnOffset { get; set; } = 20.0f;\n\n    /// <summary>\n    /// Reference to the player's current weapon (optional, for weapon system).\n    /// </summary>\n    [Export]\n    public BaseWeapon? CurrentWeapon { get; set; }\n\n    /// <summary>\n    /// Color when at full health.\n    /// </summary>\n    [Export]\n    public Color FullHealthColor { get; set; } = new Color(0.2f, 0.6f, 1.0f, 1.0f);\n\n    /// <summary>\n    /// Color when at low health (interpolates based on health percentage).\n    /// </summary>\n    [Export]\n    public Color LowHealthColor { get; set; } = new Color(0.1f, 0.2f, 0.4f, 1.0f);\n\n    /// <summary>\n    /// Color to flash when hit.\n    /// </summary>\n    [Export]\n    public Color HitFlashColor { get; set; } = new Color(1.0f, 0.3f, 0.3f, 1.0f);\n\n    /// <summary>\n    /// Duration of hit flash effect in seconds.\n    /// </summary>\n    [Export]\n    public float HitFlashDuration { get; set; } = 0.1f;\n\n    /// <summary>\n    /// Grenade scene to instantiate when throwing.\n    /// </summary>\n    [Export]\n    public PackedScene? GrenadeScene { get; set; }\n\n    /// <summary>\n    /// Maximum number of grenades the player can carry.\n    /// </summary>\n    [Export]\n    public int MaxGrenades { get; set; } = 3;\n\n    /// <summary>\n    /// Reference to the player model node containing all sprites.\n    /// </summary>\n    private Node2D? _playerModel;\n\n    /// <summary>\n    /// References to individual sprite parts for color changes.\n    /// </summary>\n    private Sprite2D? _bodySprite;\n    private Sprite2D? _headSprite;\n    private Sprite2D? _leftArmSprite;\n    private Sprite2D? _rightArmSprite;\n\n    /// <summary>\n    /// Legacy reference for compatibility (points to body sprite).\n    /// </summary>\n    private Sprite2D? _sprite;\n\n    /// <summary>\n    /// Reference to the CasingPusher Area2D for detecting shell casings (Issue #392).\n    /// </summary>\n    private Area2D? _casingPusher;\n\n    /// <summary>\n    /// Force to apply to casings when pushed by player walking over them (Issue #392, #424).\n    /// Reduced by 2.5x from 50.0 to 20.0 for Issue #424.\n    /// </summary>\n    private const float CasingPushForce = 20.0f;\n\n    /// <summary>\n    /// List of casings currently overlapping with the CasingPusher Area2D (Issue #392 Iteration 8).\n    /// Uses signal-based tracking for reliable detection from all directions.\n    /// </summary>\n    private readonly System.Collections.Generic.List<RigidBody2D> _overlappingCasings = new();\n\n    /// <summary>\n    /// Current step in the reload sequence (0 = waiting for R, 1 = waiting for F, 2 = waiting for R).\n    /// </summary>\n    private int _reloadSequenceStep = 0;\n\n    /// <summary>\n    /// Whether the player is currently in a reload sequence.\n    /// </summary>\n    private bool _isReloadingSequence = false;\n\n    /// <summary>\n    /// Tracks ammo count when reload sequence started (at step 1 after R pressed).\n    /// Used to determine if there was a bullet in the chamber.\n    /// </summary>\n    private int _ammoAtReloadStart = 0;\n\n    /// <summary>\n    /// Current number of grenades.\n    /// </summary>\n    private int _currentGrenades = 3;\n\n    /// <summary>\n    /// Whether the player is on the tutorial level (infinite grenades).\n    /// </summary>\n    private bool _isTutorialLevel = false;\n\n    /// <summary>\n    /// Grenade state machine states.\n    /// 2-step mechanic:\n    /// Step 1: G + RMB drag right ‚Üí timer starts (pin pulled)\n    /// Step 2: Hold G ‚Üí press+hold RMB ‚Üí release G ‚Üí ready to throw (only RMB held)\n    /// Step 3: Drag and release RMB ‚Üí throw grenade\n    /// </summary>\n    private enum GrenadeState\n    {\n        Idle,           // No grenade action\n        TimerStarted,   // Step 1 complete - grenade timer running, G held, waiting for RMB\n        WaitingForGRelease, // Step 2 in progress - G+RMB held, waiting for G release\n        Aiming,         // Step 2 complete - only RMB held, waiting for drag and release to throw\n        SimpleAiming    // Simple mode: RMB held, showing trajectory preview\n    }\n\n    /// <summary>\n    /// Current grenade state.\n    /// </summary>\n    private GrenadeState _grenadeState = GrenadeState.Idle;\n\n    /// <summary>\n    /// Active grenade instance (created when timer starts).\n    /// </summary>\n    private RigidBody2D? _activeGrenade = null;\n\n    /// <summary>\n    /// Position where the grenade throw drag started.\n    /// </summary>\n    private Vector2 _grenadeDragStart = Vector2.Zero;\n\n    /// <summary>\n    /// Whether the grenade throw drag is active (for step 1).\n    /// </summary>\n    private bool _grenadeDragActive = false;\n\n    /// <summary>\n    /// Minimum drag distance to confirm step 1 (in pixels).\n    /// </summary>\n    private const float MinDragDistanceForStep1 = 30.0f;\n\n    /// <summary>\n    /// Position where aiming started (for simple mode trajectory).\n    /// </summary>\n    private Vector2 _aimDragStart = Vector2.Zero;\n\n    /// <summary>\n    /// Timestamp when grenade timer was started.\n    /// </summary>\n    private double _grenadeTimerStartTime = 0.0;\n\n    /// <summary>\n    /// Whether player is currently preparing to throw a grenade (for animations).\n    /// </summary>\n    private bool _isPreparingGrenade = false;\n\n    /// <summary>\n    /// Player's rotation before throw (to restore after throw animation).\n    /// </summary>\n    private float _playerRotationBeforeThrow = 0.0f;\n\n    /// <summary>\n    /// Whether player is in throw rotation animation.\n    /// </summary>\n    private bool _isThrowRotating = false;\n\n    /// <summary>\n    /// Whether debug mode is enabled (F7 toggle, shows grenade trajectory).\n    /// </summary>\n    private bool _debugModeEnabled = false;\n\n    /// <summary>\n    /// Whether invincibility mode is enabled (F6 toggle, player takes no damage).\n    /// </summary>\n    private bool _invincibilityEnabled = false;\n\n    /// <summary>\n    /// Label for displaying invincibility mode indicator.\n    /// </summary>\n    private Label? _invincibilityLabel = null;\n\n    /// <summary>\n    /// Target rotation for throw animation.\n    /// </summary>\n    private float _throwTargetRotation = 0.0f;\n\n    /// <summary>\n    /// Time remaining for throw rotation to restore.\n    /// </summary>\n    private float _throwRotationRestoreTimer = 0.0f;\n\n    /// <summary>\n    /// Duration of throw rotation animation.\n    /// </summary>\n    private const float ThrowRotationDuration = 0.15f;\n\n    #region Weapon Pose Detection\n\n    /// <summary>\n    /// Weapon types for arm positioning.\n    /// </summary>\n    private enum WeaponType\n    {\n        Rifle,      // Default - extended grip (e.g., AssaultRifle)\n        SMG,        // Compact grip (e.g., MiniUzi)\n        Shotgun,    // Similar to rifle but slightly tighter\n        Pistol      // Compact one-handed/two-handed pistol grip (e.g., SilencedPistol)\n    }\n\n    /// <summary>\n    /// Currently detected weapon type.\n    /// </summary>\n    private WeaponType _currentWeaponType = WeaponType.Rifle;\n\n    /// <summary>\n    /// Whether weapon pose has been detected and applied.\n    /// </summary>\n    private bool _weaponPoseApplied = false;\n\n    /// <summary>\n    /// Frame counter for delayed weapon pose detection.\n    /// Weapons are added by level scripts AFTER player's _Ready() completes.\n    /// </summary>\n    private int _weaponDetectFrameCount = 0;\n\n    /// <summary>\n    /// Number of frames to wait before detecting weapon pose.\n    /// This ensures level scripts have finished adding weapons.\n    /// </summary>\n    private const int WeaponDetectWaitFrames = 3;\n\n    /// <summary>\n    /// Arm position offset for SMG weapons - left arm moves back toward body.\n    /// UZI and similar compact SMGs should have the left arm closer to the body\n    /// for a proper two-handed compact grip.\n    /// </summary>\n    private static readonly Vector2 SmgLeftArmOffset = new Vector2(-10, 0);\n\n    /// <summary>\n    /// Arm position offset for SMG weapons - right arm moves slightly forward.\n    /// </summary>\n    private static readonly Vector2 SmgRightArmOffset = new Vector2(3, 0);\n\n    #endregion\n\n    #region Walking Animation\n\n    /// <summary>\n    /// Walking animation speed multiplier - higher = faster leg cycle.\n    /// </summary>\n    [Export]\n    public float WalkAnimSpeed { get; set; } = 12.0f;\n\n    /// <summary>\n    /// Scale multiplier for the player model (body, head, arms).\n    /// Default is 1.3 to make the player slightly larger.\n    /// </summary>\n    [Export]\n    public float PlayerModelScale { get; set; } = 1.3f;\n\n    /// <summary>\n    /// Walking animation intensity - higher = more pronounced movement.\n    /// </summary>\n    [Export]\n    public float WalkAnimIntensity { get; set; } = 1.0f;\n\n    /// <summary>\n    /// Current walk animation time (accumulator for sine wave).\n    /// </summary>\n    private float _walkAnimTime = 0.0f;\n\n    /// <summary>\n    /// Whether the player is currently walking (for animation state).\n    /// </summary>\n    private bool _isWalking = false;\n\n    /// <summary>\n    /// Base positions for body parts (stored on ready for animation offsets).\n    /// </summary>\n    private Vector2 _baseBodyPos = Vector2.Zero;\n    private Vector2 _baseHeadPos = Vector2.Zero;\n    private Vector2 _baseLeftArmPos = Vector2.Zero;\n    private Vector2 _baseRightArmPos = Vector2.Zero;\n\n    #endregion\n\n    #region Reload Animation System\n\n    /// <summary>\n    /// Animation phases for assault rifle reload sequence.\n    /// Maps to the R-F-R input system for visual feedback.\n    /// Three steps as requested:\n    /// 1. Take magazine with left hand from chest\n    /// 2. Insert magazine into rifle\n    /// 3. Pull the bolt/charging handle\n    /// </summary>\n    private enum ReloadAnimPhase\n    {\n        None,           // Normal arm positions (weapon held)\n        GrabMagazine,   // Step 1: Left hand moves to chest to grab new magazine\n        InsertMagazine, // Step 2: Left hand brings magazine to weapon, inserts it\n        PullBolt,       // Step 3: Character pulls the charging handle\n        ReturnIdle      // Arms return to normal weapon-holding position\n    }\n\n    /// <summary>\n    /// Current reload animation phase.\n    /// </summary>\n    private ReloadAnimPhase _reloadAnimPhase = ReloadAnimPhase.None;\n\n    /// <summary>\n    /// Reload animation phase timer for timed transitions.\n    /// </summary>\n    private float _reloadAnimTimer = 0.0f;\n\n    /// <summary>\n    /// Reload animation phase duration in seconds.\n    /// </summary>\n    private float _reloadAnimDuration = 0.0f;\n\n    // Target positions for reload arm animations (relative offsets from base positions)\n    // These are in local PlayerModel space\n    // Base positions: LeftArm (24, 6), RightArm (-2, 6)\n    // For reload, left arm goes to chest (vest/mag pouch area), then to weapon\n\n    // Step 1: Grab magazine from chest - left arm moves toward body center\n    // Base position: LeftArm (24, 6). We want target around (4, 2) = body/chest area\n    // So offset should be (4-24, 2-6) = (-20, -4)\n    // User feedback: previous -40 was too far (went behind back), -18 was not visible enough\n    private static readonly Vector2 ReloadArmLeftGrab = new Vector2(-20, -4);      // Left hand at chest/vest mag pouch (visible but not behind back)\n    private static readonly Vector2 ReloadArmRightHold = new Vector2(0, 0);        // Right hand stays on weapon grip\n\n    // Step 2: Insert magazine - left arm moves to weapon magwell (at middle of weapon, not at the end)\n    // Weapon length: ~40 pixels from center, magwell at middle\n    // Base (24, 6), want target around (12, 6) = middle of weapon, so offset (-12, 0)\n    private static readonly Vector2 ReloadArmLeftInsert = new Vector2(-12, 0);     // Left hand at weapon magwell (middle of weapon)\n    private static readonly Vector2 ReloadArmRightSteady = new Vector2(0, 2);      // Right hand steadies weapon\n\n    // Step 3: Pull bolt - right arm moves along rifle contour (back and forth motion)\n    // The right hand should trace the rifle's right side: forward, then back to pull bolt, then release\n    // Base RightArm (-2, 6). For dramatic motion: forward (+10, +2), back (-10, -4)\n    private static readonly Vector2 ReloadArmLeftSupport = new Vector2(-10, 0);    // Left hand holds near magwell\n    private static readonly Vector2 ReloadArmRightBoltStart = new Vector2(10, 2);  // Right hand at charging handle (forward on rifle)\n    private static readonly Vector2 ReloadArmRightBoltPull = new Vector2(-12, -4); // Right hand pulls bolt back (toward player)\n    private static readonly Vector2 ReloadArmRightBoltReturn = new Vector2(10, 2); // Right hand returns forward (bolt release)\n\n    // Target rotations for reload arm animations (in degrees)\n    private const float ReloadArmRotLeftGrab = -50.0f;     // Arm rotation when grabbing mag from chest\n    private const float ReloadArmRotRightHold = 0.0f;      // Right arm steady during grab\n    private const float ReloadArmRotLeftInsert = -15.0f;   // Left arm rotation when inserting\n    private const float ReloadArmRotRightSteady = 5.0f;    // Slight tilt while steadying\n    private const float ReloadArmRotLeftSupport = -10.0f;  // Left arm on foregrip/magwell\n    private const float ReloadArmRotRightBoltStart = -10.0f;  // Right arm at bolt handle\n    private const float ReloadArmRotRightBoltPull = -35.0f;   // Right arm rotation when pulling bolt back\n    private const float ReloadArmRotRightBoltReturn = -10.0f; // Right arm rotation when releasing bolt\n\n    // Animation durations for each reload phase (in seconds)\n    // INCREASED bolt durations for visible back-and-forth motion\n    private const float ReloadAnimGrabDuration = 0.25f;    // Time to grab magazine from chest\n    private const float ReloadAnimInsertDuration = 0.3f;   // Time to insert magazine\n    private const float ReloadAnimBoltPullDuration = 0.35f;   // Time to pull bolt back (increased for visibility)\n    private const float ReloadAnimBoltReturnDuration = 0.25f; // Time for bolt to return forward (increased for visibility)\n    private const float ReloadAnimReturnDuration = 0.2f;   // Time to return to idle\n\n    /// <summary>\n    /// Sub-phase for bolt pull animation (0 = pulling, 1 = returning)\n    /// </summary>\n    private int _boltPullSubPhase = 0;\n\n    #endregion\n\n    #region Grenade Animation System\n\n    /// <summary>\n    /// Animation phases for grenade throwing sequence.\n    /// Maps to the multi-step input system for visual feedback.\n    /// </summary>\n    private enum GrenadeAnimPhase\n    {\n        None,           // Normal arm positions (walking/idle)\n        GrabGrenade,    // Left hand moves to chest to grab grenade\n        PullPin,        // Right hand pulls pin (quick snap animation)\n        HandsApproach,  // Right hand moves toward left hand\n        Transfer,       // Grenade transfers to right hand\n        WindUp,         // Dynamic wind-up based on drag\n        Throw,          // Throwing motion\n        ReturnIdle      // Arms return to normal positions\n    }\n\n    /// <summary>\n    /// Current grenade animation phase.\n    /// </summary>\n    private GrenadeAnimPhase _grenadeAnimPhase = GrenadeAnimPhase.None;\n\n    /// <summary>\n    /// Animation phase timer for timed transitions.\n    /// </summary>\n    private float _grenadeAnimTimer = 0.0f;\n\n    /// <summary>\n    /// Animation phase duration in seconds.\n    /// </summary>\n    private float _grenadeAnimDuration = 0.0f;\n\n    /// <summary>\n    /// Current wind-up intensity (0.0 = no wind-up, 1.0 = maximum wind-up).\n    /// </summary>\n    private float _windUpIntensity = 0.0f;\n\n    /// <summary>\n    /// Previous mouse position for velocity calculation.\n    /// </summary>\n    private Vector2 _prevMousePos = Vector2.Zero;\n\n    /// <summary>\n    /// Mouse velocity history for smooth velocity calculation (stores last N velocities).\n    /// Used to get stable velocity at moment of release.\n    /// </summary>\n    private List<Vector2> _mouseVelocityHistory = new List<Vector2>();\n\n    /// <summary>\n    /// Maximum number of velocity samples to keep in history.\n    /// </summary>\n    private const int MouseVelocityHistorySize = 5;\n\n    /// <summary>\n    /// Current calculated mouse velocity (pixels per second).\n    /// </summary>\n    private Vector2 _currentMouseVelocity = Vector2.Zero;\n\n    /// <summary>\n    /// Total swing distance traveled during aiming (for momentum transfer calculation).\n    /// </summary>\n    private float _totalSwingDistance = 0.0f;\n\n    /// <summary>\n    /// Previous frame time for delta calculation in velocity tracking.\n    /// </summary>\n    private double _prevFrameTime = 0.0;\n\n    /// <summary>\n    /// Whether weapon is in sling position (lowered for grenade handling).\n    /// </summary>\n    private bool _weaponSlung = false;\n\n    /// <summary>\n    /// Reference to weapon mount for sling animation.\n    /// </summary>\n    private Node2D? _weaponMount;\n\n    /// <summary>\n    /// Base weapon mount position (for sling animation).\n    /// </summary>\n    private Vector2 _baseWeaponMountPos = Vector2.Zero;\n\n    /// <summary>\n    /// Base weapon mount rotation (for sling animation).\n    /// </summary>\n    private float _baseWeaponMountRot = 0.0f;\n\n    // Target positions for arm animations (relative offsets from base positions)\n    // These are in local PlayerModel space\n    // Base positions: LeftArm (24, 6), RightArm (-2, 6)\n    // Body position: (-4, 0), so left shoulder area is approximately x=0 to x=5\n    // To move left arm from x=24 to shoulder (x~5), we need offset of ~-20\n    // During grenade operations, left arm should be BEHIND the body (toward shoulder)\n    // not holding the weapon at the front\n    private static readonly Vector2 ArmLeftChest = new Vector2(-15, 0);        // Left hand moves back to chest/shoulder area to grab grenade\n    private static readonly Vector2 ArmRightPin = new Vector2(2, -2);          // Right hand slightly up for pin pull\n    private static readonly Vector2 ArmLeftExtended = new Vector2(-10, 2);     // Left hand at chest level with grenade (not extended forward)\n    private static readonly Vector2 ArmRightApproach = new Vector2(4, 0);      // Right hand approaching left\n    private static readonly Vector2 ArmLeftTransfer = new Vector2(-12, 3);     // Left hand drops back after transfer (clearly away from weapon)\n    private static readonly Vector2 ArmRightHold = new Vector2(3, 1);          // Right hand holding grenade\n    private static readonly Vector2 ArmRightWindMin = new Vector2(4, 3);       // Minimum wind-up position (arm back)\n    private static readonly Vector2 ArmRightWindMax = new Vector2(8, 5);       // Maximum wind-up position (arm further back)\n    private static readonly Vector2 ArmRightThrow = new Vector2(-4, -2);       // Throw follow-through (arm forward)\n    private static readonly Vector2 ArmLeftRelaxed = new Vector2(-20, 2);      // Left arm at shoulder/body - well away from weapon during wind-up/throw\n\n    // Target rotations for arm animations (in degrees)\n    // When left arm moves back to shoulder position, rotate to point \"down\" relative to body\n    // This makes the arm look like it's hanging at the side rather than reaching forward\n    private const float ArmRotGrab = -45.0f;         // Arm rotation when grabbing at chest (points inward/down)\n    private const float ArmRotPinPull = -15.0f;      // Right arm rotation when pulling pin\n    private const float ArmRotLeftAtChest = -30.0f;  // Left arm rotation while holding grenade at chest\n    private const float ArmRotWindMin = 15.0f;       // Right arm minimum wind-up rotation\n    private const float ArmRotWindMax = 35.0f;       // Right arm maximum wind-up rotation\n    private const float ArmRotThrow = -25.0f;        // Right arm throw rotation (swings forward)\n    private const float ArmRotLeftRelaxed = -60.0f;  // Left arm hangs down at side during wind-up/throw (points backward)\n\n    // Animation durations for each phase (in seconds)\n    private const float AnimGrabDuration = 0.2f;\n    private const float AnimPinDuration = 0.15f;\n    private const float AnimApproachDuration = 0.2f;\n    private const float AnimTransferDuration = 0.15f;\n    private const float AnimThrowDuration = 0.2f;\n    private const float AnimReturnDuration = 0.3f;\n\n    // Animation lerp speeds\n    private const float AnimLerpSpeed = 15.0f;        // Position interpolation speed\n    private const float AnimLerpSpeedFast = 25.0f;    // Fast interpolation for snappy movements\n\n    // Weapon sling position (lowered and rotated for chest carry)\n    private static readonly Vector2 WeaponSlingOffset = new Vector2(0, 15);    // Lower weapon\n    private const float WeaponSlingRotation = 1.2f;   // Rotate to hang down (radians, ~70 degrees)\n\n    #endregion\n\n    /// <summary>\n    /// Signal emitted when reload sequence progresses.\n    /// </summary>\n    [Signal]\n    public delegate void ReloadSequenceProgressEventHandler(int step, int total);\n\n    /// <summary>\n    /// Signal emitted when reload completes.\n    /// </summary>\n    [Signal]\n    public delegate void ReloadCompletedEventHandler();\n\n    /// <summary>\n    /// Signal emitted when reload starts (first step of sequence).\n    /// This signal notifies enemies that the player has begun reloading.\n    /// </summary>\n    [Signal]\n    public delegate void ReloadStartedEventHandler();\n\n    /// <summary>\n    /// Signal emitted when player tries to shoot with empty weapon.\n    /// This signal notifies enemies that the player is out of ammo.\n    /// </summary>\n    [Signal]\n    public delegate void AmmoDepletedEventHandler();\n\n    /// <summary>\n    /// Signal emitted when grenade count changes.\n    /// </summary>\n    [Signal]\n    public delegate void GrenadeChangedEventHandler(int current, int maximum);\n\n    /// <summary>\n    /// Signal emitted when a grenade is thrown.\n    /// </summary>\n    [Signal]\n    public delegate void GrenadeThrownEventHandler();\n\n    public override void _Ready()\n    {\n        base._Ready();\n\n        // Get player model and sprite references for visual feedback\n        _playerModel = GetNodeOrNull<Node2D>(\"PlayerModel\");\n        if (_playerModel != null)\n        {\n            _bodySprite = _playerModel.GetNodeOrNull<Sprite2D>(\"Body\");\n            _headSprite = _playerModel.GetNodeOrNull<Sprite2D>(\"Head\");\n            _leftArmSprite = _playerModel.GetNodeOrNull<Sprite2D>(\"LeftArm\");\n            _rightArmSprite = _playerModel.GetNodeOrNull<Sprite2D>(\"RightArm\");\n            // Legacy compatibility - _sprite points to body\n            _sprite = _bodySprite;\n        }\n        else\n        {\n            // Fallback to old single sprite structure for compatibility\n            _sprite = GetNodeOrNull<Sprite2D>(\"Sprite2D\");\n        }\n\n        // Configure health based on difficulty\n        if (HealthComponent != null)\n        {\n            // Check if Power Fantasy mode is active for special health configuration\n            var difficultyManager = GetNodeOrNull(\"/root/DifficultyManager\");\n            bool isPowerFantasy = difficultyManager != null && (bool)difficultyManager.Call(\"is_power_fantasy_mode\");\n\n            if (isPowerFantasy)\n            {\n                // Power Fantasy mode: 10 HP (fixed, not random)\n                HealthComponent.UseRandomHealth = false;\n                HealthComponent.MaxHealth = 10;\n                HealthComponent.InitialHealth = 10;\n                HealthComponent.InitializeHealth();\n                GD.Print($\"[Player] {Name}: Power Fantasy mode - spawned with {HealthComponent.CurrentHealth}/{HealthComponent.MaxHealth} HP\");\n            }\n            else\n            {\n                // Normal difficulties: random health (2-4 HP)\n                HealthComponent.UseRandomHealth = true;\n                HealthComponent.MinRandomHealth = 2;\n                HealthComponent.MaxRandomHealth = 4;\n                HealthComponent.InitializeHealth();\n                GD.Print($\"[Player] {Name}: Spawned with health {HealthComponent.CurrentHealth}/{HealthComponent.MaxHealth}\");\n            }\n\n            // Connect to health changed signal for visual feedback\n            HealthComponent.HealthChanged += OnPlayerHealthChanged;\n        }\n\n        // Update visual based on initial health\n        UpdateHealthVisual();\n\n        // Preload bullet scene if not set in inspector\n        if (BulletScene == null)\n        {\n            // Try C# bullet scene first, fallback to GDScript version\n            BulletScene = GD.Load<PackedScene>(\"res://scenes/projectiles/csharp/Bullet.tscn\");\n            if (BulletScene == null)\n            {\n                BulletScene = GD.Load<PackedScene>(\"res://scenes/projectiles/Bullet.tscn\");\n            }\n        }\n\n        // Get grenade scene from GrenadeManager (supports grenade type selection)\n        // GrenadeManager handles the currently selected grenade type (Flashbang or Frag)\n        if (GrenadeScene == null)\n        {\n            var grenadeManager = GetNodeOrNull(\"/root/GrenadeManager\");\n            if (grenadeManager != null && grenadeManager.HasMethod(\"get_current_grenade_scene\"))\n            {\n                var sceneVariant = grenadeManager.Call(\"get_current_grenade_scene\");\n                GrenadeScene = sceneVariant.As<PackedScene>();\n                if (GrenadeScene != null)\n                {\n                    var grenadeNameVariant = grenadeManager.Call(\"get_grenade_name\", grenadeManager.Get(\"current_grenade_type\"));\n                    var grenadeName = grenadeNameVariant.AsString();\n                    LogToFile($\"[Player.Grenade] Grenade scene loaded from GrenadeManager: {grenadeName}\");\n                }\n                else\n                {\n                    LogToFile($\"[Player.Grenade] WARNING: GrenadeManager returned null grenade scene\");\n                }\n            }\n            else\n            {\n                // Fallback to flashbang if GrenadeManager is not available\n                var grenadePath = \"res://scenes/projectiles/FlashbangGrenade.tscn\";\n                GrenadeScene = GD.Load<PackedScene>(grenadePath);\n                if (GrenadeScene != null)\n                {\n                    LogToFile($\"[Player.Grenade] Grenade scene loaded from fallback: {grenadePath}\");\n                }\n                else\n                {\n                    LogToFile($\"[Player.Grenade] WARNING: Grenade scene not found at {grenadePath}\");\n                }\n            }\n        }\n        else\n        {\n            LogToFile($\"[Player.Grenade] Grenade scene already set in inspector\");\n        }\n\n        // Detect if we're on the tutorial level\n        // Tutorial level is: scenes/levels/csharp/TestTier.tscn with tutorial_level.gd script\n        var currentScene = GetTree().CurrentScene;\n        if (currentScene != null)\n        {\n            var scenePath = currentScene.SceneFilePath;\n            // Tutorial level is detected by:\n            // 1. Scene path contains \"csharp/TestTier\" (the tutorial scene)\n            // 2. OR scene uses tutorial_level.gd script\n            _isTutorialLevel = scenePath.Contains(\"csharp/TestTier\");\n\n            // Also check if the scene script is tutorial_level.gd\n            var script = currentScene.GetScript();\n            if (script.Obj is GodotObject scriptObj)\n            {\n                var scriptPath = scriptObj.Get(\"resource_path\").AsString();\n                if (scriptPath.Contains(\"tutorial_level\"))\n                {\n                    _isTutorialLevel = true;\n                }\n            }\n        }\n\n        // Initialize grenade count based on level type\n        // Tutorial: infinite grenades (max count)\n        // Other levels: 1 grenade\n        if (_isTutorialLevel)\n        {\n            _currentGrenades = MaxGrenades;\n            LogToFile($\"[Player.Grenade] Tutorial level detected - infinite grenades enabled\");\n        }\n        else\n        {\n            _currentGrenades = 1;\n            LogToFile($\"[Player.Grenade] Normal level - starting with 1 grenade\");\n        }\n\n        // Auto-equip weapon if not set but a weapon child exists\n        if (CurrentWeapon == null)\n        {\n            CurrentWeapon = GetNodeOrNull<BaseWeapon>(\"AssaultRifle\");\n            if (CurrentWeapon != null)\n            {\n                GD.Print($\"[Player] {Name}: Auto-equipped weapon {CurrentWeapon.Name}\");\n            }\n        }\n\n        // Store base positions for walking animation\n        if (_bodySprite != null)\n        {\n            _baseBodyPos = _bodySprite.Position;\n            LogToFile($\"[Player.Init] Body sprite found at position: {_baseBodyPos}\");\n        }\n        else\n        {\n            LogToFile(\"[Player.Init] WARNING: Body sprite NOT found!\");\n        }\n        if (_headSprite != null)\n        {\n            _baseHeadPos = _headSprite.Position;\n            LogToFile($\"[Player.Init] Head sprite found at position: {_baseHeadPos}\");\n        }\n        else\n        {\n            LogToFile(\"[Player.Init] WARNING: Head sprite NOT found!\");\n        }\n        if (_leftArmSprite != null)\n        {\n            _baseLeftArmPos = _leftArmSprite.Position;\n            LogToFile($\"[Player.Init] Left arm sprite found at position: {_baseLeftArmPos}\");\n        }\n        else\n        {\n            LogToFile(\"[Player.Init] WARNING: Left arm sprite NOT found!\");\n        }\n        if (_rightArmSprite != null)\n        {\n            _baseRightArmPos = _rightArmSprite.Position;\n            LogToFile($\"[Player.Init] Right arm sprite found at position: {_baseRightArmPos}\");\n        }\n        else\n        {\n            LogToFile(\"[Player.Init] WARNING: Right arm sprite NOT found!\");\n        }\n\n        // Apply scale to player model for larger appearance\n        if (_playerModel != null)\n        {\n            _playerModel.Scale = new Vector2(PlayerModelScale, PlayerModelScale);\n        }\n\n        // Get weapon mount reference for sling animation\n        _weaponMount = _playerModel?.GetNodeOrNull<Node2D>(\"WeaponMount\");\n        if (_weaponMount != null)\n        {\n            _baseWeaponMountPos = _weaponMount.Position;\n            _baseWeaponMountRot = _weaponMount.Rotation;\n        }\n\n        // Set z-index for proper layering: head should be above weapon\n        // The weapon has z_index = 1, so head should be 2 or higher\n        if (_headSprite != null)\n        {\n            _headSprite.ZIndex = 3;  // Head on top (above weapon)\n        }\n        if (_bodySprite != null)\n        {\n            _bodySprite.ZIndex = 1;  // Body same level as weapon\n        }\n        if (_leftArmSprite != null)\n        {\n            _leftArmSprite.ZIndex = 2;  // Arms between body and head\n        }\n        if (_rightArmSprite != null)\n        {\n            _rightArmSprite.ZIndex = 2;  // Arms between body and head\n        }\n\n        // Connect to GameManager's debug mode signal for F7 toggle\n        ConnectDebugModeSignal();\n\n        // Initialize CasingPusher Area2D for pushing shell casings (Issue #392 Iteration 8)\n        ConnectCasingPusherSignals();\n\n        // Log ready status with full info\n        int currentAmmo = CurrentWeapon?.CurrentAmmo ?? 0;\n        int maxAmmo = CurrentWeapon?.WeaponData?.MagazineSize ?? 0;\n        int currentHealth = (int)(HealthComponent?.CurrentHealth ?? 0);\n        int maxHealth = (int)(HealthComponent?.MaxHealth ?? 0);\n        LogToFile($\"[Player] Ready! Ammo: {currentAmmo}/{maxAmmo}, Grenades: {_currentGrenades}/{MaxGrenades}, Health: {currentHealth}/{maxHealth}\");\n        LogToFile(\"[Player.Grenade] Throwing system: VELOCITY-BASED (v2.0 - mouse velocity at release)\");\n    }\n\n    /// <summary>\n    /// Called when player health changes - updates visual feedback.\n    /// </summary>\n    private void OnPlayerHealthChanged(float currentHealth, float maxHealth)\n    {\n        GD.Print($\"[Player] {Name}: Health changed to {currentHealth}/{maxHealth} ({HealthComponent?.HealthPercent * 100:F0}%)\");\n        UpdateHealthVisual();\n    }\n\n    /// <summary>\n    /// Updates the sprite color based on current health percentage.\n    /// </summary>\n    private void UpdateHealthVisual()\n    {\n        if (HealthComponent == null)\n        {\n            return;\n        }\n\n        // Interpolate color based on health percentage\n        float healthPercent = HealthComponent.HealthPercent;\n        Color color = FullHealthColor.Lerp(LowHealthColor, 1.0f - healthPercent);\n        SetAllSpritesModulate(color);\n    }\n\n    /// <summary>\n    /// Public method to refresh the health visual.\n    /// Called by effects managers (like LastChanceEffectsManager) after they finish\n    /// modifying player sprite colors, to ensure the player returns to correct\n    /// health-based coloring.\n    /// </summary>\n    public void RefreshHealthVisual()\n    {\n        UpdateHealthVisual();\n    }\n\n    /// <summary>\n    /// Sets the modulate color on all player sprite parts.\n    /// The armband is a separate sibling sprite (not child of RightArm) that keeps\n    /// its original color, so all body parts use the same health-based color.\n    /// </summary>\n    /// <param name=\"color\">The color to apply to all sprites.</param>\n    private void SetAllSpritesModulate(Color color)\n    {\n        if (_bodySprite != null)\n        {\n            _bodySprite.Modulate = color;\n        }\n        if (_headSprite != null)\n        {\n            _headSprite.Modulate = color;\n        }\n        if (_leftArmSprite != null)\n        {\n            _leftArmSprite.Modulate = color;\n        }\n        if (_rightArmSprite != null)\n        {\n            // Right arm uses the same color as other body parts.\n            // The armband is now a separate sibling sprite (Armband node under PlayerModel)\n            // that doesn't inherit this modulate, keeping its bright red color visible.\n            _rightArmSprite.Modulate = color;\n        }\n        // If using old single sprite structure\n        if (_playerModel == null && _sprite != null)\n        {\n            _sprite.Modulate = color;\n        }\n    }\n\n    #region Casing Pusher (Issue #392)\n\n    /// <summary>\n    /// Connects the CasingPusher Area2D signals for reliable casing detection (Issue #392 Iteration 8).\n    /// Using body_entered/body_exited signals instead of polling get_overlapping_bodies()\n    /// ensures casings are detected even when player approaches from narrow side.\n    /// </summary>\n    private void ConnectCasingPusherSignals()\n    {\n        _casingPusher = GetNodeOrNull<Area2D>(\"CasingPusher\");\n        if (_casingPusher == null)\n        {\n            // CasingPusher not present in scene - this is fine for older scenes\n            return;\n        }\n\n        // Connect body_entered and body_exited signals\n        _casingPusher.BodyEntered += OnCasingPusherBodyEntered;\n        _casingPusher.BodyExited += OnCasingPusherBodyExited;\n    }\n\n    /// <summary>\n    /// Called when a body enters the CasingPusher Area2D.\n    /// Tracks casings for reliable pushing detection.\n    /// </summary>\n    private void OnCasingPusherBodyEntered(Node2D body)\n    {\n        if (body is RigidBody2D rigidBody && rigidBody.HasMethod(\"receive_kick\"))\n        {\n            if (!_overlappingCasings.Contains(rigidBody))\n            {\n                _overlappingCasings.Add(rigidBody);\n            }\n        }\n    }\n\n    /// <summary>\n    /// Called when a body exits the CasingPusher Area2D.\n    /// Removes casings from tracking list.\n    /// </summary>\n    private void OnCasingPusherBodyExited(Node2D body)\n    {\n        if (body is RigidBody2D rigidBody)\n        {\n            _overlappingCasings.Remove(rigidBody);\n        }\n    }\n\n    /// <summary>\n    /// Pushes casings that we're overlapping with using Area2D detection (Issue #392 Iteration 8).\n    /// Uses signal-tracked casings combined with polling for maximum reliability.\n    /// </summary>\n    private void PushCasingsWithArea2D()\n    {\n        if (_casingPusher == null)\n        {\n            return;\n        }\n\n        // Don't push if not moving\n        if (Velocity.LengthSquared() < 1.0f)\n        {\n            return;\n        }\n\n        // Combine both signal-tracked casings and polled overlapping bodies for reliability\n        var casingsToPush = new System.Collections.Generic.HashSet<RigidBody2D>();\n\n        // Add signal-tracked casings\n        foreach (var casing in _overlappingCasings)\n        {\n            if (IsInstanceValid(casing))\n            {\n                casingsToPush.Add(casing);\n            }\n        }\n\n        // Also poll for any casings that might have been missed by signals\n        foreach (var body in _casingPusher.GetOverlappingBodies())\n        {\n            if (body is RigidBody2D rigidBody && rigidBody.HasMethod(\"receive_kick\"))\n            {\n                casingsToPush.Add(rigidBody);\n            }\n        }\n\n        // Push all detected casings\n        foreach (var casing in casingsToPush)\n        {\n            // Calculate push direction from player center to casing position (Issue #424)\n            // This makes casings fly away based on which side they're pushed from\n            var pushDir = (casing.GlobalPosition - GlobalPosition).Normalized();\n            var pushStrength = Velocity.Length() * CasingPushForce / 100.0f;\n            var impulse = pushDir * pushStrength;\n            casing.Call(\"receive_kick\", impulse);\n        }\n    }\n\n    #endregion\n\n    public override void _PhysicsProcess(double delta)\n    {\n        // Detect weapon pose after waiting a few frames for level scripts to add weapons\n        if (!_weaponPoseApplied)\n        {\n            _weaponDetectFrameCount++;\n            if (_weaponDetectFrameCount >= WeaponDetectWaitFrames)\n            {\n                DetectAndApplyWeaponPose();\n                _weaponPoseApplied = true;\n            }\n        }\n\n        Vector2 inputDirection = GetInputDirection();\n        ApplyMovement(inputDirection, (float)delta);\n\n        // Push any casings we're overlapping with using Area2D detection (Issue #392 Iteration 8)\n        PushCasingsWithArea2D();\n\n        // Update player model rotation to face the aim direction (rifle direction)\n        UpdatePlayerModelRotation();\n\n        // Update walking animation based on movement (only if not in grenade or reload animation)\n        if (_grenadeAnimPhase == GrenadeAnimPhase.None && _reloadAnimPhase == ReloadAnimPhase.None)\n        {\n            UpdateWalkAnimation((float)delta, inputDirection);\n        }\n\n        // Update grenade animation\n        UpdateGrenadeAnimation((float)delta);\n\n        // Update reload animation\n        UpdateReloadAnimation((float)delta);\n\n        // Handle throw rotation animation (restore player rotation after throw)\n        HandleThrowRotationAnimation((float)delta);\n\n        // Handle sniper scope input (RMB) when SniperRifle is equipped\n        // This takes priority over grenade input since the sniper uses RMB for scoping\n        bool sniperScopeConsumedInput = HandleSniperScopeInput();\n\n        // Handle grenade input first (so it can consume shoot input)\n        // Skip if sniper scope already consumed the RMB input\n        if (!sniperScopeConsumedInput)\n        {\n            HandleGrenadeInput();\n        }\n\n        // Make active grenade follow player if held\n        if (_activeGrenade != null && IsInstanceValid(_activeGrenade))\n        {\n            _activeGrenade.GlobalPosition = GlobalPosition;\n        }\n\n        // Handle shooting input - support both automatic and semi-automatic weapons\n        // Allow shooting when not in grenade preparation\n        // In simple mode, RMB is for grenades so only LMB (shoot) should work\n        bool canShoot = _grenadeState == GrenadeState.Idle || _grenadeState == GrenadeState.TimerStarted || _grenadeState == GrenadeState.SimpleAiming;\n        if (canShoot)\n        {\n            HandleShootingInput();\n        }\n\n        // Handle reload sequence input (R-F-R)\n        HandleReloadSequenceInput();\n\n        // Handle fire mode toggle (B key for burst/auto toggle)\n        if (Input.IsActionJustPressed(\"toggle_fire_mode\"))\n        {\n            ToggleFireMode();\n        }\n    }\n\n    /// <summary>\n    /// Handles shooting input based on weapon type.\n    /// For automatic weapons: fires while held.\n    /// For semi-automatic/burst: fires on press.\n    /// Also handles bullet in chamber mechanics during reload sequence.\n    /// </summary>\n    private void HandleShootingInput()\n    {\n        if (CurrentWeapon == null)\n        {\n            // Fallback to original click-to-shoot behavior\n            if (Input.IsActionJustPressed(\"shoot\"))\n            {\n                Shoot();\n            }\n            return;\n        }\n\n        // Check if weapon is automatic (based on WeaponData)\n        bool isAutomatic = CurrentWeapon.WeaponData?.IsAutomatic ?? false;\n\n        // For AssaultRifle, also check if it's in automatic fire mode\n        if (CurrentWeapon is AssaultRifle assaultRifle)\n        {\n            isAutomatic = assaultRifle.CurrentFireMode == FireMode.Automatic;\n        }\n\n        // Determine if shooting input is active\n        bool shootInputActive = isAutomatic ? Input.IsActionPressed(\"shoot\") : Input.IsActionJustPressed(\"shoot\");\n\n        if (!shootInputActive)\n        {\n            return;\n        }\n\n        // Check if weapon is empty before trying to shoot (not in reload sequence)\n        // This notifies enemies that the player tried to shoot with no ammo\n        if (!_isReloadingSequence && CurrentWeapon.CurrentAmmo <= 0)\n        {\n            // Emit signal to notify enemies that player is vulnerable (out of ammo)\n            EmitSignal(SignalName.AmmoDepleted);\n            // The weapon will play the empty click sound\n        }\n\n        // Handle shooting based on reload sequence state\n        if (_isReloadingSequence)\n        {\n            // In reload sequence\n            if (_reloadSequenceStep == 1)\n            {\n                // Step 1 (only R pressed, waiting for F): shooting resets the combo\n                GD.Print(\"[Player] Shooting during reload step 1 - resetting reload sequence\");\n                ResetReloadSequence();\n                Shoot();\n            }\n            else if (_reloadSequenceStep == 2)\n            {\n                // Step 2 (R->F pressed, waiting for final R): try to fire chamber bullet\n                if (CurrentWeapon.CanFireChamberBullet)\n                {\n                    // Fire the chamber bullet\n                    Vector2 mousePos = GetGlobalMousePosition();\n                    Vector2 shootDirection = (mousePos - GlobalPosition).Normalized();\n\n                    if (CurrentWeapon.FireChamberBullet(shootDirection))\n                    {\n                        GD.Print(\"[Player] Fired bullet in chamber during reload\");\n                        // Note: Sound is handled by the weapon's FireChamberBullet implementation\n                    }\n                }\n                else if (CurrentWeapon.ChamberBulletFired)\n                {\n                    // Chamber bullet already fired, can't shoot until reload completes\n                    GD.Print(\"[Player] Cannot shoot - chamber bullet already fired, wait for reload to complete\");\n                    PlayEmptyClickSound();\n                }\n                else\n                {\n                    // No bullet in chamber (magazine was empty when reload started)\n                    GD.Print(\"[Player] Cannot shoot - no bullet in chamber, wait for reload to complete\");\n                    PlayEmptyClickSound();\n                }\n            }\n        }\n        else\n        {\n            // Not in reload sequence - normal shooting\n            Shoot();\n        }\n    }\n\n    /// <summary>\n    /// Plays the empty click sound when trying to shoot without ammo.\n    /// </summary>\n    private void PlayEmptyClickSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_empty_click\"))\n        {\n            audioManager.Call(\"play_empty_click\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Toggles fire mode on the current weapon (if supported).\n    /// </summary>\n    private void ToggleFireMode()\n    {\n        if (CurrentWeapon is AssaultRifle assaultRifle)\n        {\n            assaultRifle.ToggleFireMode();\n        }\n    }\n\n    /// <summary>\n    /// Updates the player model rotation to face the aim direction.\n    /// The player model (body, head, arms) rotates to follow the rifle's aim direction.\n    /// This creates the appearance of the player rotating their whole body toward the target.\n    /// TACTICAL RELOAD (Issue #437): During shotgun reload OR when RMB is held (dragging),\n    /// player model rotation is locked to allow the player to keep aiming at a specific\n    /// spot while performing reload gestures.\n    ///\n    /// FIX (Issue #437 feedback): Lock rotation as soon as RMB is pressed, not just when\n    /// reload state changes. This prevents barrel/player shift during quick one-motion\n    /// reload gestures (drag up then down without releasing RMB).\n    /// </summary>\n    private void UpdatePlayerModelRotation()\n    {\n        if (_playerModel == null)\n        {\n            return;\n        }\n\n        // TACTICAL RELOAD (Issue #437): Don't rotate player model during shotgun reload\n        // OR when dragging (RMB is held). This ensures the player freezes immediately\n        // when RMB is pressed, before any state change occurs.\n        var shotgun = GetNodeOrNull<Shotgun>(\"Shotgun\");\n        if (shotgun != null && (shotgun.ReloadState != ShotgunReloadState.NotReloading || shotgun.IsDragging))\n        {\n            // Keep current rotation locked - don't follow mouse\n            return;\n        }\n\n        // Get the aim direction from the weapon if available\n        Vector2 aimDirection;\n        if (CurrentWeapon is AssaultRifle assaultRifle)\n        {\n            aimDirection = assaultRifle.AimDirection;\n        }\n        else if (CurrentWeapon is SniperRifle sniperRifle)\n        {\n            aimDirection = sniperRifle.AimDirection;\n        }\n        else\n        {\n            // Fallback: calculate direction to mouse cursor\n            Vector2 mousePos = GetGlobalMousePosition();\n            Vector2 toMouse = mousePos - GlobalPosition;\n            if (toMouse.LengthSquared() > 0.001f)\n            {\n                aimDirection = toMouse.Normalized();\n            }\n            else\n            {\n                return; // No valid direction\n            }\n        }\n\n        // Calculate target rotation angle\n        float targetAngle = aimDirection.Angle();\n\n        // Apply rotation to the player model\n        _playerModel.Rotation = targetAngle;\n\n        // Handle sprite flipping for left/right aim\n        // When aiming left (angle > 90¬∞ or < -90¬∞), flip vertically to avoid upside-down appearance\n        bool aimingLeft = Mathf.Abs(targetAngle) > Mathf.Pi / 2;\n\n        // Flip the player model vertically when aiming left\n        if (aimingLeft)\n        {\n            _playerModel.Scale = new Vector2(PlayerModelScale, -PlayerModelScale);\n        }\n        else\n        {\n            _playerModel.Scale = new Vector2(PlayerModelScale, PlayerModelScale);\n        }\n    }\n\n    /// <summary>\n    /// Detects the equipped weapon type and applies appropriate arm positioning.\n    /// Called from _PhysicsProcess() after a few frames to ensure level scripts\n    /// have finished adding weapons to the player node.\n    /// </summary>\n    private void DetectAndApplyWeaponPose()\n    {\n        LogToFile($\"[Player] Detecting weapon pose (frame {_weaponDetectFrameCount})...\");\n        var detectedType = WeaponType.Rifle;  // Default to rifle pose\n\n        // Check for weapon children - weapons are added directly to player by level scripts\n        // Check in order of specificity: MiniUzi (SMG), Shotgun, SilencedPistol, then default to Rifle\n        var miniUzi = GetNodeOrNull<BaseWeapon>(\"MiniUzi\");\n        var shotgun = GetNodeOrNull<BaseWeapon>(\"Shotgun\");\n        var silencedPistol = GetNodeOrNull<BaseWeapon>(\"SilencedPistol\");\n\n        if (miniUzi != null)\n        {\n            detectedType = WeaponType.SMG;\n            LogToFile(\"[Player] Detected weapon: Mini UZI (SMG pose)\");\n        }\n        else if (shotgun != null)\n        {\n            detectedType = WeaponType.Shotgun;\n            LogToFile(\"[Player] Detected weapon: Shotgun (Shotgun pose)\");\n        }\n        else if (silencedPistol != null)\n        {\n            detectedType = WeaponType.Pistol;\n            LogToFile(\"[Player] Detected weapon: Silenced Pistol (Pistol pose)\");\n        }\n        else\n        {\n            // Default to rifle (AssaultRifle or no weapon)\n            detectedType = WeaponType.Rifle;\n            LogToFile(\"[Player] Detected weapon: Rifle (default pose)\");\n        }\n\n        _currentWeaponType = detectedType;\n        ApplyWeaponArmOffsets();\n    }\n\n    /// <summary>\n    /// Applies arm position offsets based on current weapon type.\n    /// Modifies base arm positions to create appropriate weapon-holding poses.\n    /// </summary>\n    private void ApplyWeaponArmOffsets()\n    {\n        // Original positions from Player.tscn: LeftArm (24, 6), RightArm (-2, 6)\n        var originalLeftArmPos = new Vector2(24, 6);\n        var originalRightArmPos = new Vector2(-2, 6);\n\n        switch (_currentWeaponType)\n        {\n            case WeaponType.SMG:\n                // SMG pose: Compact two-handed grip\n                // Left arm moves back toward body for shorter weapon\n                // Right arm moves forward slightly to meet left hand\n                _baseLeftArmPos = originalLeftArmPos + SmgLeftArmOffset;\n                _baseRightArmPos = originalRightArmPos + SmgRightArmOffset;\n                LogToFile($\"[Player] Applied SMG arm pose: Left={_baseLeftArmPos}, Right={_baseRightArmPos}\");\n                break;\n\n            case WeaponType.Shotgun:\n                // Shotgun pose: Similar to rifle but slightly tighter\n                _baseLeftArmPos = originalLeftArmPos + new Vector2(-3, 0);\n                _baseRightArmPos = originalRightArmPos + new Vector2(1, 0);\n                LogToFile($\"[Player] Applied Shotgun arm pose: Left={_baseLeftArmPos}, Right={_baseRightArmPos}\");\n                break;\n\n            case WeaponType.Pistol:\n                // Pistol pose: Compact two-handed pistol grip (Weaver/Isoceles stance)\n                // Similar to SMG but even more compact - suppressed pistol is shorter than SMG\n                // Left arm supports under the right hand (close to body)\n                // Right arm extends forward slightly for aiming\n                _baseLeftArmPos = originalLeftArmPos + new Vector2(-14, 0);  // More compact than SMG (-10)\n                _baseRightArmPos = originalRightArmPos + new Vector2(4, 0);  // Slightly more forward than SMG (3)\n                LogToFile($\"[Player] Applied Pistol arm pose: Left={_baseLeftArmPos}, Right={_baseRightArmPos}\");\n                break;\n\n            case WeaponType.Rifle:\n            default:\n                // Rifle pose: Standard extended grip (original positions)\n                _baseLeftArmPos = originalLeftArmPos;\n                _baseRightArmPos = originalRightArmPos;\n                LogToFile($\"[Player] Applied Rifle arm pose: Left={_baseLeftArmPos}, Right={_baseRightArmPos}\");\n                break;\n        }\n\n        // Apply new base positions to sprites immediately\n        if (_leftArmSprite != null)\n        {\n            _leftArmSprite.Position = _baseLeftArmPos;\n        }\n        if (_rightArmSprite != null)\n        {\n            _rightArmSprite.Position = _baseRightArmPos;\n        }\n    }\n\n    /// <summary>\n    /// Gets the normalized input direction from player input.\n    /// </summary>\n    /// <returns>Normalized direction vector.</returns>\n    private Vector2 GetInputDirection()\n    {\n        Vector2 direction = Vector2.Zero;\n        direction.X = Input.GetAxis(\"move_left\", \"move_right\");\n        direction.Y = Input.GetAxis(\"move_up\", \"move_down\");\n\n        // Normalize to prevent faster diagonal movement\n        if (direction.Length() > 1.0f)\n        {\n            direction = direction.Normalized();\n        }\n\n        return direction;\n    }\n\n    /// <summary>\n    /// Updates the walking animation based on player movement state.\n    /// Creates a natural bobbing motion for body parts during movement.\n    /// </summary>\n    /// <param name=\"delta\">Time since last frame.</param>\n    /// <param name=\"inputDirection\">Current movement input direction.</param>\n    private void UpdateWalkAnimation(float delta, Vector2 inputDirection)\n    {\n        bool isMoving = inputDirection != Vector2.Zero || Velocity.Length() > 10.0f;\n\n        if (isMoving)\n        {\n            // Accumulate animation time based on movement speed\n            float speedFactor = Velocity.Length() / MaxSpeed;\n            _walkAnimTime += delta * WalkAnimSpeed * speedFactor;\n            _isWalking = true;\n\n            // Calculate animation offsets using sine waves\n            // Body bobs up and down (frequency = 2x for double step)\n            float bodyBob = Mathf.Sin(_walkAnimTime * 2.0f) * 1.5f * WalkAnimIntensity;\n\n            // Head bobs slightly less than body (dampened)\n            float headBob = Mathf.Sin(_walkAnimTime * 2.0f) * 0.8f * WalkAnimIntensity;\n\n            // Arms swing opposite to each other (alternating)\n            float armSwing = Mathf.Sin(_walkAnimTime) * 3.0f * WalkAnimIntensity;\n\n            // Apply offsets to sprites\n            if (_bodySprite != null)\n            {\n                _bodySprite.Position = _baseBodyPos + new Vector2(0, bodyBob);\n            }\n\n            if (_headSprite != null)\n            {\n                _headSprite.Position = _baseHeadPos + new Vector2(0, headBob);\n            }\n\n            if (_leftArmSprite != null)\n            {\n                // Left arm swings forward/back (y-axis in top-down)\n                _leftArmSprite.Position = _baseLeftArmPos + new Vector2(armSwing, 0);\n            }\n\n            if (_rightArmSprite != null)\n            {\n                // Right arm swings opposite to left arm\n                _rightArmSprite.Position = _baseRightArmPos + new Vector2(-armSwing, 0);\n            }\n        }\n        else\n        {\n            // Return to idle pose smoothly\n            if (_isWalking)\n            {\n                _isWalking = false;\n                _walkAnimTime = 0.0f;\n            }\n\n            // Interpolate back to base positions\n            float lerpSpeed = 10.0f * delta;\n            if (_bodySprite != null)\n            {\n                _bodySprite.Position = _bodySprite.Position.Lerp(_baseBodyPos, lerpSpeed);\n            }\n            if (_headSprite != null)\n            {\n                _headSprite.Position = _headSprite.Position.Lerp(_baseHeadPos, lerpSpeed);\n            }\n            if (_leftArmSprite != null)\n            {\n                _leftArmSprite.Position = _leftArmSprite.Position.Lerp(_baseLeftArmPos, lerpSpeed);\n            }\n            if (_rightArmSprite != null)\n            {\n                _rightArmSprite.Position = _rightArmSprite.Position.Lerp(_baseRightArmPos, lerpSpeed);\n            }\n        }\n    }\n\n    /// <summary>\n    /// Handles the R-F-R reload sequence input.\n    /// Step 0: Press R to start sequence (eject magazine)\n    /// Step 1: Press F to continue (insert new magazine)\n    /// Step 2: Press R to complete reload instantly (chamber round)\n    ///\n    /// Bullet in chamber mechanics:\n    /// - At step 1 (R pressed): shooting resets the combo\n    /// - At step 2 (R->F pressed): if previous magazine had ammo, one chamber bullet can be fired\n    /// - After reload: if chamber bullet was fired, subtract one from new magazine\n    ///\n    /// Note: This reload sequence is skipped for weapons that use tube magazines (like Shotgun),\n    /// which have their own shell-by-shell reload mechanism via RMB drag gestures.\n    /// </summary>\n    private void HandleReloadSequenceInput()\n    {\n        if (CurrentWeapon == null)\n        {\n            return;\n        }\n\n        // Skip R-F-R reload sequence for weapons that use tube magazines (like Shotgun)\n        // These weapons have their own reload mechanism (shell-by-shell via RMB gestures)\n        // Pressing R key should be ignored for these weapons to avoid breaking ammo tracking\n        if (CurrentWeapon is Shotgun)\n        {\n            return;\n        }\n\n        // Can't reload if magazine is full (and not in reload sequence)\n        if (!_isReloadingSequence && CurrentWeapon.CurrentAmmo >= (CurrentWeapon.WeaponData?.MagazineSize ?? 0))\n        {\n            return;\n        }\n\n        // Can't reload if no reserve ammo (and not in reload sequence)\n        if (!_isReloadingSequence && CurrentWeapon.ReserveAmmo <= 0)\n        {\n            return;\n        }\n\n        // Handle R key (first and third step)\n        if (Input.IsActionJustPressed(\"reload\"))\n        {\n            if (_reloadSequenceStep == 0 || _reloadSequenceStep == 1)\n            {\n                // Check if we can start a new reload (need ammo or already in sequence)\n                if (_reloadSequenceStep == 0)\n                {\n                    // Starting fresh - check conditions\n                    if (CurrentWeapon.CurrentAmmo >= (CurrentWeapon.WeaponData?.MagazineSize ?? 0))\n                    {\n                        return; // Magazine is full\n                    }\n                    if (CurrentWeapon.ReserveAmmo <= 0)\n                    {\n                        return; // No reserve ammo\n                    }\n                }\n\n                // Start or restart reload sequence\n                // This handles both initial R press and R->R sequence (restart)\n                _isReloadingSequence = true;\n                _reloadSequenceStep = 1;\n                _ammoAtReloadStart = CurrentWeapon.CurrentAmmo;\n                GD.Print($\"[Player] Reload sequence started (R pressed) - ammo at start: {_ammoAtReloadStart} - press F next\");\n                // Start animation: Step 1 - Grab magazine from chest\n                StartReloadAnimPhase(ReloadAnimPhase.GrabMagazine, ReloadAnimGrabDuration);\n                // Play magazine out sound\n                PlayReloadMagOutSound();\n                EmitSignal(SignalName.ReloadSequenceProgress, 1, 3);\n                // Notify enemies that player has started reloading (vulnerable state)\n                EmitSignal(SignalName.ReloadStarted);\n            }\n            else if (_reloadSequenceStep == 2)\n            {\n                // Complete reload sequence - instant reload!\n                // Start animation: Step 3 - Pull bolt/charging handle (back and forth motion)\n                StartReloadAnimPhase(ReloadAnimPhase.PullBolt, ReloadAnimBoltPullDuration);\n                // Play bolt cycling sound\n                PlayM16BoltSound();\n                CompleteReloadSequence();\n            }\n        }\n\n        // Handle F key (reload_step action - second step)\n        if (Input.IsActionJustPressed(\"reload_step\"))\n        {\n            if (_reloadSequenceStep == 1)\n            {\n                // Continue to next step - set up chamber bullet\n                _reloadSequenceStep = 2;\n\n                // Set up bullet in chamber based on ammo at reload start\n                bool hadAmmoInMagazine = _ammoAtReloadStart > 0;\n                CurrentWeapon.StartReloadSequence(hadAmmoInMagazine);\n\n                GD.Print($\"[Player] Reload sequence step 2 (F pressed) - bullet in chamber: {hadAmmoInMagazine} - press R to complete\");\n                // Start animation: Step 2 - Insert magazine into rifle\n                StartReloadAnimPhase(ReloadAnimPhase.InsertMagazine, ReloadAnimInsertDuration);\n                // Play magazine in sound\n                PlayReloadMagInSound();\n                EmitSignal(SignalName.ReloadSequenceProgress, 2, 3);\n            }\n            else if (_isReloadingSequence)\n            {\n                // Wrong key pressed, reset sequence\n                GD.Print(\"[Player] Wrong key! Reload sequence reset (expected R)\");\n                // Restart animation from grab phase\n                StartReloadAnimPhase(ReloadAnimPhase.GrabMagazine, ReloadAnimGrabDuration);\n                ResetReloadSequence();\n            }\n        }\n    }\n\n    /// <summary>\n    /// Plays the magazine out sound (first reload step).\n    /// </summary>\n    private void PlayReloadMagOutSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_reload_mag_out\"))\n        {\n            audioManager.Call(\"play_reload_mag_out\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Plays the magazine in sound (second reload step).\n    /// </summary>\n    private void PlayReloadMagInSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_reload_mag_in\"))\n        {\n            audioManager.Call(\"play_reload_mag_in\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Plays the M16 bolt cycling sound (third reload step).\n    /// </summary>\n    private void PlayM16BoltSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_bolt\"))\n        {\n            audioManager.Call(\"play_m16_bolt\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Completes the reload sequence, instantly reloading the weapon.\n    /// </summary>\n    private void CompleteReloadSequence()\n    {\n        if (CurrentWeapon == null)\n        {\n            return;\n        }\n\n        // Perform instant reload\n        CurrentWeapon.InstantReload();\n\n        GD.Print(\"[Player] Reload sequence complete! Magazine refilled instantly.\");\n        EmitSignal(SignalName.ReloadSequenceProgress, 3, 3);\n        EmitSignal(SignalName.ReloadCompleted);\n\n        ResetReloadSequence();\n    }\n\n    /// <summary>\n    /// Resets the reload sequence to the beginning.\n    /// Also cancels the weapon's reload sequence state.\n    /// </summary>\n    private void ResetReloadSequence()\n    {\n        _reloadSequenceStep = 0;\n        _isReloadingSequence = false;\n        _ammoAtReloadStart = 0;\n\n        // Return arms to idle if reload animation was active\n        if (_reloadAnimPhase != ReloadAnimPhase.None)\n        {\n            StartReloadAnimPhase(ReloadAnimPhase.ReturnIdle, ReloadAnimReturnDuration);\n        }\n\n        // Cancel weapon's reload sequence state\n        CurrentWeapon?.CancelReloadSequence();\n    }\n\n    /// <summary>\n    /// Gets whether the player is currently in a reload sequence.\n    /// </summary>\n    public bool IsReloadingSequence => _isReloadingSequence;\n\n    /// <summary>\n    /// Gets the current reload sequence step (0-2).\n    /// </summary>\n    public int ReloadSequenceStep => _reloadSequenceStep;\n\n    /// <summary>\n    /// Fires a bullet towards the mouse cursor.\n    /// Uses weapon system if available, otherwise uses direct bullet spawning.\n    /// </summary>\n    private void Shoot()\n    {\n        // Calculate direction towards mouse cursor\n        Vector2 mousePos = GetGlobalMousePosition();\n        Vector2 shootDirection = (mousePos - GlobalPosition).Normalized();\n\n        // If we have a weapon equipped, use it\n        if (CurrentWeapon != null)\n        {\n            CurrentWeapon.Fire(shootDirection);\n            return;\n        }\n\n        // Otherwise use direct bullet spawning (original behavior)\n        SpawnBullet(shootDirection);\n    }\n\n    /// <summary>\n    /// Spawns a bullet directly without using the weapon system.\n    /// Preserves the original template behavior.\n    /// </summary>\n    /// <param name=\"direction\">Direction for the bullet to travel.</param>\n    private void SpawnBullet(Vector2 direction)\n    {\n        if (BulletScene == null)\n        {\n            return;\n        }\n\n        // Create bullet instance\n        var bullet = BulletScene.Instantiate<Node2D>();\n\n        // Set bullet position with offset in shoot direction\n        bullet.GlobalPosition = GlobalPosition + direction * BulletSpawnOffset;\n\n        // Set bullet direction\n        if (bullet.HasMethod(\"SetDirection\"))\n        {\n            bullet.Call(\"SetDirection\", direction);\n        }\n        else\n        {\n            bullet.Set(\"direction\", direction);\n        }\n\n        // Set shooter ID to prevent self-damage\n        if (bullet.HasMethod(\"SetShooterId\"))\n        {\n            bullet.Call(\"SetShooterId\", GetInstanceId());\n        }\n        else\n        {\n            bullet.Set(\"shooter_id\", GetInstanceId());\n        }\n\n        // Add bullet to the scene tree\n        GetTree().CurrentScene.AddChild(bullet);\n    }\n\n    /// <summary>\n    /// Last hit direction stored for blood effect spawning (Issue #350).\n    /// </summary>\n    private Vector2 _lastHitDirection = Vector2.Right;\n\n    /// <summary>\n    /// Last caliber data stored for blood effect scaling (Issue #350).\n    /// </summary>\n    private Godot.Resource? _lastCaliberData = null;\n\n    /// <summary>\n    /// Called when hit by a projectile via hit_area.gd.\n    /// This method name follows GDScript naming convention for cross-language compatibility\n    /// with the hit detection system that uses has_method(\"on_hit\") checks.\n    /// </summary>\n    public void on_hit()\n    {\n        on_hit_with_info(Vector2.Right, null);\n    }\n\n    /// <summary>\n    /// Called when hit by a projectile with extended hit information (Issue #350).\n    /// This method name follows GDScript naming convention for cross-language compatibility\n    /// with the hit detection system that uses has_method(\"on_hit_with_info\") checks.\n    /// </summary>\n    /// <param name=\"hitDirection\">Direction the bullet was traveling.</param>\n    /// <param name=\"caliberData\">Caliber resource for effect scaling (can be null).</param>\n    public void on_hit_with_info(Vector2 hitDirection, Godot.Resource? caliberData)\n    {\n        _lastHitDirection = hitDirection;\n        _lastCaliberData = caliberData;\n        TakeDamage(1);\n    }\n\n    /// <inheritdoc/>\n    public override void TakeDamage(float amount)\n    {\n        if (HealthComponent == null || !IsAlive)\n        {\n            return;\n        }\n\n        // Check invincibility mode (F6 toggle)\n        if (_invincibilityEnabled)\n        {\n            LogToFile(\"[Player] Hit blocked by invincibility mode (C#)\");\n            ShowHitFlash(); // Still show visual feedback for debugging\n            // Spawn blood effect for visual feedback even in invincibility mode (Issue #350)\n            SpawnBloodEffect(false);\n            return;\n        }\n\n        GD.Print($\"[Player] {Name}: Taking {amount} damage. Current health: {HealthComponent.CurrentHealth}\");\n\n        // Show hit flash effect\n        ShowHitFlash();\n\n        // Determine if this hit will be lethal before applying damage\n        bool willBeFatal = HealthComponent.CurrentHealth <= amount;\n\n        // Play appropriate hit sound and spawn blood effect (Issue #350)\n        if (willBeFatal)\n        {\n            PlayHitLethalSound();\n            SpawnBloodEffect(true);\n        }\n        else\n        {\n            PlayHitNonLethalSound();\n            SpawnBloodEffect(false);\n        }\n\n        base.TakeDamage(amount);\n    }\n\n    /// <summary>\n    /// Spawns blood effect at the player's position (Issue #350).\n    /// This makes blood effects appear when the player is hit, just like for enemies.\n    /// </summary>\n    /// <param name=\"isLethal\">Whether this was a lethal hit (affects effect scale).</param>\n    private void SpawnBloodEffect(bool isLethal)\n    {\n        var impactManager = GetNodeOrNull(\"/root/ImpactEffectsManager\");\n        if (impactManager != null && impactManager.HasMethod(\"spawn_blood_effect\"))\n        {\n            LogToFile($\"[Player] Spawning blood effect at {GlobalPosition}, dir={_lastHitDirection}, lethal={isLethal} (C#)\");\n            impactManager.Call(\"spawn_blood_effect\", GlobalPosition, _lastHitDirection, _lastCaliberData, isLethal);\n        }\n        else\n        {\n            LogToFile(\"[Player] WARNING: ImpactEffectsManager not found, blood effect not spawned (C#)\");\n        }\n    }\n\n    /// <summary>\n    /// Plays the lethal hit sound when player dies.\n    /// </summary>\n    private void PlayHitLethalSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_hit_lethal\"))\n        {\n            audioManager.Call(\"play_hit_lethal\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Plays the non-lethal hit sound when player is damaged but survives.\n    /// </summary>\n    private void PlayHitNonLethalSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_hit_non_lethal\"))\n        {\n            audioManager.Call(\"play_hit_non_lethal\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Shows a brief flash effect when hit.\n    /// </summary>\n    private async void ShowHitFlash()\n    {\n        if (_playerModel == null && _sprite == null)\n        {\n            return;\n        }\n\n        SetAllSpritesModulate(HitFlashColor);\n\n        await ToSignal(GetTree().CreateTimer(HitFlashDuration), \"timeout\");\n\n        // Restore color based on current health (if still alive)\n        if (HealthComponent != null && HealthComponent.IsAlive)\n        {\n            UpdateHealthVisual();\n        }\n    }\n\n    /// <inheritdoc/>\n    public override void OnDeath()\n    {\n        base.OnDeath();\n        // Handle player death\n        GD.Print(\"Player died!\");\n    }\n\n    /// <summary>\n    /// Equips a new weapon.\n    /// </summary>\n    /// <param name=\"weapon\">The weapon to equip.</param>\n    public void EquipWeapon(BaseWeapon weapon)\n    {\n        // Unequip current weapon if any\n        if (CurrentWeapon != null && CurrentWeapon.GetParent() == this)\n        {\n            RemoveChild(CurrentWeapon);\n        }\n\n        CurrentWeapon = weapon;\n\n        // Add weapon as child if not already in scene tree\n        if (CurrentWeapon.GetParent() == null)\n        {\n            AddChild(CurrentWeapon);\n        }\n    }\n\n    /// <summary>\n    /// Unequips the current weapon.\n    /// </summary>\n    public void UnequipWeapon()\n    {\n        if (CurrentWeapon != null && CurrentWeapon.GetParent() == this)\n        {\n            RemoveChild(CurrentWeapon);\n        }\n        CurrentWeapon = null;\n    }\n\n    #region Sniper Scope System\n\n    /// <summary>\n    /// Handles sniper scope input when the SniperRifle is equipped.\n    /// RMB activates the scope for aiming beyond the viewport.\n    /// Mouse wheel adjusts zoom distance while scoped.\n    /// Returns true if the sniper scope consumed the RMB input.\n    /// </summary>\n    private bool HandleSniperScopeInput()\n    {\n        // Only handle scope when a SniperRifle is the current weapon\n        var sniperRifle = CurrentWeapon as SniperRifle;\n        if (sniperRifle == null)\n        {\n            return false;\n        }\n\n        // Handle RMB press to activate scope\n        if (Input.IsActionJustPressed(\"grenade_throw\"))\n        {\n            // Only activate scope if not already in a grenade action\n            if (_grenadeState == GrenadeState.Idle && !Input.IsActionPressed(\"grenade_prepare\"))\n            {\n                sniperRifle.ActivateScope();\n                return true;\n            }\n        }\n\n        // Handle RMB release to deactivate scope\n        if (Input.IsActionJustReleased(\"grenade_throw\") && sniperRifle.IsScopeActive)\n        {\n            sniperRifle.DeactivateScope();\n            return true;\n        }\n\n        // While scope is active, consume RMB input to prevent grenade handling\n        if (sniperRifle.IsScopeActive)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    /// <summary>\n    /// Handles mouse wheel input for scope zoom when sniper scope is active.\n    /// This is called from _UnhandledInput to capture wheel events.\n    /// </summary>\n    public override void _UnhandledInput(InputEvent @event)\n    {\n        base._UnhandledInput(@event);\n\n        var sniperRifle = CurrentWeapon as SniperRifle;\n        if (sniperRifle == null || !sniperRifle.IsScopeActive)\n        {\n            return;\n        }\n\n        if (@event is InputEventMouseButton mouseButton)\n        {\n            if (mouseButton.Pressed)\n            {\n                if (mouseButton.ButtonIndex == MouseButton.WheelUp)\n                {\n                    sniperRifle.AdjustScopeZoom(1.0f);\n                    GetViewport().SetInputAsHandled();\n                }\n                else if (mouseButton.ButtonIndex == MouseButton.WheelDown)\n                {\n                    sniperRifle.AdjustScopeZoom(-1.0f);\n                    GetViewport().SetInputAsHandled();\n                }\n            }\n        }\n    }\n\n    #endregion\n\n    #region Grenade System\n\n    /// <summary>\n    /// Handle grenade input with either simple or complex mechanic.\n    /// Simple mode (default): Hold RMB to aim with trajectory preview, release to throw.\n    /// Complex mode (experimental): G + RMB drag right ‚Üí hold G+RMB ‚Üí release G ‚Üí drag and release RMB.\n    /// </summary>\n    private void HandleGrenadeInput()\n    {\n        // Handle throw rotation animation\n        HandleThrowRotationAnimation((float)GetPhysicsProcessDeltaTime());\n\n        // Check for active grenade explosion (explodes in hand after 4 seconds)\n        if (_activeGrenade != null && !IsInstanceValid(_activeGrenade))\n        {\n            // Grenade exploded while held - return arms to idle\n            StartGrenadeAnimPhase(GrenadeAnimPhase.ReturnIdle, AnimReturnDuration);\n            ResetGrenadeState();\n            return;\n        }\n\n        // Check if complex grenade throwing is enabled (experimental setting)\n        var experimentalSettings = GetNodeOrNull(\"/root/ExperimentalSettings\");\n        bool useComplexThrowing = false;\n        if (experimentalSettings != null && experimentalSettings.HasMethod(\"is_complex_grenade_throwing\"))\n        {\n            useComplexThrowing = (bool)experimentalSettings.Call(\"is_complex_grenade_throwing\");\n        }\n\n        // Debug log once per state change to track mode (logged once when grenade action starts)\n        if (_grenadeState == GrenadeState.Idle && (Input.IsActionJustPressed(\"grenade_throw\") || Input.IsActionJustPressed(\"grenade_prepare\")))\n        {\n            LogToFile($\"[Player.Grenade] Mode check: complex={useComplexThrowing}, settings_node={experimentalSettings != null}\");\n        }\n\n        if (useComplexThrowing)\n        {\n            // Complex 3-step throwing mechanic\n            switch (_grenadeState)\n            {\n                case GrenadeState.Idle:\n                    HandleGrenadeIdleState();\n                    break;\n                case GrenadeState.TimerStarted:\n                    HandleGrenadeTimerStartedState();\n                    break;\n                case GrenadeState.WaitingForGRelease:\n                    HandleGrenadeWaitingForGReleaseState();\n                    break;\n                case GrenadeState.Aiming:\n                    HandleGrenadeAimingState();\n                    break;\n            }\n        }\n        else\n        {\n            // Simple trajectory aiming mode - uses same pin-pull mechanic (G+RMB drag)\n            // but replaces mouse-velocity throwing with trajectory-to-cursor aiming\n            switch (_grenadeState)\n            {\n                case GrenadeState.Idle:\n                    // Use same G+RMB drag mechanic as complex mode for pin pull (Step 1)\n                    HandleGrenadeIdleState();\n                    break;\n                case GrenadeState.TimerStarted:\n                    // After pin is pulled, RMB starts trajectory aiming (instead of Step 2)\n                    HandleSimpleGrenadeTimerStartedState();\n                    break;\n                case GrenadeState.SimpleAiming:\n                    // RMB held: show trajectory preview, release to throw to cursor\n                    HandleSimpleGrenadeAimingState();\n                    break;\n                default:\n                    // If we're in a complex-mode state but simple mode is now enabled,\n                    // reset to allow starting fresh (handles mode switch mid-throw)\n                    if (_grenadeState == GrenadeState.WaitingForGRelease ||\n                        _grenadeState == GrenadeState.Aiming)\n                    {\n                        LogToFile($\"[Player.Grenade] Mode mismatch: resetting from complex state {_grenadeState} to IDLE\");\n                        if (_activeGrenade != null && IsInstanceValid(_activeGrenade))\n                        {\n                            DropGrenadeAtFeet();\n                        }\n                        else\n                        {\n                            ResetGrenadeState();\n                        }\n                    }\n                    break;\n            }\n        }\n    }\n\n    /// <summary>\n    /// Handle grenade input in Idle state.\n    /// Waiting for G + RMB drag right to start timer (Step 1).\n    /// </summary>\n    private void HandleGrenadeIdleState()\n    {\n        // Start grab animation when G is first pressed (check before the is_action_pressed block)\n        if (Input.IsActionJustPressed(\"grenade_prepare\") && _currentGrenades > 0)\n        {\n            StartGrenadeAnimPhase(GrenadeAnimPhase.GrabGrenade, AnimGrabDuration);\n            LogToFile(\"[Player.Grenade] G pressed - starting grab animation\");\n        }\n\n        // Check if G key is held and player has grenades\n        if (Input.IsActionPressed(\"grenade_prepare\") && _currentGrenades > 0)\n        {\n            // Check if RMB was just pressed (start of drag)\n            if (Input.IsActionJustPressed(\"grenade_throw\"))\n            {\n                _grenadeDragStart = GetGlobalMousePosition();\n                _grenadeDragActive = true;\n                LogToFile($\"[Player.Grenade] Step 1 started: G held, RMB pressed at {_grenadeDragStart}\");\n            }\n\n            // Check if RMB was released (end of drag)\n            if (_grenadeDragActive && Input.IsActionJustReleased(\"grenade_throw\"))\n            {\n                Vector2 dragEnd = GetGlobalMousePosition();\n                Vector2 dragVector = dragEnd - _grenadeDragStart;\n\n                // Check if drag was to the right and long enough\n                if (dragVector.X > MinDragDistanceForStep1)\n                {\n                    StartGrenadeTimer();\n                    // Start pull pin animation\n                    StartGrenadeAnimPhase(GrenadeAnimPhase.PullPin, AnimPinDuration);\n                    LogToFile($\"[Player.Grenade] Step 1 complete! Drag: {dragVector}\");\n                }\n                else\n                {\n                    LogToFile($\"[Player.Grenade] Step 1 failed: drag not far enough right ({dragVector.X} < {MinDragDistanceForStep1})\");\n                }\n                _grenadeDragActive = false;\n            }\n        }\n        else\n        {\n            _grenadeDragActive = false;\n            // If G was released and we were in grab animation, return to idle\n            if (_grenadeAnimPhase == GrenadeAnimPhase.GrabGrenade)\n            {\n                StartGrenadeAnimPhase(GrenadeAnimPhase.ReturnIdle, AnimReturnDuration);\n            }\n        }\n    }\n\n    /// <summary>\n    /// Handle grenade input in TimerStarted state.\n    /// Waiting for RMB to be pressed while G is held (Step 2 part 1).\n    /// </summary>\n    private void HandleGrenadeTimerStartedState()\n    {\n        // If G is released, drop grenade at feet\n        if (!Input.IsActionPressed(\"grenade_prepare\"))\n        {\n            LogToFile(\"[Player.Grenade] G released - dropping grenade at feet\");\n            DropGrenadeAtFeet();\n            return;\n        }\n\n        // Check if RMB is pressed to enter WaitingForGRelease state\n        if (Input.IsActionJustPressed(\"grenade_throw\"))\n        {\n            _grenadeState = GrenadeState.WaitingForGRelease;\n            // Start hands approach animation\n            StartGrenadeAnimPhase(GrenadeAnimPhase.HandsApproach, AnimApproachDuration);\n            LogToFile(\"[Player.Grenade] Step 2 part 1: G+RMB held - now release G to ready the throw\");\n        }\n    }\n\n    /// <summary>\n    /// Handle grenade input in WaitingForGRelease state.\n    /// G+RMB are both held, waiting for G to be released (Step 2 part 2).\n    /// </summary>\n    private void HandleGrenadeWaitingForGReleaseState()\n    {\n        // If RMB is released before G, go back to TimerStarted\n        if (!Input.IsActionPressed(\"grenade_throw\"))\n        {\n            _grenadeState = GrenadeState.TimerStarted;\n            LogToFile(\"[Player.Grenade] RMB released before G - back to waiting for RMB\");\n            return;\n        }\n\n        // If G is released while RMB is still held, enter Aiming state\n        if (!Input.IsActionPressed(\"grenade_prepare\"))\n        {\n            _grenadeState = GrenadeState.Aiming;\n            _grenadeDragStart = GetGlobalMousePosition();\n            _prevMousePos = _grenadeDragStart;\n            // Initialize velocity tracking for realistic throwing\n            _mouseVelocityHistory.Clear();\n            _currentMouseVelocity = Vector2.Zero;\n            _totalSwingDistance = 0.0f;\n            _prevFrameTime = Time.GetTicksMsec() / 1000.0;\n            // Start transfer animation (grenade to throwing hand)\n            StartGrenadeAnimPhase(GrenadeAnimPhase.Transfer, AnimTransferDuration);\n            LogToFile(\"[Player.Grenade] Step 2 complete: G released, RMB held - now aiming (velocity-based throwing enabled)\");\n        }\n    }\n\n    /// <summary>\n    /// Handle grenade input in Aiming state.\n    /// Only RMB is held (G was released), waiting for drag and release to throw.\n    /// </summary>\n    private void HandleGrenadeAimingState()\n    {\n        // In this state, G is already released (that's how we got here)\n        // We only care about RMB\n\n        // Transition from transfer to wind-up after transfer completes\n        if (_grenadeAnimPhase == GrenadeAnimPhase.Transfer && _grenadeAnimTimer <= 0)\n        {\n            StartGrenadeAnimPhase(GrenadeAnimPhase.WindUp, 0); // Wind-up is continuous\n            LogToFile(\"[Player.Grenade.Anim] Entered wind-up phase\");\n        }\n\n        // Update wind-up intensity while in wind-up phase\n        if (_grenadeAnimPhase == GrenadeAnimPhase.WindUp)\n        {\n            UpdateWindUpIntensity();\n        }\n\n        // Request redraw for debug trajectory visualization\n        if (_debugModeEnabled)\n        {\n            QueueRedraw();\n        }\n\n        // If RMB is released, throw the grenade\n        if (Input.IsActionJustReleased(\"grenade_throw\"))\n        {\n            // Start throw animation\n            StartGrenadeAnimPhase(GrenadeAnimPhase.Throw, AnimThrowDuration);\n            Vector2 dragEnd = GetGlobalMousePosition();\n            ThrowGrenade(dragEnd);\n        }\n    }\n\n    #region Simple Grenade Throwing Mode\n\n    /// <summary>\n    /// Handle TIMER_STARTED state for simple grenade throwing mode.\n    /// After pin is pulled (G+RMB drag), wait for RMB to start trajectory aiming.\n    /// If G is released, drop grenade at feet.\n    /// </summary>\n    private void HandleSimpleGrenadeTimerStartedState()\n    {\n        // Make grenade follow player while G is held\n        if (_activeGrenade != null && IsInstanceValid(_activeGrenade))\n        {\n            _activeGrenade.GlobalPosition = GlobalPosition;\n        }\n\n        // If G is released, drop grenade at feet\n        if (!Input.IsActionPressed(\"grenade_prepare\"))\n        {\n            LogToFile(\"[Player.Grenade.Simple] G released - dropping grenade at feet\");\n            DropGrenadeAtFeet();\n            return;\n        }\n\n        // Check if RMB is pressed to enter SimpleAiming state\n        if (Input.IsActionJustPressed(\"grenade_throw\"))\n        {\n            _grenadeState = GrenadeState.SimpleAiming;\n            _isPreparingGrenade = true;\n            // Store initial mouse position for aiming\n            _aimDragStart = GetGlobalMousePosition();\n            // Start hands approach animation\n            StartGrenadeAnimPhase(GrenadeAnimPhase.HandsApproach, AnimApproachDuration);\n            LogToFile(\"[Player.Grenade.Simple] RMB pressed after pin pull - starting trajectory aiming\");\n        }\n    }\n\n    /// <summary>\n    /// Handle SIMPLE_AIMING state: RMB held, showing trajectory preview.\n    /// Cursor position = landing point. Release RMB to throw.\n    /// G can be released while RMB is held - grenade stays ready.\n    /// </summary>\n    private void HandleSimpleGrenadeAimingState()\n    {\n        // Request redraw for trajectory visualization (always show in simple mode)\n        QueueRedraw();\n\n        // Make grenade follow player\n        if (_activeGrenade != null && IsInstanceValid(_activeGrenade))\n        {\n            _activeGrenade.GlobalPosition = GlobalPosition;\n        }\n\n        // Update arm animation based on wind-up\n        UpdateSimpleWindUpAnimation();\n\n        // If animation phases need to transition\n        if (_grenadeAnimPhase == GrenadeAnimPhase.HandsApproach && _grenadeAnimTimer <= 0)\n        {\n            _grenadeAnimPhase = GrenadeAnimPhase.WindUp;\n        }\n\n        // Check for RMB release - throw the grenade!\n        if (Input.IsActionJustReleased(\"grenade_throw\"))\n        {\n            ThrowSimpleGrenade();\n        }\n\n        // Check for cancellation (if grenade was somehow destroyed)\n        if (_activeGrenade == null || !IsInstanceValid(_activeGrenade))\n        {\n            ResetGrenadeState();\n            StartGrenadeAnimPhase(GrenadeAnimPhase.ReturnIdle, AnimReturnDuration);\n        }\n    }\n\n    /// <summary>\n    /// Update wind-up animation based on distance from player to cursor.\n    /// </summary>\n    private void UpdateSimpleWindUpAnimation()\n    {\n        Vector2 currentMouse = GetGlobalMousePosition();\n        float distance = GlobalPosition.DistanceTo(currentMouse);\n\n        // Calculate wind-up intensity based on distance (0-500 pixels = 0-1 intensity)\n        const float maxDistance = 500.0f;\n        _windUpIntensity = Mathf.Clamp(distance / maxDistance, 0.0f, 1.0f);\n    }\n\n    /// <summary>\n    /// Throw the grenade in simple mode.\n    /// Direction and distance based on cursor position relative to player.\n    /// </summary>\n    private void ThrowSimpleGrenade()\n    {\n        if (_activeGrenade == null || !IsInstanceValid(_activeGrenade))\n        {\n            LogToFile(\"[Player.Grenade.Simple] Cannot throw: no active grenade\");\n            ResetGrenadeState();\n            return;\n        }\n\n        Vector2 targetPos = GetGlobalMousePosition();\n        Vector2 toTarget = targetPos - GlobalPosition;\n\n        // Calculate throw direction\n        Vector2 throwDirection = toTarget.Length() > 10.0f ? toTarget.Normalized() : new Vector2(1, 0);\n\n        // FIX for issue #398: Account for spawn offset in distance calculation\n        // The grenade starts 60 pixels ahead of the player in the throw direction,\n        // so we need to calculate distance from spawn position to target, not from player to target\n        const float spawnOffset = 60.0f;\n        Vector2 spawnPosition = GlobalPosition + throwDirection * spawnOffset;\n        float throwDistance = (targetPos - spawnPosition).Length();\n\n        // Ensure minimum throw distance\n        if (throwDistance < 10.0f) throwDistance = 10.0f;\n\n        // Get grenade's actual physics properties for accurate calculation\n        // FIX for issue #398: Use actual grenade properties instead of hardcoded values\n        float groundFriction = 300.0f; // Default\n        float maxThrowSpeed = 850.0f;  // Default\n        if (_activeGrenade.Get(\"ground_friction\").VariantType != Variant.Type.Nil)\n        {\n            groundFriction = (float)_activeGrenade.Get(\"ground_friction\");\n        }\n        if (_activeGrenade.Get(\"max_throw_speed\").VariantType != Variant.Type.Nil)\n        {\n            maxThrowSpeed = (float)_activeGrenade.Get(\"max_throw_speed\");\n        }\n\n        // Calculate throw speed needed to reach target (using physics)\n        // Distance = v^2 / (2 * friction) ‚Üí v = sqrt(2 * friction * distance)\n        // FIX for issue #428: Apply 16% compensation factor to account for:\n        // 1. Discrete time integration error from Godot's 60 FPS Euler integration (~0.8%)\n        // 2. Additional physics damping effects in Godot's RigidBody2D (~12.5%)\n        // Empirically tested: grenades travel ~86% of calculated distance without compensation.\n        // Factor of 1.16 (‚âà 1/0.86) brings actual landing position to match target cursor position.\n        const float physicsCompensationFactor = 1.16f;\n        float requiredSpeed = Mathf.Sqrt(2.0f * groundFriction * throwDistance * physicsCompensationFactor);\n\n        // Clamp to grenade's max throw speed\n        float throwSpeed = Mathf.Min(requiredSpeed, maxThrowSpeed);\n\n        // Calculate actual landing distance with clamped speed (for logging)\n        float actualDistance = (throwSpeed * throwSpeed) / (2.0f * groundFriction);\n\n        LogToFile($\"[Player.Grenade.Simple] Throwing! Target: {targetPos}, Distance: {actualDistance:F1}, Speed: {throwSpeed:F1}, Friction: {groundFriction:F1}\");\n\n        // Rotate player to face throw direction\n        RotatePlayerForThrow(throwDirection);\n\n        // Calculate safe spawn position with wall check\n        Vector2 intendedSpawnPosition = GlobalPosition + throwDirection * spawnOffset;\n        Vector2 safeSpawnPosition = GetSafeGrenadeSpawnPosition(GlobalPosition, intendedSpawnPosition, throwDirection);\n\n        // FIX for issue #398: Set grenade position to spawn point BEFORE throwing\n        // The grenade follows the player during aiming at GlobalPosition,\n        // but the distance calculation assumes it starts from spawnPosition (60px ahead).\n        // Without this fix, the grenade lands ~60px short of the target.\n        _activeGrenade.GlobalPosition = safeSpawnPosition;\n\n        // FIX for Issue #432: Mark grenade as thrown BEFORE unfreezing to avoid race condition.\n        // If MarkAsThrown() is called after unfreezing, the BodyEntered signal could fire\n        // before IsThrown is set, causing impact detection to fail.\n        var grenadeTimer = _activeGrenade.GetNodeOrNull<GrenadeTimer>(\"GrenadeTimer\");\n        if (grenadeTimer != null)\n        {\n            grenadeTimer.MarkAsThrown();\n        }\n\n        // Unfreeze and throw the grenade\n        _activeGrenade.Freeze = false;\n\n        // FIX for Issue #432: ALWAYS set velocity directly in C# as primary mechanism.\n        // GDScript methods called via Call() may silently fail in exported builds,\n        // causing grenades to fly infinitely (no velocity set) or not move at all.\n        // By setting velocity directly in C#, we guarantee the grenade moves correctly.\n        _activeGrenade.LinearVelocity = throwDirection * throwSpeed;\n        _activeGrenade.Rotation = throwDirection.Angle();\n\n        LogToFile($\"[Player.Grenade.Simple] C# set velocity directly: dir={throwDirection}, speed={throwSpeed:F1}, spawn={safeSpawnPosition}\");\n\n        // Also try to call GDScript method for any additional setup it might do\n        // (visual effects, sound, etc.), but the velocity is already set above\n        if (_activeGrenade.HasMethod(\"throw_grenade_simple\"))\n        {\n            _activeGrenade.Call(\"throw_grenade_simple\", throwDirection, throwSpeed);\n        }\n\n        // Start throw animation\n        StartGrenadeAnimPhase(GrenadeAnimPhase.Throw, AnimThrowDuration);\n\n        // Emit signal and play sound\n        EmitSignal(SignalName.GrenadeThrown);\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_grenade_throw\"))\n        {\n            audioManager.Call(\"play_grenade_throw\", GlobalPosition);\n        }\n\n        LogToFile(\"[Player.Grenade.Simple] Grenade thrown!\");\n\n        // Reset state\n        ResetGrenadeState();\n    }\n\n    #endregion\n\n    /// <summary>\n    /// Start the grenade timer (step 1 complete - pin pulled).\n    /// Creates the grenade instance and starts its 4-second fuse.\n    /// </summary>\n    private void StartGrenadeTimer()\n    {\n        if (_currentGrenades <= 0)\n        {\n            LogToFile(\"[Player.Grenade] Cannot start timer: no grenades\");\n            return;\n        }\n\n        if (GrenadeScene == null)\n        {\n            LogToFile(\"[Player.Grenade] Cannot start timer: GrenadeScene is null\");\n            return;\n        }\n\n        // Create grenade instance (held by player)\n        _activeGrenade = GrenadeScene.Instantiate<RigidBody2D>();\n        if (_activeGrenade == null)\n        {\n            LogToFile(\"[Player.Grenade] Failed to instantiate grenade scene\");\n            return;\n        }\n\n        // Add grenade to scene first (must be in tree before setting GlobalPosition)\n        GetTree().CurrentScene.AddChild(_activeGrenade);\n\n        // FIX for Issue #432 (activation position bug): Freeze the grenade IMMEDIATELY after creation.\n        // This MUST happen before setting position to prevent physics engine interference.\n        // Root cause: GDScript _ready() sets freeze=true, but GDScript doesn't run in exports!\n        // Without this fix, the physics engine can move the unfrozen grenade while player moves,\n        // causing the grenade to be thrown from the activation position instead of player's current position.\n        // See commit 60f7cae for original fix and docs/case-studies/issue-183/ for detailed analysis.\n        _activeGrenade.FreezeMode = RigidBody2D.FreezeModeEnum.Kinematic;\n        _activeGrenade.Freeze = true;\n\n        // Set position AFTER AddChild and AFTER freezing (GlobalPosition only works when node is in the scene tree)\n        _activeGrenade.GlobalPosition = GlobalPosition;\n\n        // FIX for Issue #432: Add C# GrenadeTimer component for reliable explosion handling.\n        // GDScript methods called via Call() may silently fail in exports, causing grenades\n        // to fly infinitely without exploding. This C# component provides a reliable fallback.\n        AddGrenadeTimerComponent(_activeGrenade);\n\n        // Activate the grenade timer (starts 4s countdown)\n        // Try GDScript first, but C# GrenadeTimer will handle it if this fails\n        if (_activeGrenade.HasMethod(\"activate_timer\"))\n        {\n            _activeGrenade.Call(\"activate_timer\");\n        }\n        // Also activate C# timer as reliable fallback\n        var grenadeTimer = _activeGrenade.GetNodeOrNull<GrenadeTimer>(\"GrenadeTimer\");\n        if (grenadeTimer != null)\n        {\n            grenadeTimer.ActivateTimer();\n        }\n\n        _grenadeState = GrenadeState.TimerStarted;\n\n        // Decrement grenade count now (pin is pulled) - but not on tutorial level (infinite)\n        if (!_isTutorialLevel)\n        {\n            _currentGrenades--;\n        }\n        EmitSignal(SignalName.GrenadeChanged, _currentGrenades, MaxGrenades);\n\n        // Play grenade prepare sound\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_grenade_prepare\"))\n        {\n            audioManager.Call(\"play_grenade_prepare\", GlobalPosition);\n        }\n\n        LogToFile($\"[Player.Grenade] Timer started, grenade created at {GlobalPosition}\");\n    }\n\n    /// <summary>\n    /// Add C# GrenadeTimer component to grenade for reliable explosion handling.\n    /// FIX for Issue #432: GDScript methods called via Call() may silently fail in exports.\n    /// </summary>\n    private void AddGrenadeTimerComponent(RigidBody2D grenade)\n    {\n        // Determine grenade type from scene name\n        var grenadeType = GrenadeTimer.GrenadeType.Flashbang;\n        var scenePath = grenade.SceneFilePath;\n        if (scenePath.Contains(\"Frag\", StringComparison.OrdinalIgnoreCase))\n        {\n            grenadeType = GrenadeTimer.GrenadeType.Frag;\n        }\n\n        // Create and configure the GrenadeTimer component\n        var timer = new GrenadeTimer();\n        timer.Name = \"GrenadeTimer\";\n        timer.Type = grenadeType;\n\n        // Copy relevant properties from grenade (if they exist as exported properties)\n        if (grenade.HasMeta(\"fuse_time\") || grenade.Get(\"fuse_time\").VariantType != Variant.Type.Nil)\n        {\n            timer.FuseTime = (float)grenade.Get(\"fuse_time\");\n        }\n        if (grenade.HasMeta(\"effect_radius\") || grenade.Get(\"effect_radius\").VariantType != Variant.Type.Nil)\n        {\n            timer.EffectRadius = (float)grenade.Get(\"effect_radius\");\n        }\n        if (grenade.HasMeta(\"explosion_damage\") || grenade.Get(\"explosion_damage\").VariantType != Variant.Type.Nil)\n        {\n            timer.ExplosionDamage = (int)grenade.Get(\"explosion_damage\");\n        }\n        if (grenade.HasMeta(\"blindness_duration\") || grenade.Get(\"blindness_duration\").VariantType != Variant.Type.Nil)\n        {\n            timer.BlindnessDuration = (float)grenade.Get(\"blindness_duration\");\n        }\n        if (grenade.HasMeta(\"stun_duration\") || grenade.Get(\"stun_duration\").VariantType != Variant.Type.Nil)\n        {\n            timer.StunDuration = (float)grenade.Get(\"stun_duration\");\n        }\n        // FIX for Issue #432: Copy ground_friction for C# friction handling\n        // GDScript _physics_process() may not run in exports, so we need C# to apply friction\n        if (grenade.HasMeta(\"ground_friction\") || grenade.Get(\"ground_friction\").VariantType != Variant.Type.Nil)\n        {\n            timer.GroundFriction = (float)grenade.Get(\"ground_friction\");\n        }\n\n        // FIX for Issue #432: Apply type-based defaults BEFORE adding to scene.\n        // GDScript Get() calls may fail silently in exported builds, leaving us with\n        // incorrect values (e.g., Frag grenade using Flashbang's 400 radius instead of 225).\n        timer.SetTypeBasedDefaults();\n\n        // Add the timer component to the grenade\n        grenade.AddChild(timer);\n        LogToFile($\"[Player.Grenade] Added GrenadeTimer component (type: {grenadeType})\");\n    }\n\n    /// <summary>\n    /// Drop the grenade at player's feet (when G is released before throwing).\n    /// </summary>\n    private void DropGrenadeAtFeet()\n    {\n        if (_activeGrenade != null && IsInstanceValid(_activeGrenade))\n        {\n            // Set position to current player position before unfreezing\n            _activeGrenade.GlobalPosition = GlobalPosition;\n            // Unfreeze the grenade so physics works and it can explode\n            _activeGrenade.Freeze = false;\n            // The grenade stays where it is (at player's feet)\n            LogToFile($\"[Player.Grenade] Grenade dropped at feet at {_activeGrenade.GlobalPosition} (unfrozen)\");\n        }\n        // Start return animation\n        StartGrenadeAnimPhase(GrenadeAnimPhase.ReturnIdle, AnimReturnDuration);\n        ResetGrenadeState();\n    }\n\n    /// <summary>\n    /// Reset grenade state to idle.\n    /// </summary>\n    private void ResetGrenadeState()\n    {\n        _grenadeState = GrenadeState.Idle;\n        _grenadeDragActive = false;\n        _grenadeDragStart = Vector2.Zero;\n        // Don't null out _activeGrenade - it's now an independent object in the scene\n        _activeGrenade = null;\n        // Reset wind-up intensity\n        _windUpIntensity = 0.0f;\n        // Reset velocity tracking for next throw\n        _mouseVelocityHistory.Clear();\n        _currentMouseVelocity = Vector2.Zero;\n        _totalSwingDistance = 0.0f;\n        LogToFile(\"[Player.Grenade] State reset to IDLE\");\n    }\n\n    /// <summary>\n    /// Sensitivity multiplier for throw distance calculation.\n    /// Higher value = farther throw for same drag distance.\n    /// Must match the value used in debug visualization.\n    /// </summary>\n    private const float ThrowSensitivityMultiplier = 9.0f;\n\n    /// <summary>\n    /// Throw the grenade using realistic velocity-based physics.\n    /// The throw velocity is determined by mouse velocity at release moment, not drag distance.\n    /// FIX for issue #313: Direction is now determined by MOUSE VELOCITY (how user moves the mouse)\n    /// with snapping to 4 cardinal directions to compensate for imprecise human mouse movement.\n    /// </summary>\n    /// <param name=\"dragEnd\">The end position of the drag (used for direction fallback).</param>\n    private void ThrowGrenade(Vector2 dragEnd)\n    {\n        if (_activeGrenade == null || !IsInstanceValid(_activeGrenade))\n        {\n            LogToFile(\"[Player.Grenade] Cannot throw: no active grenade\");\n            ResetGrenadeState();\n            return;\n        }\n\n        // Get the mouse velocity at moment of release (for determining throw speed AND direction)\n        Vector2 releaseVelocity = _currentMouseVelocity;\n        float velocityMagnitude = releaseVelocity.Length();\n\n        // FIX for issue #313: Use MOUSE VELOCITY DIRECTION (how the mouse is MOVING)\n        // User requirement: grenade flies in the direction the mouse is moving at release\n        // NOT toward where the mouse cursor is positioned\n        // Example: If user moves mouse DOWN, grenade flies DOWN (regardless of where cursor is)\n        Vector2 throwDirection;\n\n        if (velocityMagnitude > 10.0f)\n        {\n            // Primary direction: the direction the mouse is MOVING (velocity direction)\n            // FIX for issue #313 v4: Snap to 8 directions (4 cardinal + 4 diagonal)\n            // This compensates for imprecise human mouse movement while allowing diagonal throws\n            Vector2 rawDirection = releaseVelocity.Normalized();\n            throwDirection = SnapToOctantDirection(rawDirection);\n            LogToFile($\"[Player.Grenade] Raw direction: {rawDirection}, Snapped direction: {throwDirection}\");\n        }\n        else\n        {\n            // Fallback when mouse is not moving - use player-to-mouse as fallback direction\n            // FIX for issue #313 v4: Also snap fallback to 8 directions\n            Vector2 playerToMouse = dragEnd - GlobalPosition;\n            if (playerToMouse.Length() > 10.0f)\n            {\n                throwDirection = SnapToOctantDirection(playerToMouse.Normalized());\n            }\n            else\n            {\n                throwDirection = new Vector2(1, 0);  // Default direction (right)\n            }\n            // FIX for issue #313 v4: When velocity is 0, use a minimum throw speed\n            // This prevents grenade from getting \"stuck\" when user stops mouse before release\n            float minFallbackVelocity = 2000.0f;  // Minimum velocity to ensure grenade travels\n            velocityMagnitude = minFallbackVelocity;\n            LogToFile($\"[Player.Grenade] Fallback mode: Using minimum velocity {minFallbackVelocity:F1} px/s\");\n        }\n\n        LogToFile($\"[Player.Grenade] Throwing in mouse velocity direction! Direction: {throwDirection}, Mouse velocity: {velocityMagnitude:F1} px/s, Swing: {_totalSwingDistance:F1}\");\n\n        // Rotate player to face throw direction (prevents grenade hitting player when throwing upward)\n        RotatePlayerForThrow(throwDirection);\n\n        // Calculate intended spawn position (60px in front of player in throw direction)\n        float spawnOffset = 60.0f;\n        Vector2 intendedSpawnPosition = GlobalPosition + throwDirection * spawnOffset;\n\n        // FIXED: Raycast check to prevent spawning grenade behind/inside walls\n        // This fixes grenades passing through walls when thrown at close range (\"–≤ —É–ø–æ—Ä\")\n        Vector2 spawnPosition = GetSafeGrenadeSpawnPosition(GlobalPosition, intendedSpawnPosition, throwDirection);\n        _activeGrenade.GlobalPosition = spawnPosition;\n\n        // FIX for Issue #432: ALWAYS set velocity directly in C# as primary mechanism.\n        // GDScript methods called via Call() may silently fail in exported builds.\n        // Calculate throw speed using the same formula as GDScript\n        float multiplier = 0.5f;\n        float minSwing = 80.0f;\n        float maxSpeed = 850.0f;\n        float swingTransfer = Mathf.Clamp(_totalSwingDistance / minSwing, 0.0f, 0.65f);\n        float finalSpeed = Mathf.Min(velocityMagnitude * multiplier * (0.35f + swingTransfer), maxSpeed);\n\n        // FIX for Issue #432: Mark grenade as thrown BEFORE unfreezing to avoid race condition.\n        // If MarkAsThrown() is called after unfreezing, the BodyEntered signal could fire\n        // before IsThrown is set, causing impact detection to fail.\n        var grenadeTimer = _activeGrenade.GetNodeOrNull<GrenadeTimer>(\"GrenadeTimer\");\n        if (grenadeTimer != null)\n        {\n            grenadeTimer.MarkAsThrown();\n        }\n\n        // Unfreeze and set velocity directly\n        _activeGrenade.Freeze = false;\n        _activeGrenade.LinearVelocity = throwDirection * finalSpeed;\n        _activeGrenade.Rotation = throwDirection.Angle();\n\n        LogToFile($\"[Player.Grenade] C# set velocity directly: dir={throwDirection}, speed={finalSpeed:F1}, spawn={spawnPosition}\");\n\n        // Also try to call GDScript method for any additional setup\n        if (_activeGrenade.HasMethod(\"throw_grenade_with_direction\"))\n        {\n            _activeGrenade.Call(\"throw_grenade_with_direction\", throwDirection, velocityMagnitude, _totalSwingDistance);\n        }\n        else if (_activeGrenade.HasMethod(\"throw_grenade_velocity_based\"))\n        {\n            Vector2 directionalVelocity = throwDirection * velocityMagnitude;\n            _activeGrenade.Call(\"throw_grenade_velocity_based\", directionalVelocity, _totalSwingDistance);\n        }\n        else if (_activeGrenade.HasMethod(\"throw_grenade\"))\n        {\n            float legacyDistance = velocityMagnitude * 0.5f;\n            _activeGrenade.Call(\"throw_grenade\", throwDirection, legacyDistance);\n        }\n\n        // Emit signal\n        EmitSignal(SignalName.GrenadeThrown);\n\n        // Play grenade throw sound\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_grenade_throw\"))\n        {\n            audioManager.Call(\"play_grenade_throw\", GlobalPosition);\n        }\n\n        LogToFile($\"[Player.Grenade] Thrown! Velocity: {velocityMagnitude:F1}, Swing: {_totalSwingDistance:F1}\");\n\n        // Reset state (grenade is now independent)\n        ResetGrenadeState();\n    }\n\n    /// <summary>\n    /// Rotate player to face throw direction (with swing animation).\n    /// Prevents grenade from hitting player when throwing upward.\n    /// </summary>\n    /// <param name=\"throwDirection\">The direction of the throw.</param>\n    private void RotatePlayerForThrow(Vector2 throwDirection)\n    {\n        // Store current rotation to restore later\n        _playerRotationBeforeThrow = Rotation;\n\n        // Calculate target rotation (face throw direction)\n        _throwTargetRotation = throwDirection.Angle();\n\n        // Apply rotation immediately\n        Rotation = _throwTargetRotation;\n\n        // Start restore timer\n        _isThrowRotating = true;\n        _throwRotationRestoreTimer = ThrowRotationDuration;\n\n        LogToFile($\"[Player.Grenade] Player rotated for throw: {_playerRotationBeforeThrow} -> {_throwTargetRotation}\");\n    }\n\n    /// <summary>\n    /// Handle throw rotation animation - restore player rotation after throw.\n    /// </summary>\n    /// <param name=\"delta\">Time since last frame.</param>\n    private void HandleThrowRotationAnimation(float delta)\n    {\n        if (!_isThrowRotating)\n        {\n            return;\n        }\n\n        _throwRotationRestoreTimer -= delta;\n        if (_throwRotationRestoreTimer <= 0)\n        {\n            // Restore original rotation\n            Rotation = _playerRotationBeforeThrow;\n            _isThrowRotating = false;\n            LogToFile($\"[Player.Grenade] Player rotation restored to {_playerRotationBeforeThrow}\");\n        }\n    }\n\n    /// <summary>\n    /// Get a safe spawn position for the grenade that doesn't spawn behind/inside walls.\n    /// Uses raycast from player position to intended spawn position to detect walls.\n    /// If a wall is detected, spawns the grenade just before the wall (5px safety margin).\n    /// </summary>\n    /// <param name=\"fromPos\">The player's current position.</param>\n    /// <param name=\"intendedPos\">The intended spawn position (player + offset in throw direction).</param>\n    /// <param name=\"throwDirection\">The normalized throw direction.</param>\n    /// <returns>The safe spawn position for the grenade.</returns>\n    private Vector2 GetSafeGrenadeSpawnPosition(Vector2 fromPos, Vector2 intendedPos, Vector2 throwDirection)\n    {\n        // Get physics space state for raycasting\n        var spaceState = GetWorld2D().DirectSpaceState;\n        if (spaceState == null)\n        {\n            LogToFile(\"[Player.Grenade] Warning: Could not get DirectSpaceState for raycast\");\n            return intendedPos;\n        }\n\n        // Create raycast query from player to intended spawn position\n        // Collision mask 4 = obstacles layer (walls)\n        var query = PhysicsRayQueryParameters2D.Create(fromPos, intendedPos, 4);\n        query.Exclude = new Godot.Collections.Array<Rid> { GetRid() }; // Exclude self\n\n        var result = spaceState.IntersectRay(query);\n\n        // If no wall detected, use intended position\n        if (result.Count == 0)\n        {\n            return intendedPos;\n        }\n\n        // Wall detected! Calculate safe position (5px before the wall)\n        Vector2 wallPosition = (Vector2)result[\"position\"];\n        string colliderName = \"Unknown\";\n        if (result.ContainsKey(\"collider\"))\n        {\n            var collider = result[\"collider\"].AsGodotObject();\n            if (collider is Node node)\n            {\n                colliderName = node.Name;\n            }\n        }\n\n        float distanceToWall = fromPos.DistanceTo(wallPosition);\n        float safeDistance = Mathf.Max(distanceToWall - 5.0f, 10.0f); // At least 10px from player\n        Vector2 safePosition = fromPos + throwDirection * safeDistance;\n\n        LogToFile($\"[Player.Grenade] Wall detected at {wallPosition} (collider: {colliderName})! Adjusting spawn from {intendedPos} to {safePosition}\");\n\n        return safePosition;\n    }\n\n    /// <summary>\n    /// FIX for issue #313 v4: Snap raw mouse velocity direction to the nearest of 8 directions.\n    /// This compensates for imprecise human mouse movement while allowing diagonal throws.\n    ///\n    /// Uses 8 directions (45¬∞ sectors each):\n    /// - RIGHT (0¬∞): 0¬∞\n    /// - DOWN-RIGHT (45¬∞): 45¬∞\n    /// - DOWN (90¬∞): 90¬∞\n    /// - DOWN-LEFT (135¬∞): 135¬∞\n    /// - LEFT (180¬∞): 180¬∞\n    /// - UP-LEFT (-135¬∞): -135¬∞\n    /// - UP (-90¬∞): -90¬∞\n    /// - UP-RIGHT (-45¬∞): -45¬∞\n    /// </summary>\n    /// <param name=\"rawDirection\">The raw normalized direction from mouse velocity.</param>\n    /// <returns>The snapped direction (one of 8 unit vectors).</returns>\n    private Vector2 SnapToOctantDirection(Vector2 rawDirection)\n    {\n        float angle = rawDirection.Angle();  // Returns angle in radians (-PI to PI)\n        float sectorSize = Mathf.Pi / 4.0f;  // 45 degrees per sector (8 directions)\n        int sectorIndex = Mathf.RoundToInt(angle / sectorSize);\n        float snappedAngle = sectorIndex * sectorSize;\n        return new Vector2(Mathf.Cos(snappedAngle), Mathf.Sin(snappedAngle));\n    }\n\n    /// <summary>\n    /// Get current grenade count.\n    /// </summary>\n    public int GetCurrentGrenades()\n    {\n        return _currentGrenades;\n    }\n\n    /// <summary>\n    /// Get maximum grenade count.\n    /// </summary>\n    public int GetMaxGrenades()\n    {\n        return MaxGrenades;\n    }\n\n    /// <summary>\n    /// Add grenades to inventory (e.g., from pickup).\n    /// </summary>\n    /// <param name=\"count\">Number of grenades to add.</param>\n    public void AddGrenades(int count)\n    {\n        _currentGrenades = Mathf.Min(_currentGrenades + count, MaxGrenades);\n        EmitSignal(SignalName.GrenadeChanged, _currentGrenades, MaxGrenades);\n    }\n\n    /// <summary>\n    /// Check if player is preparing to throw a grenade.\n    /// </summary>\n    public bool IsPreparingGrenade()\n    {\n        return _grenadeState != GrenadeState.Idle;\n    }\n\n    #endregion\n\n    #region Grenade Animation Methods\n\n    /// <summary>\n    /// Start a new grenade animation phase.\n    /// </summary>\n    /// <param name=\"phase\">The GrenadeAnimPhase to transition to.</param>\n    /// <param name=\"duration\">How long this phase should last (for timed phases).</param>\n    private void StartGrenadeAnimPhase(GrenadeAnimPhase phase, float duration)\n    {\n        _grenadeAnimPhase = phase;\n        _grenadeAnimTimer = duration;\n        _grenadeAnimDuration = duration;\n\n        // Enable weapon sling when handling grenade\n        if (phase != GrenadeAnimPhase.None && phase != GrenadeAnimPhase.ReturnIdle)\n        {\n            _weaponSlung = true;\n        }\n        // RETURN_IDLE will unset _weaponSlung when animation completes\n\n        LogToFile($\"[Player.Grenade.Anim] Phase changed to: {phase} (duration: {duration:F2}s)\");\n    }\n\n    /// <summary>\n    /// Update grenade animation based on current phase.\n    /// Called every frame from _PhysicsProcess.\n    /// </summary>\n    /// <param name=\"delta\">Time since last frame.</param>\n    private void UpdateGrenadeAnimation(float delta)\n    {\n        // Early exit if no animation active\n        if (_grenadeAnimPhase == GrenadeAnimPhase.None)\n        {\n            // Restore normal z-index when not animating\n            RestoreArmZIndex();\n            return;\n        }\n\n        // Update phase timer\n        if (_grenadeAnimTimer > 0)\n        {\n            _grenadeAnimTimer -= delta;\n        }\n\n        // Calculate animation progress (0.0 to 1.0)\n        float progress = 1.0f;\n        if (_grenadeAnimDuration > 0)\n        {\n            progress = Mathf.Clamp(1.0f - (_grenadeAnimTimer / _grenadeAnimDuration), 0.0f, 1.0f);\n        }\n\n        // Calculate target positions based on current phase\n        Vector2 leftArmTarget = _baseLeftArmPos;\n        Vector2 rightArmTarget = _baseRightArmPos;\n        float leftArmRot = 0.0f;\n        float rightArmRot = 0.0f;\n        float lerpSpeed = AnimLerpSpeed * delta;\n\n        // Set arms to lower z-index during grenade operations (below weapon)\n        // This ensures arms appear below the weapon as user requested\n        SetGrenadeAnimZIndex();\n\n        switch (_grenadeAnimPhase)\n        {\n            case GrenadeAnimPhase.GrabGrenade:\n                // Left arm moves back to shoulder/chest area (away from weapon) to grab grenade\n                // Large negative X offset pulls the arm from weapon front (x=24) toward body (x~5)\n                leftArmTarget = _baseLeftArmPos + ArmLeftChest;\n                leftArmRot = Mathf.DegToRad(ArmRotGrab);\n                lerpSpeed = AnimLerpSpeedFast * delta;\n                break;\n\n            case GrenadeAnimPhase.PullPin:\n                // Left hand holds grenade at chest level, right hand pulls pin\n                leftArmTarget = _baseLeftArmPos + ArmLeftExtended;\n                leftArmRot = Mathf.DegToRad(ArmRotLeftAtChest);\n                rightArmTarget = _baseRightArmPos + ArmRightPin;\n                rightArmRot = Mathf.DegToRad(ArmRotPinPull);\n                lerpSpeed = AnimLerpSpeedFast * delta;\n                break;\n\n            case GrenadeAnimPhase.HandsApproach:\n                // Both hands at chest level, preparing for transfer\n                leftArmTarget = _baseLeftArmPos + ArmLeftExtended;\n                leftArmRot = Mathf.DegToRad(ArmRotLeftAtChest);\n                rightArmTarget = _baseRightArmPos + ArmRightApproach;\n                break;\n\n            case GrenadeAnimPhase.Transfer:\n                // Left arm drops back toward body, right hand takes grenade\n                leftArmTarget = _baseLeftArmPos + ArmLeftTransfer;\n                leftArmRot = Mathf.DegToRad(ArmRotLeftRelaxed * 0.5f);\n                rightArmTarget = _baseRightArmPos + ArmRightHold;\n                lerpSpeed = AnimLerpSpeed * delta;\n                break;\n\n            case GrenadeAnimPhase.WindUp:\n                // LEFT ARM: Fully retracted to shoulder/body area, hangs at side\n                // This is the key position - arm must be clearly NOT on the weapon\n                leftArmTarget = _baseLeftArmPos + ArmLeftRelaxed;\n                leftArmRot = Mathf.DegToRad(ArmRotLeftRelaxed);\n                // RIGHT ARM: Interpolate between min and max wind-up based on intensity\n                Vector2 windUpOffset = ArmRightWindMin.Lerp(ArmRightWindMax, _windUpIntensity);\n                rightArmTarget = _baseRightArmPos + windUpOffset;\n                float windUpRot = Mathf.Lerp(ArmRotWindMin, ArmRotWindMax, _windUpIntensity);\n                rightArmRot = Mathf.DegToRad(windUpRot);\n                lerpSpeed = AnimLerpSpeedFast * delta; // Responsive to input\n                break;\n\n            case GrenadeAnimPhase.Throw:\n                // Throwing motion - right arm swings forward, left stays at body\n                leftArmTarget = _baseLeftArmPos + ArmLeftRelaxed;\n                leftArmRot = Mathf.DegToRad(ArmRotLeftRelaxed);\n                rightArmTarget = _baseRightArmPos + ArmRightThrow;\n                rightArmRot = Mathf.DegToRad(ArmRotThrow);\n                lerpSpeed = AnimLerpSpeedFast * delta;\n\n                // When throw animation completes, transition to return\n                if (_grenadeAnimTimer <= 0)\n                {\n                    StartGrenadeAnimPhase(GrenadeAnimPhase.ReturnIdle, AnimReturnDuration);\n                }\n                break;\n\n            case GrenadeAnimPhase.ReturnIdle:\n                // Arms returning to base positions (back to holding weapon)\n                leftArmTarget = _baseLeftArmPos;\n                rightArmTarget = _baseRightArmPos;\n                lerpSpeed = AnimLerpSpeed * delta;\n\n                // When return animation completes, end animation\n                if (_grenadeAnimTimer <= 0)\n                {\n                    _grenadeAnimPhase = GrenadeAnimPhase.None;\n                    _weaponSlung = false;\n                    RestoreArmZIndex();\n                    LogToFile(\"[Player.Grenade.Anim] Animation complete, returning to normal\");\n                }\n                break;\n        }\n\n        // Apply arm positions with smooth interpolation\n        if (_leftArmSprite != null)\n        {\n            _leftArmSprite.Position = _leftArmSprite.Position.Lerp(leftArmTarget, lerpSpeed);\n            _leftArmSprite.Rotation = Mathf.Lerp(_leftArmSprite.Rotation, leftArmRot, lerpSpeed);\n        }\n\n        if (_rightArmSprite != null)\n        {\n            _rightArmSprite.Position = _rightArmSprite.Position.Lerp(rightArmTarget, lerpSpeed);\n            _rightArmSprite.Rotation = Mathf.Lerp(_rightArmSprite.Rotation, rightArmRot, lerpSpeed);\n        }\n\n        // Update weapon sling animation\n        UpdateWeaponSling(delta);\n    }\n\n    /// <summary>\n    /// Set arm z-index for grenade animation (arms below weapon).\n    /// </summary>\n    private void SetGrenadeAnimZIndex()\n    {\n        // During grenade operations, arms should appear below the weapon\n        // Weapon has z_index = 1, so set arms to 0\n        if (_leftArmSprite != null)\n        {\n            _leftArmSprite.ZIndex = 0;\n        }\n        if (_rightArmSprite != null)\n        {\n            _rightArmSprite.ZIndex = 0;\n        }\n    }\n\n    /// <summary>\n    /// Restore normal arm z-index (arms above weapon for normal aiming).\n    /// </summary>\n    private void RestoreArmZIndex()\n    {\n        // Normal state: arms at z_index 2 (between body and head)\n        if (_leftArmSprite != null)\n        {\n            _leftArmSprite.ZIndex = 2;\n        }\n        if (_rightArmSprite != null)\n        {\n            _rightArmSprite.ZIndex = 2;\n        }\n    }\n\n    /// <summary>\n    /// Update weapon sling position (lower weapon when handling grenade).\n    /// </summary>\n    /// <param name=\"delta\">Time since last frame.</param>\n    private void UpdateWeaponSling(float delta)\n    {\n        if (_weaponMount == null)\n        {\n            return;\n        }\n\n        Vector2 targetPos = _baseWeaponMountPos;\n        float targetRot = _baseWeaponMountRot;\n\n        if (_weaponSlung)\n        {\n            // Lower weapon to chest/sling position\n            targetPos = _baseWeaponMountPos + WeaponSlingOffset;\n            targetRot = _baseWeaponMountRot + WeaponSlingRotation;\n        }\n\n        float lerpSpeed = AnimLerpSpeed * delta;\n        _weaponMount.Position = _weaponMount.Position.Lerp(targetPos, lerpSpeed);\n        _weaponMount.Rotation = Mathf.Lerp(_weaponMount.Rotation, targetRot, lerpSpeed);\n    }\n\n    /// <summary>\n    /// Update wind-up intensity and track mouse velocity during aiming.\n    /// Uses velocity-based physics for realistic throwing.\n    /// </summary>\n    private void UpdateWindUpIntensity()\n    {\n        Vector2 currentMouse = GetGlobalMousePosition();\n        double currentTime = Time.GetTicksMsec() / 1000.0;\n\n        // Calculate time delta since last frame\n        double deltaTime = currentTime - _prevFrameTime;\n        if (deltaTime <= 0.0)\n        {\n            deltaTime = 0.016; // Default to ~60fps if first frame\n        }\n\n        // Calculate mouse displacement since last frame\n        Vector2 mouseDelta = currentMouse - _prevMousePos;\n\n        // Accumulate total swing distance for momentum transfer calculation\n        _totalSwingDistance += mouseDelta.Length();\n\n        // Calculate instantaneous mouse velocity (pixels per second)\n        Vector2 instantaneousVelocity = mouseDelta / (float)deltaTime;\n\n        // Add to velocity history for smoothing\n        _mouseVelocityHistory.Add(instantaneousVelocity);\n        if (_mouseVelocityHistory.Count > MouseVelocityHistorySize)\n        {\n            _mouseVelocityHistory.RemoveAt(0);\n        }\n\n        // Calculate average velocity from history (smoothed velocity)\n        Vector2 velocitySum = Vector2.Zero;\n        foreach (Vector2 vel in _mouseVelocityHistory)\n        {\n            velocitySum += vel;\n        }\n        _currentMouseVelocity = velocitySum / Math.Max(_mouseVelocityHistory.Count, 1);\n\n        // Calculate wind-up intensity based on velocity (for animation)\n        // Higher velocity = more wind-up visual effect\n        float velocityMagnitude = _currentMouseVelocity.Length();\n        // Normalize to a reasonable range (0-2000 pixels/second typical for fast mouse movement)\n        float velocityIntensity = Mathf.Clamp(velocityMagnitude / 1500.0f, 0.0f, 1.0f);\n\n        _windUpIntensity = velocityIntensity;\n\n        // Update tracking for next frame\n        _prevMousePos = currentMouse;\n        _prevFrameTime = currentTime;\n    }\n\n    #endregion\n\n    #region Reload Animation Methods\n\n    /// <summary>\n    /// Start a new reload animation phase.\n    /// </summary>\n    /// <param name=\"phase\">The ReloadAnimPhase to transition to.</param>\n    /// <param name=\"duration\">How long this phase should last.</param>\n    private void StartReloadAnimPhase(ReloadAnimPhase phase, float duration)\n    {\n        _reloadAnimPhase = phase;\n        _reloadAnimTimer = duration;\n        _reloadAnimDuration = duration;\n\n        // Reset bolt pull sub-phase when entering bolt pull phase\n        if (phase == ReloadAnimPhase.PullBolt)\n        {\n            _boltPullSubPhase = 0;\n        }\n\n        LogToFile($\"[Player.Reload.Anim] Phase changed to: {phase} (duration: {duration:F2}s)\");\n    }\n\n    /// <summary>\n    /// Set arm z-index for reload animation (arms BELOW weapon).\n    /// User feedback: animated hand should be below weapon, not above it.\n    /// </summary>\n    private void SetReloadAnimZIndex()\n    {\n        // During reload operations, arms should appear BELOW the weapon\n        // Weapon has z_index = 1, so set arms to 0\n        if (_leftArmSprite != null)\n        {\n            _leftArmSprite.ZIndex = 0;\n        }\n        if (_rightArmSprite != null)\n        {\n            _rightArmSprite.ZIndex = 0;\n        }\n    }\n\n    /// <summary>\n    /// Update reload animation based on current phase.\n    /// Called every frame from _PhysicsProcess.\n    /// </summary>\n    /// <param name=\"delta\">Time since last frame.</param>\n    private void UpdateReloadAnimation(float delta)\n    {\n        // Early exit if no animation active\n        if (_reloadAnimPhase == ReloadAnimPhase.None)\n        {\n            // Restore normal z-index when not animating\n            RestoreArmZIndex();\n            return;\n        }\n\n        // Update phase timer\n        if (_reloadAnimTimer > 0)\n        {\n            _reloadAnimTimer -= delta;\n        }\n\n        // Calculate target positions based on current phase\n        Vector2 leftArmTarget = _baseLeftArmPos;\n        Vector2 rightArmTarget = _baseRightArmPos;\n        float leftArmRot = 0.0f;\n        float rightArmRot = 0.0f;\n        float lerpSpeed = AnimLerpSpeed * delta;\n\n        // Set arms to lower z-index during reload operations (BELOW weapon)\n        // User feedback: \"animated hand should be below weapon, not above it\"\n        SetReloadAnimZIndex();\n\n        switch (_reloadAnimPhase)\n        {\n            case ReloadAnimPhase.GrabMagazine:\n                // Step 1: Left arm moves to chest to grab new magazine\n                leftArmTarget = _baseLeftArmPos + ReloadArmLeftGrab;\n                leftArmRot = Mathf.DegToRad(ReloadArmRotLeftGrab);\n                rightArmTarget = _baseRightArmPos + ReloadArmRightHold;\n                rightArmRot = Mathf.DegToRad(ReloadArmRotRightHold);\n                lerpSpeed = AnimLerpSpeedFast * delta;\n                break;\n\n            case ReloadAnimPhase.InsertMagazine:\n                // Step 2: Left arm brings magazine to weapon magwell (at middle of weapon)\n                // User feedback: \"step 2 should end at middle of weapon length, not at the end\"\n                leftArmTarget = _baseLeftArmPos + ReloadArmLeftInsert;\n                leftArmRot = Mathf.DegToRad(ReloadArmRotLeftInsert);\n                rightArmTarget = _baseRightArmPos + ReloadArmRightSteady;\n                rightArmRot = Mathf.DegToRad(ReloadArmRotRightSteady);\n                lerpSpeed = AnimLerpSpeed * delta;\n                break;\n\n            case ReloadAnimPhase.PullBolt:\n                // Step 3: Right hand traces rifle contour - back and forth motion\n                // User feedback: \"step 3 should be a movement along the rifle contour\n                // right towards and away from oneself (back and forth)\"\n                leftArmTarget = _baseLeftArmPos + ReloadArmLeftSupport;\n                leftArmRot = Mathf.DegToRad(ReloadArmRotLeftSupport);\n\n                if (_boltPullSubPhase == 0)\n                {\n                    // Sub-phase 0: Pull bolt back (toward player)\n                    rightArmTarget = _baseRightArmPos + ReloadArmRightBoltPull;\n                    rightArmRot = Mathf.DegToRad(ReloadArmRotRightBoltPull);\n                    lerpSpeed = AnimLerpSpeedFast * delta;\n\n                    // Log bolt pull progress periodically\n                    if (Engine.GetFramesDrawn() % 30 == 0)\n                    {\n                        LogToFile($\"[Player.Reload.Anim] Bolt sub-phase 0 (pull back): timer={_reloadAnimTimer:F2}s, rightArm target={rightArmTarget}\");\n                    }\n\n                    // When pull back completes, transition to return forward\n                    if (_reloadAnimTimer <= 0)\n                    {\n                        _boltPullSubPhase = 1;\n                        _reloadAnimTimer = ReloadAnimBoltReturnDuration;\n                        _reloadAnimDuration = ReloadAnimBoltReturnDuration;\n                        LogToFile($\"[Player.Reload.Anim] Bolt sub-phase transition: pull‚Üíreturn (duration: {ReloadAnimBoltReturnDuration:F2}s)\");\n                    }\n                }\n                else\n                {\n                    // Sub-phase 1: Release bolt (return forward)\n                    rightArmTarget = _baseRightArmPos + ReloadArmRightBoltReturn;\n                    rightArmRot = Mathf.DegToRad(ReloadArmRotRightBoltReturn);\n                    lerpSpeed = AnimLerpSpeedFast * delta;\n\n                    // Log bolt return progress periodically\n                    if (Engine.GetFramesDrawn() % 30 == 0)\n                    {\n                        LogToFile($\"[Player.Reload.Anim] Bolt sub-phase 1 (return): timer={_reloadAnimTimer:F2}s, rightArm target={rightArmTarget}\");\n                    }\n\n                    // When return completes, transition to return idle\n                    if (_reloadAnimTimer <= 0)\n                    {\n                        LogToFile(\"[Player.Reload.Anim] Bolt animation complete, transitioning to idle\");\n                        StartReloadAnimPhase(ReloadAnimPhase.ReturnIdle, ReloadAnimReturnDuration);\n                    }\n                }\n                break;\n\n            case ReloadAnimPhase.ReturnIdle:\n                // Arms returning to base positions\n                leftArmTarget = _baseLeftArmPos;\n                rightArmTarget = _baseRightArmPos;\n                leftArmRot = 0.0f;\n                rightArmRot = 0.0f;\n                lerpSpeed = AnimLerpSpeed * delta;\n\n                // When return animation completes, end animation and restore z-index\n                if (_reloadAnimTimer <= 0)\n                {\n                    _reloadAnimPhase = ReloadAnimPhase.None;\n                    RestoreArmZIndex();\n                    LogToFile(\"[Player.Reload.Anim] Animation complete, returning to normal\");\n                }\n                break;\n        }\n\n        // Apply arm positions with smooth interpolation\n        if (_leftArmSprite != null)\n        {\n            Vector2 oldPos = _leftArmSprite.Position;\n            _leftArmSprite.Position = _leftArmSprite.Position.Lerp(leftArmTarget, lerpSpeed);\n            _leftArmSprite.Rotation = Mathf.Lerp(_leftArmSprite.Rotation, leftArmRot, lerpSpeed);\n\n            // Log arm position changes periodically (every 60 frames = ~1 second)\n            if (Engine.GetFramesDrawn() % 60 == 0)\n            {\n                LogToFile($\"[Player.Reload.Anim] LeftArm: pos={_leftArmSprite.Position}, target={leftArmTarget}, base={_baseLeftArmPos}\");\n            }\n        }\n        else if (Engine.GetFramesDrawn() % 60 == 0)\n        {\n            LogToFile(\"[Player.Reload.Anim] WARNING: Left arm sprite is null during animation!\");\n        }\n\n        if (_rightArmSprite != null)\n        {\n            Vector2 oldPos = _rightArmSprite.Position;\n            _rightArmSprite.Position = _rightArmSprite.Position.Lerp(rightArmTarget, lerpSpeed);\n            _rightArmSprite.Rotation = Mathf.Lerp(_rightArmSprite.Rotation, rightArmRot, lerpSpeed);\n\n            // Log arm position changes periodically (every 60 frames = ~1 second)\n            if (Engine.GetFramesDrawn() % 60 == 0)\n            {\n                LogToFile($\"[Player.Reload.Anim] RightArm: pos={_rightArmSprite.Position}, target={rightArmTarget}, base={_baseRightArmPos}\");\n            }\n        }\n        else if (Engine.GetFramesDrawn() % 60 == 0)\n        {\n            LogToFile(\"[Player.Reload.Anim] WARNING: Right arm sprite is null during animation!\");\n        }\n    }\n\n    #endregion\n\n    #region Logging\n\n    /// <summary>\n    /// Logs a message to the FileLogger (GDScript autoload) for debugging.\n    /// </summary>\n    /// <param name=\"message\">The message to log.</param>\n    private void LogToFile(string message)\n    {\n        // Print to console\n        GD.Print(message);\n\n        // Also log to FileLogger if available\n        var fileLogger = GetNodeOrNull(\"/root/FileLogger\");\n        if (fileLogger != null && fileLogger.HasMethod(\"log_info\"))\n        {\n            fileLogger.Call(\"log_info\", message);\n        }\n    }\n\n    #endregion\n\n    #region Debug Trajectory Visualization\n\n    /// <summary>\n    /// Connects to GameManager's debug_mode_toggled and invincibility_toggled signals.\n    /// </summary>\n    private void ConnectDebugModeSignal()\n    {\n        var gameManager = GetNodeOrNull(\"/root/GameManager\");\n        if (gameManager == null)\n        {\n            LogToFile(\"[Player.Debug] WARNING: GameManager not found, debug visualization disabled\");\n            return;\n        }\n\n        // Connect to debug mode signal (F7)\n        if (gameManager.HasSignal(\"debug_mode_toggled\"))\n        {\n            gameManager.Connect(\"debug_mode_toggled\", Callable.From<bool>(OnDebugModeToggled));\n\n            // Check if debug mode is already enabled\n            if (gameManager.HasMethod(\"is_debug_mode_enabled\"))\n            {\n                _debugModeEnabled = (bool)gameManager.Call(\"is_debug_mode_enabled\");\n                LogToFile($\"[Player.Debug] Connected to GameManager, debug mode: {_debugModeEnabled}\");\n            }\n        }\n        else\n        {\n            LogToFile(\"[Player.Debug] WARNING: GameManager doesn't have debug_mode_toggled signal\");\n        }\n\n        // Connect to invincibility mode signal (F6)\n        if (gameManager.HasSignal(\"invincibility_toggled\"))\n        {\n            gameManager.Connect(\"invincibility_toggled\", Callable.From<bool>(OnInvincibilityToggled));\n\n            // Check if invincibility mode is already enabled\n            if (gameManager.HasMethod(\"is_invincibility_enabled\"))\n            {\n                _invincibilityEnabled = (bool)gameManager.Call(\"is_invincibility_enabled\");\n                LogToFile($\"[Player.Debug] Connected to GameManager, invincibility mode: {_invincibilityEnabled}\");\n                UpdateInvincibilityIndicator();\n            }\n        }\n        else\n        {\n            LogToFile(\"[Player.Debug] WARNING: GameManager doesn't have invincibility_toggled signal\");\n        }\n    }\n\n    /// <summary>\n    /// Called when debug mode is toggled via F7 key.\n    /// </summary>\n    /// <param name=\"enabled\">True if debug mode is now enabled.</param>\n    private void OnDebugModeToggled(bool enabled)\n    {\n        _debugModeEnabled = enabled;\n        QueueRedraw();\n        LogToFile($\"[Player.Debug] Debug mode toggled: {(enabled ? \"ON\" : \"OFF\")}\");\n    }\n\n    /// <summary>\n    /// Called when invincibility mode is toggled via F6 key.\n    /// </summary>\n    /// <param name=\"enabled\">True if invincibility mode is now enabled.</param>\n    private void OnInvincibilityToggled(bool enabled)\n    {\n        _invincibilityEnabled = enabled;\n        UpdateInvincibilityIndicator();\n        LogToFile($\"[Player] Invincibility mode: {(enabled ? \"ON\" : \"OFF\")}\");\n    }\n\n    /// <summary>\n    /// Updates the visual indicator for invincibility mode.\n    /// Shows \"INVINCIBLE\" label when enabled, hides it when disabled.\n    /// </summary>\n    private void UpdateInvincibilityIndicator()\n    {\n        // Create label if it doesn't exist\n        if (_invincibilityLabel == null)\n        {\n            _invincibilityLabel = new Label();\n            _invincibilityLabel.Name = \"InvincibilityLabel\";\n            _invincibilityLabel.Text = \"–ë–ï–°–°–ú–ï–†–¢–ò–ï\";\n            _invincibilityLabel.HorizontalAlignment = HorizontalAlignment.Center;\n            _invincibilityLabel.VerticalAlignment = VerticalAlignment.Center;\n\n            // Position above the player\n            _invincibilityLabel.Position = new Vector2(-60, -80);\n            _invincibilityLabel.Size = new Vector2(120, 30);\n\n            // Style: bright yellow/gold color with outline for visibility\n            _invincibilityLabel.AddThemeColorOverride(\"font_color\", new Color(1.0f, 0.9f, 0.2f, 1.0f));\n            _invincibilityLabel.AddThemeColorOverride(\"font_outline_color\", new Color(0.0f, 0.0f, 0.0f, 1.0f));\n            _invincibilityLabel.AddThemeFontSizeOverride(\"font_size\", 14);\n            _invincibilityLabel.AddThemeConstantOverride(\"outline_size\", 3);\n\n            AddChild(_invincibilityLabel);\n        }\n\n        // Show/hide based on invincibility state\n        _invincibilityLabel.Visible = _invincibilityEnabled;\n    }\n\n    /// <summary>\n    /// Override _Draw to visualize grenade trajectory.\n    /// In simple mode: Always shows trajectory preview (semi-transparent arc).\n    /// In complex mode: Only shows when debug mode is enabled (F7).\n    /// </summary>\n    public override void _Draw()\n    {\n        // Determine if we should draw trajectory\n        bool isSimpleAiming = _grenadeState == GrenadeState.SimpleAiming;\n        bool isComplexAiming = _grenadeState == GrenadeState.Aiming;\n\n        // In simple mode: always show trajectory\n        // In complex mode: only show if debug mode is enabled\n        if (!isSimpleAiming && !(isComplexAiming && _debugModeEnabled))\n        {\n            return;\n        }\n\n        // Use different colors for simple mode (more subtle) vs debug mode (bright)\n        Color colorTrajectory;\n        Color colorLanding;\n        Color colorRadius;\n        float lineWidth;\n\n        if (isSimpleAiming)\n        {\n            // Semi-transparent colors for simple mode\n            colorTrajectory = new Color(1.0f, 1.0f, 1.0f, 0.4f); // White semi-transparent\n            colorLanding = new Color(1.0f, 0.8f, 0.2f, 0.6f); // Yellow-orange\n            colorRadius = new Color(1.0f, 0.5f, 0.0f, 0.2f); // Effect radius\n            lineWidth = 2.0f;\n        }\n        else\n        {\n            // Bright colors for debug mode\n            colorTrajectory = new Color(1.0f, 0.8f, 0.2f, 0.9f);\n            colorLanding = new Color(1.0f, 0.3f, 0.1f, 0.9f);\n            colorRadius = new Color(1.0f, 0.5f, 0.0f, 0.3f);\n            lineWidth = 3.0f;\n        }\n\n        // Calculate throw parameters\n        Vector2 currentMousePos = GetGlobalMousePosition();\n        Vector2 throwDirection;\n        float throwSpeed;\n        float landingDistance;\n        const float SpawnOffset = 60.0f;\n\n        // Get grenade's actual physics properties for accurate visualization\n        // FIX for issue #398: Use actual grenade properties instead of hardcoded values\n        float groundFriction = 300.0f; // Default\n        float maxThrowSpeed = 850.0f;  // Default\n        if (_activeGrenade != null && IsInstanceValid(_activeGrenade))\n        {\n            if (_activeGrenade.Get(\"ground_friction\").VariantType != Variant.Type.Nil)\n            {\n                groundFriction = (float)_activeGrenade.Get(\"ground_friction\");\n            }\n            if (_activeGrenade.Get(\"max_throw_speed\").VariantType != Variant.Type.Nil)\n            {\n                maxThrowSpeed = (float)_activeGrenade.Get(\"max_throw_speed\");\n            }\n        }\n\n        if (isSimpleAiming)\n        {\n            // Simple mode: direction and distance based on cursor position\n            Vector2 toTarget = currentMousePos - GlobalPosition;\n            throwDirection = toTarget.Length() > 10.0f ? toTarget.Normalized() : new Vector2(1, 0);\n\n            // FIX for issue #398: Account for spawn offset in distance calculation\n            // The grenade starts 60 pixels ahead of the player\n            Vector2 spawnPos = GlobalPosition + throwDirection * SpawnOffset;\n            float throwDistance = (currentMousePos - spawnPos).Length();\n            if (throwDistance < 10.0f) throwDistance = 10.0f;\n\n            // Calculate throw speed needed to reach target\n            float requiredSpeed = Mathf.Sqrt(2.0f * groundFriction * throwDistance);\n            throwSpeed = Mathf.Min(requiredSpeed, maxThrowSpeed);\n\n            // Calculate actual landing distance with clamped speed\n            landingDistance = (throwSpeed * throwSpeed) / (2.0f * groundFriction);\n        }\n        else\n        {\n            // Complex mode: direction based on mouse velocity\n            Vector2 releaseVelocity = _currentMouseVelocity;\n            float velocityMagnitude = releaseVelocity.Length();\n            Vector2 dragVector = currentMousePos - _grenadeDragStart;\n\n            if (velocityMagnitude > 10.0f)\n            {\n                throwDirection = SnapToOctantDirection(releaseVelocity.Normalized());\n            }\n            else if (dragVector.Length() > 5.0f)\n            {\n                throwDirection = SnapToOctantDirection(dragVector.Normalized());\n            }\n            else\n            {\n                throwDirection = new Vector2(1, 0);\n            }\n\n            // Calculate velocity-based throw speed\n            const float GrenadeMass = 0.36f;\n            const float MouseVelocityMultiplier = 1.5f;\n            const float MinSwingDistance = 180.0f;\n            const float MinThrowSpeed = 100.0f;\n            const float MaxThrowSpeed = 2500.0f;\n\n            float massRatio = GrenadeMass / 0.4f;\n            float adjustedMinSwing = MinSwingDistance * massRatio;\n            float transferEfficiency = Mathf.Clamp(_totalSwingDistance / adjustedMinSwing, 0.0f, 1.0f);\n            float massMultiplier = 1.0f / Mathf.Sqrt(massRatio);\n\n            throwSpeed = velocityMagnitude * MouseVelocityMultiplier * transferEfficiency * massMultiplier;\n            throwSpeed = Mathf.Clamp(throwSpeed, MinThrowSpeed, MaxThrowSpeed);\n\n            if (velocityMagnitude < 10.0f)\n            {\n                throwSpeed = MinThrowSpeed * 0.5f;\n            }\n\n            landingDistance = (throwSpeed * throwSpeed) / (2.0f * groundFriction);\n        }\n\n        // Calculate spawn and landing positions\n        Vector2 spawnPosition = GlobalPosition + throwDirection * SpawnOffset;\n        Vector2 landingPosition = spawnPosition + throwDirection * landingDistance;\n\n        // Convert to local coordinates for drawing\n        Vector2 localStart = ToLocal(spawnPosition);\n        Vector2 localEnd = ToLocal(landingPosition);\n\n        // Draw trajectory line with dashes\n        DrawTrajectoryLine(localStart, localEnd, colorTrajectory, lineWidth);\n\n        // Draw landing point indicator (circle with X)\n        DrawLandingIndicator(localEnd, colorLanding, 12.0f);\n\n        // Draw effect radius circle at landing position\n        float effectRadius = GetGrenadeEffectRadius();\n        DrawCircleOutline(localEnd, effectRadius, colorRadius, 2.0f);\n\n        // In complex mode, also draw velocity direction arrow\n        if (isComplexAiming)\n        {\n            Vector2 localPlayerCenter = Vector2.Zero;\n            Vector2 arrowEnd = localPlayerCenter + throwDirection * 40.0f;\n            DrawArrow(localPlayerCenter, arrowEnd, new Color(0.2f, 1.0f, 0.2f, 0.7f), 2.0f);\n        }\n    }\n\n    /// <summary>\n    /// Get the effect radius of the current grenade type.\n    /// FIX for Issue #432: Use type-based defaults when GDScript Call() fails in exports.\n    /// </summary>\n    private float GetGrenadeEffectRadius()\n    {\n        if (_activeGrenade != null && IsInstanceValid(_activeGrenade))\n        {\n            // Try to call GDScript method first\n            if (_activeGrenade.HasMethod(\"_get_effect_radius\"))\n            {\n                var result = _activeGrenade.Call(\"_get_effect_radius\");\n                if (result.VariantType != Variant.Type.Nil)\n                {\n                    return (float)result;\n                }\n            }\n\n            // Try to read effect_radius property directly\n            if (_activeGrenade.Get(\"effect_radius\").VariantType != Variant.Type.Nil)\n            {\n                return (float)_activeGrenade.Get(\"effect_radius\");\n            }\n\n            // FIX for Issue #432: Use type-based defaults matching scene files\n            // GDScript property access may fail silently in exported builds\n            var script = _activeGrenade.GetScript();\n            if (script.Obj != null)\n            {\n                string scriptPath = ((Script)script.Obj).ResourcePath;\n                if (scriptPath.Contains(\"frag_grenade\"))\n                {\n                    return 225.0f;  // FragGrenade.tscn default\n                }\n            }\n        }\n        // Default: Flashbang effect radius (FlashbangGrenade.tscn)\n        return 400.0f;\n    }\n\n    /// <summary>\n    /// Draw a circle outline at the specified position.\n    /// </summary>\n    private void DrawCircleOutline(Vector2 position, float radius, Color color, float width)\n    {\n        const int segments = 32;\n        var points = new List<Vector2>();\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            points.Add(position + new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * radius);\n        }\n        for (int i = 0; i < points.Count - 1; i++)\n        {\n            DrawLine(points[i], points[i + 1], color, width);\n        }\n    }\n\n    /// <summary>\n    /// Draw a dashed trajectory line from start to end.\n    /// </summary>\n    private void DrawTrajectoryLine(Vector2 start, Vector2 end, Color color, float width)\n    {\n        Vector2 direction = (end - start).Normalized();\n        float totalLength = start.DistanceTo(end);\n        const float DashLength = 15.0f;\n        const float GapLength = 8.0f;\n\n        float currentPos = 0.0f;\n        while (currentPos < totalLength)\n        {\n            float dashEnd = Mathf.Min(currentPos + DashLength, totalLength);\n            Vector2 dashStart = start + direction * currentPos;\n            Vector2 dashEndPos = start + direction * dashEnd;\n            DrawLine(dashStart, dashEndPos, color, width);\n            currentPos = dashEnd + GapLength;\n        }\n    }\n\n    /// <summary>\n    /// Draw a landing indicator (circle with X) at the target position.\n    /// </summary>\n    private void DrawLandingIndicator(Vector2 position, Color color, float radius)\n    {\n        // Draw outer circle\n        const int CirclePoints = 24;\n        Vector2[] circlePoints = new Vector2[CirclePoints + 1];\n        for (int i = 0; i <= CirclePoints; i++)\n        {\n            float angle = i * Mathf.Tau / CirclePoints;\n            circlePoints[i] = position + new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * radius;\n        }\n        for (int i = 0; i < CirclePoints; i++)\n        {\n            DrawLine(circlePoints[i], circlePoints[i + 1], color, 2.0f);\n        }\n\n        // Draw X inside\n        float xSize = radius * 0.6f;\n        DrawLine(position + new Vector2(-xSize, -xSize), position + new Vector2(xSize, xSize), color, 2.0f);\n        DrawLine(position + new Vector2(-xSize, xSize), position + new Vector2(xSize, -xSize), color, 2.0f);\n    }\n\n    /// <summary>\n    /// Draw an arrow from start to end with an arrowhead.\n    /// </summary>\n    private void DrawArrow(Vector2 start, Vector2 end, Color color, float width)\n    {\n        // Draw main line\n        DrawLine(start, end, color, width);\n\n        // Draw arrowhead\n        Vector2 direction = (end - start).Normalized();\n        float arrowSize = 8.0f;\n        float arrowAngle = Mathf.Pi / 6.0f; // 30 degrees\n\n        Vector2 arrowLeft = end - direction.Rotated(arrowAngle) * arrowSize;\n        Vector2 arrowRight = end - direction.Rotated(-arrowAngle) * arrowSize;\n\n        DrawLine(end, arrowLeft, color, width);\n        DrawLine(end, arrowRight, color, width);\n    }\n\n    #endregion\n}\n",
    "structuredPatch": [
      {
        "oldStart": 1661,
        "oldLines": 6,
        "newStart": 1661,
        "newLines": 15,
        "lines": [
          "         // If we have a weapon equipped, use it",
          "         if (CurrentWeapon != null)",
          "         {",
          "+            // When SniperRifle scope is active, fire towards the scope crosshair center",
          "+            // instead of the mouse cursor (the camera is offset, so mouse != crosshair)",
          "+            var sniperRifle = CurrentWeapon as SniperRifle;",
          "+            if (sniperRifle != null && sniperRifle.IsScopeActive)",
          "+            {",
          "+                Vector2 scopeTarget = sniperRifle.GetScopeAimTarget();",
          "+                shootDirection = (scopeTarget - GlobalPosition).Normalized();",
          "+            }",
          "+",
          "             CurrentWeapon.Fire(shootDirection);",
          "             return;",
          "         }"
        ]
      }
    ],
    "userModified": false,
    "replaceAll": false
  }
}
[2026-02-06T20:58:01.228Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01LcHizs2KskPDAU95FoFdzA",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now add mouse motion handling to `_UnhandledInput` for the scope fine-tune:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 595,
      "cache_read_input_tokens": 62399,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 595
      },
      "output_tokens": 2,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "33927eac-1c7d-4612-b6b5-f6ce15c99ebb"
}
[2026-02-06T20:58:07.467Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01LcHizs2KskPDAU95FoFdzA",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_019H7kXsGM74bPbmAKVGdNPM",
        "name": "Edit",
        "input": {
          "replace_all": false,
          "file_path": "/tmp/gh-issue-solver-1770411323361/Scripts/Characters/Player.cs",
          "old_string": "    public override void _UnhandledInput(InputEvent @event)\n    {\n        base._UnhandledInput(@event);\n\n        var sniperRifle = CurrentWeapon as SniperRifle;\n        if (sniperRifle == null || !sniperRifle.IsScopeActive)\n        {\n            return;\n        }\n\n        if (@event is InputEventMouseButton mouseButton)\n        {\n            if (mouseButton.Pressed)\n            {\n                if (mouseButton.ButtonIndex == MouseButton.WheelUp)\n                {\n                    sniperRifle.AdjustScopeZoom(1.0f);\n                    GetViewport().SetInputAsHandled();\n                }\n                else if (mouseButton.ButtonIndex == MouseButton.WheelDown)\n                {\n                    sniperRifle.AdjustScopeZoom(-1.0f);\n                    GetViewport().SetInputAsHandled();\n                }\n            }\n        }\n    }",
          "new_string": "    public override void _UnhandledInput(InputEvent @event)\n    {\n        base._UnhandledInput(@event);\n\n        var sniperRifle = CurrentWeapon as SniperRifle;\n        if (sniperRifle == null || !sniperRifle.IsScopeActive)\n        {\n            return;\n        }\n\n        if (@event is InputEventMouseButton mouseButton)\n        {\n            if (mouseButton.Pressed)\n            {\n                if (mouseButton.ButtonIndex == MouseButton.WheelUp)\n                {\n                    sniperRifle.AdjustScopeZoom(1.0f);\n                    GetViewport().SetInputAsHandled();\n                }\n                else if (mouseButton.ButtonIndex == MouseButton.WheelDown)\n                {\n                    sniperRifle.AdjustScopeZoom(-1.0f);\n                    GetViewport().SetInputAsHandled();\n                }\n            }\n        }\n        // Handle mouse movement for scope fine-tuning (closer/further by ~1/3 viewport)\n        else if (@event is InputEventMouseMotion mouseMotion)\n        {\n            sniperRifle.AdjustScopeFineTune(mouseMotion.Relative);\n        }\n    }"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 595,
      "cache_read_input_tokens": 62399,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 595
      },
      "output_tokens": 2,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "1e23a9c9-23e8-4630-a4dc-8f583825674a"
}
[2026-02-06T20:58:07.484Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_019H7kXsGM74bPbmAKVGdNPM",
        "type": "tool_result",
        "content": "The file /tmp/gh-issue-solver-1770411323361/Scripts/Characters/Player.cs has been updated successfully."
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "2383b29e-cb23-4a85-a6b1-8e0ddb0564ef",
  "tool_use_result": {
    "filePath": "/tmp/gh-issue-solver-1770411323361/Scripts/Characters/Player.cs",
    "oldString": "    public override void _UnhandledInput(InputEvent @event)\n    {\n        base._UnhandledInput(@event);\n\n        var sniperRifle = CurrentWeapon as SniperRifle;\n        if (sniperRifle == null || !sniperRifle.IsScopeActive)\n        {\n            return;\n        }\n\n        if (@event is InputEventMouseButton mouseButton)\n        {\n            if (mouseButton.Pressed)\n            {\n                if (mouseButton.ButtonIndex == MouseButton.WheelUp)\n                {\n                    sniperRifle.AdjustScopeZoom(1.0f);\n                    GetViewport().SetInputAsHandled();\n                }\n                else if (mouseButton.ButtonIndex == MouseButton.WheelDown)\n                {\n                    sniperRifle.AdjustScopeZoom(-1.0f);\n                    GetViewport().SetInputAsHandled();\n                }\n            }\n        }\n    }",
    "newString": "    public override void _UnhandledInput(InputEvent @event)\n    {\n        base._UnhandledInput(@event);\n\n        var sniperRifle = CurrentWeapon as SniperRifle;\n        if (sniperRifle == null || !sniperRifle.IsScopeActive)\n        {\n            return;\n        }\n\n        if (@event is InputEventMouseButton mouseButton)\n        {\n            if (mouseButton.Pressed)\n            {\n                if (mouseButton.ButtonIndex == MouseButton.WheelUp)\n                {\n                    sniperRifle.AdjustScopeZoom(1.0f);\n                    GetViewport().SetInputAsHandled();\n                }\n                else if (mouseButton.ButtonIndex == MouseButton.WheelDown)\n                {\n                    sniperRifle.AdjustScopeZoom(-1.0f);\n                    GetViewport().SetInputAsHandled();\n                }\n            }\n        }\n        // Handle mouse movement for scope fine-tuning (closer/further by ~1/3 viewport)\n        else if (@event is InputEventMouseMotion mouseMotion)\n        {\n            sniperRifle.AdjustScopeFineTune(mouseMotion.Relative);\n        }\n    }",
    "originalFile": "using Godot;\nusing System;\nusing System.Collections.Generic;\nusing GodotTopDownTemplate.AbstractClasses;\nusing GodotTopDownTemplate.Weapons;\nusing GodotTopdown.Scripts.Projectiles;\n\nnamespace GodotTopDownTemplate.Characters;\n\n/// <summary>\n/// Player character controller for top-down movement and shooting.\n/// Uses physics-based movement with acceleration and friction for smooth control.\n/// Supports WASD and arrow key input via configured input actions.\n/// Shoots bullets towards the mouse cursor on left mouse button.\n/// Supports both automatic (hold to fire) and semi-automatic (click per shot) weapons.\n/// Uses R-F-R key sequence for instant reload (press R, then F, then R again).\n/// Grenade throwing: G+RMB drag right ‚Üí hold G+RMB ‚Üí release G ‚Üí drag and release RMB to throw.\n/// </summary>\npublic partial class Player : BaseCharacter\n{\n    /// <summary>\n    /// Bullet scene to instantiate when shooting.\n    /// </summary>\n    [Export]\n    public PackedScene? BulletScene { get; set; }\n\n    /// <summary>\n    /// Offset from player center for bullet spawn position.\n    /// </summary>\n    [Export]\n    public float BulletSpawnOffset { get; set; } = 20.0f;\n\n    /// <summary>\n    /// Reference to the player's current weapon (optional, for weapon system).\n    /// </summary>\n    [Export]\n    public BaseWeapon? CurrentWeapon { get; set; }\n\n    /// <summary>\n    /// Color when at full health.\n    /// </summary>\n    [Export]\n    public Color FullHealthColor { get; set; } = new Color(0.2f, 0.6f, 1.0f, 1.0f);\n\n    /// <summary>\n    /// Color when at low health (interpolates based on health percentage).\n    /// </summary>\n    [Export]\n    public Color LowHealthColor { get; set; } = new Color(0.1f, 0.2f, 0.4f, 1.0f);\n\n    /// <summary>\n    /// Color to flash when hit.\n    /// </summary>\n    [Export]\n    public Color HitFlashColor { get; set; } = new Color(1.0f, 0.3f, 0.3f, 1.0f);\n\n    /// <summary>\n    /// Duration of hit flash effect in seconds.\n    /// </summary>\n    [Export]\n    public float HitFlashDuration { get; set; } = 0.1f;\n\n    /// <summary>\n    /// Grenade scene to instantiate when throwing.\n    /// </summary>\n    [Export]\n    public PackedScene? GrenadeScene { get; set; }\n\n    /// <summary>\n    /// Maximum number of grenades the player can carry.\n    /// </summary>\n    [Export]\n    public int MaxGrenades { get; set; } = 3;\n\n    /// <summary>\n    /// Reference to the player model node containing all sprites.\n    /// </summary>\n    private Node2D? _playerModel;\n\n    /// <summary>\n    /// References to individual sprite parts for color changes.\n    /// </summary>\n    private Sprite2D? _bodySprite;\n    private Sprite2D? _headSprite;\n    private Sprite2D? _leftArmSprite;\n    private Sprite2D? _rightArmSprite;\n\n    /// <summary>\n    /// Legacy reference for compatibility (points to body sprite).\n    /// </summary>\n    private Sprite2D? _sprite;\n\n    /// <summary>\n    /// Reference to the CasingPusher Area2D for detecting shell casings (Issue #392).\n    /// </summary>\n    private Area2D? _casingPusher;\n\n    /// <summary>\n    /// Force to apply to casings when pushed by player walking over them (Issue #392, #424).\n    /// Reduced by 2.5x from 50.0 to 20.0 for Issue #424.\n    /// </summary>\n    private const float CasingPushForce = 20.0f;\n\n    /// <summary>\n    /// List of casings currently overlapping with the CasingPusher Area2D (Issue #392 Iteration 8).\n    /// Uses signal-based tracking for reliable detection from all directions.\n    /// </summary>\n    private readonly System.Collections.Generic.List<RigidBody2D> _overlappingCasings = new();\n\n    /// <summary>\n    /// Current step in the reload sequence (0 = waiting for R, 1 = waiting for F, 2 = waiting for R).\n    /// </summary>\n    private int _reloadSequenceStep = 0;\n\n    /// <summary>\n    /// Whether the player is currently in a reload sequence.\n    /// </summary>\n    private bool _isReloadingSequence = false;\n\n    /// <summary>\n    /// Tracks ammo count when reload sequence started (at step 1 after R pressed).\n    /// Used to determine if there was a bullet in the chamber.\n    /// </summary>\n    private int _ammoAtReloadStart = 0;\n\n    /// <summary>\n    /// Current number of grenades.\n    /// </summary>\n    private int _currentGrenades = 3;\n\n    /// <summary>\n    /// Whether the player is on the tutorial level (infinite grenades).\n    /// </summary>\n    private bool _isTutorialLevel = false;\n\n    /// <summary>\n    /// Grenade state machine states.\n    /// 2-step mechanic:\n    /// Step 1: G + RMB drag right ‚Üí timer starts (pin pulled)\n    /// Step 2: Hold G ‚Üí press+hold RMB ‚Üí release G ‚Üí ready to throw (only RMB held)\n    /// Step 3: Drag and release RMB ‚Üí throw grenade\n    /// </summary>\n    private enum GrenadeState\n    {\n        Idle,           // No grenade action\n        TimerStarted,   // Step 1 complete - grenade timer running, G held, waiting for RMB\n        WaitingForGRelease, // Step 2 in progress - G+RMB held, waiting for G release\n        Aiming,         // Step 2 complete - only RMB held, waiting for drag and release to throw\n        SimpleAiming    // Simple mode: RMB held, showing trajectory preview\n    }\n\n    /// <summary>\n    /// Current grenade state.\n    /// </summary>\n    private GrenadeState _grenadeState = GrenadeState.Idle;\n\n    /// <summary>\n    /// Active grenade instance (created when timer starts).\n    /// </summary>\n    private RigidBody2D? _activeGrenade = null;\n\n    /// <summary>\n    /// Position where the grenade throw drag started.\n    /// </summary>\n    private Vector2 _grenadeDragStart = Vector2.Zero;\n\n    /// <summary>\n    /// Whether the grenade throw drag is active (for step 1).\n    /// </summary>\n    private bool _grenadeDragActive = false;\n\n    /// <summary>\n    /// Minimum drag distance to confirm step 1 (in pixels).\n    /// </summary>\n    private const float MinDragDistanceForStep1 = 30.0f;\n\n    /// <summary>\n    /// Position where aiming started (for simple mode trajectory).\n    /// </summary>\n    private Vector2 _aimDragStart = Vector2.Zero;\n\n    /// <summary>\n    /// Timestamp when grenade timer was started.\n    /// </summary>\n    private double _grenadeTimerStartTime = 0.0;\n\n    /// <summary>\n    /// Whether player is currently preparing to throw a grenade (for animations).\n    /// </summary>\n    private bool _isPreparingGrenade = false;\n\n    /// <summary>\n    /// Player's rotation before throw (to restore after throw animation).\n    /// </summary>\n    private float _playerRotationBeforeThrow = 0.0f;\n\n    /// <summary>\n    /// Whether player is in throw rotation animation.\n    /// </summary>\n    private bool _isThrowRotating = false;\n\n    /// <summary>\n    /// Whether debug mode is enabled (F7 toggle, shows grenade trajectory).\n    /// </summary>\n    private bool _debugModeEnabled = false;\n\n    /// <summary>\n    /// Whether invincibility mode is enabled (F6 toggle, player takes no damage).\n    /// </summary>\n    private bool _invincibilityEnabled = false;\n\n    /// <summary>\n    /// Label for displaying invincibility mode indicator.\n    /// </summary>\n    private Label? _invincibilityLabel = null;\n\n    /// <summary>\n    /// Target rotation for throw animation.\n    /// </summary>\n    private float _throwTargetRotation = 0.0f;\n\n    /// <summary>\n    /// Time remaining for throw rotation to restore.\n    /// </summary>\n    private float _throwRotationRestoreTimer = 0.0f;\n\n    /// <summary>\n    /// Duration of throw rotation animation.\n    /// </summary>\n    private const float ThrowRotationDuration = 0.15f;\n\n    #region Weapon Pose Detection\n\n    /// <summary>\n    /// Weapon types for arm positioning.\n    /// </summary>\n    private enum WeaponType\n    {\n        Rifle,      // Default - extended grip (e.g., AssaultRifle)\n        SMG,        // Compact grip (e.g., MiniUzi)\n        Shotgun,    // Similar to rifle but slightly tighter\n        Pistol      // Compact one-handed/two-handed pistol grip (e.g., SilencedPistol)\n    }\n\n    /// <summary>\n    /// Currently detected weapon type.\n    /// </summary>\n    private WeaponType _currentWeaponType = WeaponType.Rifle;\n\n    /// <summary>\n    /// Whether weapon pose has been detected and applied.\n    /// </summary>\n    private bool _weaponPoseApplied = false;\n\n    /// <summary>\n    /// Frame counter for delayed weapon pose detection.\n    /// Weapons are added by level scripts AFTER player's _Ready() completes.\n    /// </summary>\n    private int _weaponDetectFrameCount = 0;\n\n    /// <summary>\n    /// Number of frames to wait before detecting weapon pose.\n    /// This ensures level scripts have finished adding weapons.\n    /// </summary>\n    private const int WeaponDetectWaitFrames = 3;\n\n    /// <summary>\n    /// Arm position offset for SMG weapons - left arm moves back toward body.\n    /// UZI and similar compact SMGs should have the left arm closer to the body\n    /// for a proper two-handed compact grip.\n    /// </summary>\n    private static readonly Vector2 SmgLeftArmOffset = new Vector2(-10, 0);\n\n    /// <summary>\n    /// Arm position offset for SMG weapons - right arm moves slightly forward.\n    /// </summary>\n    private static readonly Vector2 SmgRightArmOffset = new Vector2(3, 0);\n\n    #endregion\n\n    #region Walking Animation\n\n    /// <summary>\n    /// Walking animation speed multiplier - higher = faster leg cycle.\n    /// </summary>\n    [Export]\n    public float WalkAnimSpeed { get; set; } = 12.0f;\n\n    /// <summary>\n    /// Scale multiplier for the player model (body, head, arms).\n    /// Default is 1.3 to make the player slightly larger.\n    /// </summary>\n    [Export]\n    public float PlayerModelScale { get; set; } = 1.3f;\n\n    /// <summary>\n    /// Walking animation intensity - higher = more pronounced movement.\n    /// </summary>\n    [Export]\n    public float WalkAnimIntensity { get; set; } = 1.0f;\n\n    /// <summary>\n    /// Current walk animation time (accumulator for sine wave).\n    /// </summary>\n    private float _walkAnimTime = 0.0f;\n\n    /// <summary>\n    /// Whether the player is currently walking (for animation state).\n    /// </summary>\n    private bool _isWalking = false;\n\n    /// <summary>\n    /// Base positions for body parts (stored on ready for animation offsets).\n    /// </summary>\n    private Vector2 _baseBodyPos = Vector2.Zero;\n    private Vector2 _baseHeadPos = Vector2.Zero;\n    private Vector2 _baseLeftArmPos = Vector2.Zero;\n    private Vector2 _baseRightArmPos = Vector2.Zero;\n\n    #endregion\n\n    #region Reload Animation System\n\n    /// <summary>\n    /// Animation phases for assault rifle reload sequence.\n    /// Maps to the R-F-R input system for visual feedback.\n    /// Three steps as requested:\n    /// 1. Take magazine with left hand from chest\n    /// 2. Insert magazine into rifle\n    /// 3. Pull the bolt/charging handle\n    /// </summary>\n    private enum ReloadAnimPhase\n    {\n        None,           // Normal arm positions (weapon held)\n        GrabMagazine,   // Step 1: Left hand moves to chest to grab new magazine\n        InsertMagazine, // Step 2: Left hand brings magazine to weapon, inserts it\n        PullBolt,       // Step 3: Character pulls the charging handle\n        ReturnIdle      // Arms return to normal weapon-holding position\n    }\n\n    /// <summary>\n    /// Current reload animation phase.\n    /// </summary>\n    private ReloadAnimPhase _reloadAnimPhase = ReloadAnimPhase.None;\n\n    /// <summary>\n    /// Reload animation phase timer for timed transitions.\n    /// </summary>\n    private float _reloadAnimTimer = 0.0f;\n\n    /// <summary>\n    /// Reload animation phase duration in seconds.\n    /// </summary>\n    private float _reloadAnimDuration = 0.0f;\n\n    // Target positions for reload arm animations (relative offsets from base positions)\n    // These are in local PlayerModel space\n    // Base positions: LeftArm (24, 6), RightArm (-2, 6)\n    // For reload, left arm goes to chest (vest/mag pouch area), then to weapon\n\n    // Step 1: Grab magazine from chest - left arm moves toward body center\n    // Base position: LeftArm (24, 6). We want target around (4, 2) = body/chest area\n    // So offset should be (4-24, 2-6) = (-20, -4)\n    // User feedback: previous -40 was too far (went behind back), -18 was not visible enough\n    private static readonly Vector2 ReloadArmLeftGrab = new Vector2(-20, -4);      // Left hand at chest/vest mag pouch (visible but not behind back)\n    private static readonly Vector2 ReloadArmRightHold = new Vector2(0, 0);        // Right hand stays on weapon grip\n\n    // Step 2: Insert magazine - left arm moves to weapon magwell (at middle of weapon, not at the end)\n    // Weapon length: ~40 pixels from center, magwell at middle\n    // Base (24, 6), want target around (12, 6) = middle of weapon, so offset (-12, 0)\n    private static readonly Vector2 ReloadArmLeftInsert = new Vector2(-12, 0);     // Left hand at weapon magwell (middle of weapon)\n    private static readonly Vector2 ReloadArmRightSteady = new Vector2(0, 2);      // Right hand steadies weapon\n\n    // Step 3: Pull bolt - right arm moves along rifle contour (back and forth motion)\n    // The right hand should trace the rifle's right side: forward, then back to pull bolt, then release\n    // Base RightArm (-2, 6). For dramatic motion: forward (+10, +2), back (-10, -4)\n    private static readonly Vector2 ReloadArmLeftSupport = new Vector2(-10, 0);    // Left hand holds near magwell\n    private static readonly Vector2 ReloadArmRightBoltStart = new Vector2(10, 2);  // Right hand at charging handle (forward on rifle)\n    private static readonly Vector2 ReloadArmRightBoltPull = new Vector2(-12, -4); // Right hand pulls bolt back (toward player)\n    private static readonly Vector2 ReloadArmRightBoltReturn = new Vector2(10, 2); // Right hand returns forward (bolt release)\n\n    // Target rotations for reload arm animations (in degrees)\n    private const float ReloadArmRotLeftGrab = -50.0f;     // Arm rotation when grabbing mag from chest\n    private const float ReloadArmRotRightHold = 0.0f;      // Right arm steady during grab\n    private const float ReloadArmRotLeftInsert = -15.0f;   // Left arm rotation when inserting\n    private const float ReloadArmRotRightSteady = 5.0f;    // Slight tilt while steadying\n    private const float ReloadArmRotLeftSupport = -10.0f;  // Left arm on foregrip/magwell\n    private const float ReloadArmRotRightBoltStart = -10.0f;  // Right arm at bolt handle\n    private const float ReloadArmRotRightBoltPull = -35.0f;   // Right arm rotation when pulling bolt back\n    private const float ReloadArmRotRightBoltReturn = -10.0f; // Right arm rotation when releasing bolt\n\n    // Animation durations for each reload phase (in seconds)\n    // INCREASED bolt durations for visible back-and-forth motion\n    private const float ReloadAnimGrabDuration = 0.25f;    // Time to grab magazine from chest\n    private const float ReloadAnimInsertDuration = 0.3f;   // Time to insert magazine\n    private const float ReloadAnimBoltPullDuration = 0.35f;   // Time to pull bolt back (increased for visibility)\n    private const float ReloadAnimBoltReturnDuration = 0.25f; // Time for bolt to return forward (increased for visibility)\n    private const float ReloadAnimReturnDuration = 0.2f;   // Time to return to idle\n\n    /// <summary>\n    /// Sub-phase for bolt pull animation (0 = pulling, 1 = returning)\n    /// </summary>\n    private int _boltPullSubPhase = 0;\n\n    #endregion\n\n    #region Grenade Animation System\n\n    /// <summary>\n    /// Animation phases for grenade throwing sequence.\n    /// Maps to the multi-step input system for visual feedback.\n    /// </summary>\n    private enum GrenadeAnimPhase\n    {\n        None,           // Normal arm positions (walking/idle)\n        GrabGrenade,    // Left hand moves to chest to grab grenade\n        PullPin,        // Right hand pulls pin (quick snap animation)\n        HandsApproach,  // Right hand moves toward left hand\n        Transfer,       // Grenade transfers to right hand\n        WindUp,         // Dynamic wind-up based on drag\n        Throw,          // Throwing motion\n        ReturnIdle      // Arms return to normal positions\n    }\n\n    /// <summary>\n    /// Current grenade animation phase.\n    /// </summary>\n    private GrenadeAnimPhase _grenadeAnimPhase = GrenadeAnimPhase.None;\n\n    /// <summary>\n    /// Animation phase timer for timed transitions.\n    /// </summary>\n    private float _grenadeAnimTimer = 0.0f;\n\n    /// <summary>\n    /// Animation phase duration in seconds.\n    /// </summary>\n    private float _grenadeAnimDuration = 0.0f;\n\n    /// <summary>\n    /// Current wind-up intensity (0.0 = no wind-up, 1.0 = maximum wind-up).\n    /// </summary>\n    private float _windUpIntensity = 0.0f;\n\n    /// <summary>\n    /// Previous mouse position for velocity calculation.\n    /// </summary>\n    private Vector2 _prevMousePos = Vector2.Zero;\n\n    /// <summary>\n    /// Mouse velocity history for smooth velocity calculation (stores last N velocities).\n    /// Used to get stable velocity at moment of release.\n    /// </summary>\n    private List<Vector2> _mouseVelocityHistory = new List<Vector2>();\n\n    /// <summary>\n    /// Maximum number of velocity samples to keep in history.\n    /// </summary>\n    private const int MouseVelocityHistorySize = 5;\n\n    /// <summary>\n    /// Current calculated mouse velocity (pixels per second).\n    /// </summary>\n    private Vector2 _currentMouseVelocity = Vector2.Zero;\n\n    /// <summary>\n    /// Total swing distance traveled during aiming (for momentum transfer calculation).\n    /// </summary>\n    private float _totalSwingDistance = 0.0f;\n\n    /// <summary>\n    /// Previous frame time for delta calculation in velocity tracking.\n    /// </summary>\n    private double _prevFrameTime = 0.0;\n\n    /// <summary>\n    /// Whether weapon is in sling position (lowered for grenade handling).\n    /// </summary>\n    private bool _weaponSlung = false;\n\n    /// <summary>\n    /// Reference to weapon mount for sling animation.\n    /// </summary>\n    private Node2D? _weaponMount;\n\n    /// <summary>\n    /// Base weapon mount position (for sling animation).\n    /// </summary>\n    private Vector2 _baseWeaponMountPos = Vector2.Zero;\n\n    /// <summary>\n    /// Base weapon mount rotation (for sling animation).\n    /// </summary>\n    private float _baseWeaponMountRot = 0.0f;\n\n    // Target positions for arm animations (relative offsets from base positions)\n    // These are in local PlayerModel space\n    // Base positions: LeftArm (24, 6), RightArm (-2, 6)\n    // Body position: (-4, 0), so left shoulder area is approximately x=0 to x=5\n    // To move left arm from x=24 to shoulder (x~5), we need offset of ~-20\n    // During grenade operations, left arm should be BEHIND the body (toward shoulder)\n    // not holding the weapon at the front\n    private static readonly Vector2 ArmLeftChest = new Vector2(-15, 0);        // Left hand moves back to chest/shoulder area to grab grenade\n    private static readonly Vector2 ArmRightPin = new Vector2(2, -2);          // Right hand slightly up for pin pull\n    private static readonly Vector2 ArmLeftExtended = new Vector2(-10, 2);     // Left hand at chest level with grenade (not extended forward)\n    private static readonly Vector2 ArmRightApproach = new Vector2(4, 0);      // Right hand approaching left\n    private static readonly Vector2 ArmLeftTransfer = new Vector2(-12, 3);     // Left hand drops back after transfer (clearly away from weapon)\n    private static readonly Vector2 ArmRightHold = new Vector2(3, 1);          // Right hand holding grenade\n    private static readonly Vector2 ArmRightWindMin = new Vector2(4, 3);       // Minimum wind-up position (arm back)\n    private static readonly Vector2 ArmRightWindMax = new Vector2(8, 5);       // Maximum wind-up position (arm further back)\n    private static readonly Vector2 ArmRightThrow = new Vector2(-4, -2);       // Throw follow-through (arm forward)\n    private static readonly Vector2 ArmLeftRelaxed = new Vector2(-20, 2);      // Left arm at shoulder/body - well away from weapon during wind-up/throw\n\n    // Target rotations for arm animations (in degrees)\n    // When left arm moves back to shoulder position, rotate to point \"down\" relative to body\n    // This makes the arm look like it's hanging at the side rather than reaching forward\n    private const float ArmRotGrab = -45.0f;         // Arm rotation when grabbing at chest (points inward/down)\n    private const float ArmRotPinPull = -15.0f;      // Right arm rotation when pulling pin\n    private const float ArmRotLeftAtChest = -30.0f;  // Left arm rotation while holding grenade at chest\n    private const float ArmRotWindMin = 15.0f;       // Right arm minimum wind-up rotation\n    private const float ArmRotWindMax = 35.0f;       // Right arm maximum wind-up rotation\n    private const float ArmRotThrow = -25.0f;        // Right arm throw rotation (swings forward)\n    private const float ArmRotLeftRelaxed = -60.0f;  // Left arm hangs down at side during wind-up/throw (points backward)\n\n    // Animation durations for each phase (in seconds)\n    private const float AnimGrabDuration = 0.2f;\n    private const float AnimPinDuration = 0.15f;\n    private const float AnimApproachDuration = 0.2f;\n    private const float AnimTransferDuration = 0.15f;\n    private const float AnimThrowDuration = 0.2f;\n    private const float AnimReturnDuration = 0.3f;\n\n    // Animation lerp speeds\n    private const float AnimLerpSpeed = 15.0f;        // Position interpolation speed\n    private const float AnimLerpSpeedFast = 25.0f;    // Fast interpolation for snappy movements\n\n    // Weapon sling position (lowered and rotated for chest carry)\n    private static readonly Vector2 WeaponSlingOffset = new Vector2(0, 15);    // Lower weapon\n    private const float WeaponSlingRotation = 1.2f;   // Rotate to hang down (radians, ~70 degrees)\n\n    #endregion\n\n    /// <summary>\n    /// Signal emitted when reload sequence progresses.\n    /// </summary>\n    [Signal]\n    public delegate void ReloadSequenceProgressEventHandler(int step, int total);\n\n    /// <summary>\n    /// Signal emitted when reload completes.\n    /// </summary>\n    [Signal]\n    public delegate void ReloadCompletedEventHandler();\n\n    /// <summary>\n    /// Signal emitted when reload starts (first step of sequence).\n    /// This signal notifies enemies that the player has begun reloading.\n    /// </summary>\n    [Signal]\n    public delegate void ReloadStartedEventHandler();\n\n    /// <summary>\n    /// Signal emitted when player tries to shoot with empty weapon.\n    /// This signal notifies enemies that the player is out of ammo.\n    /// </summary>\n    [Signal]\n    public delegate void AmmoDepletedEventHandler();\n\n    /// <summary>\n    /// Signal emitted when grenade count changes.\n    /// </summary>\n    [Signal]\n    public delegate void GrenadeChangedEventHandler(int current, int maximum);\n\n    /// <summary>\n    /// Signal emitted when a grenade is thrown.\n    /// </summary>\n    [Signal]\n    public delegate void GrenadeThrownEventHandler();\n\n    public override void _Ready()\n    {\n        base._Ready();\n\n        // Get player model and sprite references for visual feedback\n        _playerModel = GetNodeOrNull<Node2D>(\"PlayerModel\");\n        if (_playerModel != null)\n        {\n            _bodySprite = _playerModel.GetNodeOrNull<Sprite2D>(\"Body\");\n            _headSprite = _playerModel.GetNodeOrNull<Sprite2D>(\"Head\");\n            _leftArmSprite = _playerModel.GetNodeOrNull<Sprite2D>(\"LeftArm\");\n            _rightArmSprite = _playerModel.GetNodeOrNull<Sprite2D>(\"RightArm\");\n            // Legacy compatibility - _sprite points to body\n            _sprite = _bodySprite;\n        }\n        else\n        {\n            // Fallback to old single sprite structure for compatibility\n            _sprite = GetNodeOrNull<Sprite2D>(\"Sprite2D\");\n        }\n\n        // Configure health based on difficulty\n        if (HealthComponent != null)\n        {\n            // Check if Power Fantasy mode is active for special health configuration\n            var difficultyManager = GetNodeOrNull(\"/root/DifficultyManager\");\n            bool isPowerFantasy = difficultyManager != null && (bool)difficultyManager.Call(\"is_power_fantasy_mode\");\n\n            if (isPowerFantasy)\n            {\n                // Power Fantasy mode: 10 HP (fixed, not random)\n                HealthComponent.UseRandomHealth = false;\n                HealthComponent.MaxHealth = 10;\n                HealthComponent.InitialHealth = 10;\n                HealthComponent.InitializeHealth();\n                GD.Print($\"[Player] {Name}: Power Fantasy mode - spawned with {HealthComponent.CurrentHealth}/{HealthComponent.MaxHealth} HP\");\n            }\n            else\n            {\n                // Normal difficulties: random health (2-4 HP)\n                HealthComponent.UseRandomHealth = true;\n                HealthComponent.MinRandomHealth = 2;\n                HealthComponent.MaxRandomHealth = 4;\n                HealthComponent.InitializeHealth();\n                GD.Print($\"[Player] {Name}: Spawned with health {HealthComponent.CurrentHealth}/{HealthComponent.MaxHealth}\");\n            }\n\n            // Connect to health changed signal for visual feedback\n            HealthComponent.HealthChanged += OnPlayerHealthChanged;\n        }\n\n        // Update visual based on initial health\n        UpdateHealthVisual();\n\n        // Preload bullet scene if not set in inspector\n        if (BulletScene == null)\n        {\n            // Try C# bullet scene first, fallback to GDScript version\n            BulletScene = GD.Load<PackedScene>(\"res://scenes/projectiles/csharp/Bullet.tscn\");\n            if (BulletScene == null)\n            {\n                BulletScene = GD.Load<PackedScene>(\"res://scenes/projectiles/Bullet.tscn\");\n            }\n        }\n\n        // Get grenade scene from GrenadeManager (supports grenade type selection)\n        // GrenadeManager handles the currently selected grenade type (Flashbang or Frag)\n        if (GrenadeScene == null)\n        {\n            var grenadeManager = GetNodeOrNull(\"/root/GrenadeManager\");\n            if (grenadeManager != null && grenadeManager.HasMethod(\"get_current_grenade_scene\"))\n            {\n                var sceneVariant = grenadeManager.Call(\"get_current_grenade_scene\");\n                GrenadeScene = sceneVariant.As<PackedScene>();\n                if (GrenadeScene != null)\n                {\n                    var grenadeNameVariant = grenadeManager.Call(\"get_grenade_name\", grenadeManager.Get(\"current_grenade_type\"));\n                    var grenadeName = grenadeNameVariant.AsString();\n                    LogToFile($\"[Player.Grenade] Grenade scene loaded from GrenadeManager: {grenadeName}\");\n                }\n                else\n                {\n                    LogToFile($\"[Player.Grenade] WARNING: GrenadeManager returned null grenade scene\");\n                }\n            }\n            else\n            {\n                // Fallback to flashbang if GrenadeManager is not available\n                var grenadePath = \"res://scenes/projectiles/FlashbangGrenade.tscn\";\n                GrenadeScene = GD.Load<PackedScene>(grenadePath);\n                if (GrenadeScene != null)\n                {\n                    LogToFile($\"[Player.Grenade] Grenade scene loaded from fallback: {grenadePath}\");\n                }\n                else\n                {\n                    LogToFile($\"[Player.Grenade] WARNING: Grenade scene not found at {grenadePath}\");\n                }\n            }\n        }\n        else\n        {\n            LogToFile($\"[Player.Grenade] Grenade scene already set in inspector\");\n        }\n\n        // Detect if we're on the tutorial level\n        // Tutorial level is: scenes/levels/csharp/TestTier.tscn with tutorial_level.gd script\n        var currentScene = GetTree().CurrentScene;\n        if (currentScene != null)\n        {\n            var scenePath = currentScene.SceneFilePath;\n            // Tutorial level is detected by:\n            // 1. Scene path contains \"csharp/TestTier\" (the tutorial scene)\n            // 2. OR scene uses tutorial_level.gd script\n            _isTutorialLevel = scenePath.Contains(\"csharp/TestTier\");\n\n            // Also check if the scene script is tutorial_level.gd\n            var script = currentScene.GetScript();\n            if (script.Obj is GodotObject scriptObj)\n            {\n                var scriptPath = scriptObj.Get(\"resource_path\").AsString();\n                if (scriptPath.Contains(\"tutorial_level\"))\n                {\n                    _isTutorialLevel = true;\n                }\n            }\n        }\n\n        // Initialize grenade count based on level type\n        // Tutorial: infinite grenades (max count)\n        // Other levels: 1 grenade\n        if (_isTutorialLevel)\n        {\n            _currentGrenades = MaxGrenades;\n            LogToFile($\"[Player.Grenade] Tutorial level detected - infinite grenades enabled\");\n        }\n        else\n        {\n            _currentGrenades = 1;\n            LogToFile($\"[Player.Grenade] Normal level - starting with 1 grenade\");\n        }\n\n        // Auto-equip weapon if not set but a weapon child exists\n        if (CurrentWeapon == null)\n        {\n            CurrentWeapon = GetNodeOrNull<BaseWeapon>(\"AssaultRifle\");\n            if (CurrentWeapon != null)\n            {\n                GD.Print($\"[Player] {Name}: Auto-equipped weapon {CurrentWeapon.Name}\");\n            }\n        }\n\n        // Store base positions for walking animation\n        if (_bodySprite != null)\n        {\n            _baseBodyPos = _bodySprite.Position;\n            LogToFile($\"[Player.Init] Body sprite found at position: {_baseBodyPos}\");\n        }\n        else\n        {\n            LogToFile(\"[Player.Init] WARNING: Body sprite NOT found!\");\n        }\n        if (_headSprite != null)\n        {\n            _baseHeadPos = _headSprite.Position;\n            LogToFile($\"[Player.Init] Head sprite found at position: {_baseHeadPos}\");\n        }\n        else\n        {\n            LogToFile(\"[Player.Init] WARNING: Head sprite NOT found!\");\n        }\n        if (_leftArmSprite != null)\n        {\n            _baseLeftArmPos = _leftArmSprite.Position;\n            LogToFile($\"[Player.Init] Left arm sprite found at position: {_baseLeftArmPos}\");\n        }\n        else\n        {\n            LogToFile(\"[Player.Init] WARNING: Left arm sprite NOT found!\");\n        }\n        if (_rightArmSprite != null)\n        {\n            _baseRightArmPos = _rightArmSprite.Position;\n            LogToFile($\"[Player.Init] Right arm sprite found at position: {_baseRightArmPos}\");\n        }\n        else\n        {\n            LogToFile(\"[Player.Init] WARNING: Right arm sprite NOT found!\");\n        }\n\n        // Apply scale to player model for larger appearance\n        if (_playerModel != null)\n        {\n            _playerModel.Scale = new Vector2(PlayerModelScale, PlayerModelScale);\n        }\n\n        // Get weapon mount reference for sling animation\n        _weaponMount = _playerModel?.GetNodeOrNull<Node2D>(\"WeaponMount\");\n        if (_weaponMount != null)\n        {\n            _baseWeaponMountPos = _weaponMount.Position;\n            _baseWeaponMountRot = _weaponMount.Rotation;\n        }\n\n        // Set z-index for proper layering: head should be above weapon\n        // The weapon has z_index = 1, so head should be 2 or higher\n        if (_headSprite != null)\n        {\n            _headSprite.ZIndex = 3;  // Head on top (above weapon)\n        }\n        if (_bodySprite != null)\n        {\n            _bodySprite.ZIndex = 1;  // Body same level as weapon\n        }\n        if (_leftArmSprite != null)\n        {\n            _leftArmSprite.ZIndex = 2;  // Arms between body and head\n        }\n        if (_rightArmSprite != null)\n        {\n            _rightArmSprite.ZIndex = 2;  // Arms between body and head\n        }\n\n        // Connect to GameManager's debug mode signal for F7 toggle\n        ConnectDebugModeSignal();\n\n        // Initialize CasingPusher Area2D for pushing shell casings (Issue #392 Iteration 8)\n        ConnectCasingPusherSignals();\n\n        // Log ready status with full info\n        int currentAmmo = CurrentWeapon?.CurrentAmmo ?? 0;\n        int maxAmmo = CurrentWeapon?.WeaponData?.MagazineSize ?? 0;\n        int currentHealth = (int)(HealthComponent?.CurrentHealth ?? 0);\n        int maxHealth = (int)(HealthComponent?.MaxHealth ?? 0);\n        LogToFile($\"[Player] Ready! Ammo: {currentAmmo}/{maxAmmo}, Grenades: {_currentGrenades}/{MaxGrenades}, Health: {currentHealth}/{maxHealth}\");\n        LogToFile(\"[Player.Grenade] Throwing system: VELOCITY-BASED (v2.0 - mouse velocity at release)\");\n    }\n\n    /// <summary>\n    /// Called when player health changes - updates visual feedback.\n    /// </summary>\n    private void OnPlayerHealthChanged(float currentHealth, float maxHealth)\n    {\n        GD.Print($\"[Player] {Name}: Health changed to {currentHealth}/{maxHealth} ({HealthComponent?.HealthPercent * 100:F0}%)\");\n        UpdateHealthVisual();\n    }\n\n    /// <summary>\n    /// Updates the sprite color based on current health percentage.\n    /// </summary>\n    private void UpdateHealthVisual()\n    {\n        if (HealthComponent == null)\n        {\n            return;\n        }\n\n        // Interpolate color based on health percentage\n        float healthPercent = HealthComponent.HealthPercent;\n        Color color = FullHealthColor.Lerp(LowHealthColor, 1.0f - healthPercent);\n        SetAllSpritesModulate(color);\n    }\n\n    /// <summary>\n    /// Public method to refresh the health visual.\n    /// Called by effects managers (like LastChanceEffectsManager) after they finish\n    /// modifying player sprite colors, to ensure the player returns to correct\n    /// health-based coloring.\n    /// </summary>\n    public void RefreshHealthVisual()\n    {\n        UpdateHealthVisual();\n    }\n\n    /// <summary>\n    /// Sets the modulate color on all player sprite parts.\n    /// The armband is a separate sibling sprite (not child of RightArm) that keeps\n    /// its original color, so all body parts use the same health-based color.\n    /// </summary>\n    /// <param name=\"color\">The color to apply to all sprites.</param>\n    private void SetAllSpritesModulate(Color color)\n    {\n        if (_bodySprite != null)\n        {\n            _bodySprite.Modulate = color;\n        }\n        if (_headSprite != null)\n        {\n            _headSprite.Modulate = color;\n        }\n        if (_leftArmSprite != null)\n        {\n            _leftArmSprite.Modulate = color;\n        }\n        if (_rightArmSprite != null)\n        {\n            // Right arm uses the same color as other body parts.\n            // The armband is now a separate sibling sprite (Armband node under PlayerModel)\n            // that doesn't inherit this modulate, keeping its bright red color visible.\n            _rightArmSprite.Modulate = color;\n        }\n        // If using old single sprite structure\n        if (_playerModel == null && _sprite != null)\n        {\n            _sprite.Modulate = color;\n        }\n    }\n\n    #region Casing Pusher (Issue #392)\n\n    /// <summary>\n    /// Connects the CasingPusher Area2D signals for reliable casing detection (Issue #392 Iteration 8).\n    /// Using body_entered/body_exited signals instead of polling get_overlapping_bodies()\n    /// ensures casings are detected even when player approaches from narrow side.\n    /// </summary>\n    private void ConnectCasingPusherSignals()\n    {\n        _casingPusher = GetNodeOrNull<Area2D>(\"CasingPusher\");\n        if (_casingPusher == null)\n        {\n            // CasingPusher not present in scene - this is fine for older scenes\n            return;\n        }\n\n        // Connect body_entered and body_exited signals\n        _casingPusher.BodyEntered += OnCasingPusherBodyEntered;\n        _casingPusher.BodyExited += OnCasingPusherBodyExited;\n    }\n\n    /// <summary>\n    /// Called when a body enters the CasingPusher Area2D.\n    /// Tracks casings for reliable pushing detection.\n    /// </summary>\n    private void OnCasingPusherBodyEntered(Node2D body)\n    {\n        if (body is RigidBody2D rigidBody && rigidBody.HasMethod(\"receive_kick\"))\n        {\n            if (!_overlappingCasings.Contains(rigidBody))\n            {\n                _overlappingCasings.Add(rigidBody);\n            }\n        }\n    }\n\n    /// <summary>\n    /// Called when a body exits the CasingPusher Area2D.\n    /// Removes casings from tracking list.\n    /// </summary>\n    private void OnCasingPusherBodyExited(Node2D body)\n    {\n        if (body is RigidBody2D rigidBody)\n        {\n            _overlappingCasings.Remove(rigidBody);\n        }\n    }\n\n    /// <summary>\n    /// Pushes casings that we're overlapping with using Area2D detection (Issue #392 Iteration 8).\n    /// Uses signal-tracked casings combined with polling for maximum reliability.\n    /// </summary>\n    private void PushCasingsWithArea2D()\n    {\n        if (_casingPusher == null)\n        {\n            return;\n        }\n\n        // Don't push if not moving\n        if (Velocity.LengthSquared() < 1.0f)\n        {\n            return;\n        }\n\n        // Combine both signal-tracked casings and polled overlapping bodies for reliability\n        var casingsToPush = new System.Collections.Generic.HashSet<RigidBody2D>();\n\n        // Add signal-tracked casings\n        foreach (var casing in _overlappingCasings)\n        {\n            if (IsInstanceValid(casing))\n            {\n                casingsToPush.Add(casing);\n            }\n        }\n\n        // Also poll for any casings that might have been missed by signals\n        foreach (var body in _casingPusher.GetOverlappingBodies())\n        {\n            if (body is RigidBody2D rigidBody && rigidBody.HasMethod(\"receive_kick\"))\n            {\n                casingsToPush.Add(rigidBody);\n            }\n        }\n\n        // Push all detected casings\n        foreach (var casing in casingsToPush)\n        {\n            // Calculate push direction from player center to casing position (Issue #424)\n            // This makes casings fly away based on which side they're pushed from\n            var pushDir = (casing.GlobalPosition - GlobalPosition).Normalized();\n            var pushStrength = Velocity.Length() * CasingPushForce / 100.0f;\n            var impulse = pushDir * pushStrength;\n            casing.Call(\"receive_kick\", impulse);\n        }\n    }\n\n    #endregion\n\n    public override void _PhysicsProcess(double delta)\n    {\n        // Detect weapon pose after waiting a few frames for level scripts to add weapons\n        if (!_weaponPoseApplied)\n        {\n            _weaponDetectFrameCount++;\n            if (_weaponDetectFrameCount >= WeaponDetectWaitFrames)\n            {\n                DetectAndApplyWeaponPose();\n                _weaponPoseApplied = true;\n            }\n        }\n\n        Vector2 inputDirection = GetInputDirection();\n        ApplyMovement(inputDirection, (float)delta);\n\n        // Push any casings we're overlapping with using Area2D detection (Issue #392 Iteration 8)\n        PushCasingsWithArea2D();\n\n        // Update player model rotation to face the aim direction (rifle direction)\n        UpdatePlayerModelRotation();\n\n        // Update walking animation based on movement (only if not in grenade or reload animation)\n        if (_grenadeAnimPhase == GrenadeAnimPhase.None && _reloadAnimPhase == ReloadAnimPhase.None)\n        {\n            UpdateWalkAnimation((float)delta, inputDirection);\n        }\n\n        // Update grenade animation\n        UpdateGrenadeAnimation((float)delta);\n\n        // Update reload animation\n        UpdateReloadAnimation((float)delta);\n\n        // Handle throw rotation animation (restore player rotation after throw)\n        HandleThrowRotationAnimation((float)delta);\n\n        // Handle sniper scope input (RMB) when SniperRifle is equipped\n        // This takes priority over grenade input since the sniper uses RMB for scoping\n        bool sniperScopeConsumedInput = HandleSniperScopeInput();\n\n        // Handle grenade input first (so it can consume shoot input)\n        // Skip if sniper scope already consumed the RMB input\n        if (!sniperScopeConsumedInput)\n        {\n            HandleGrenadeInput();\n        }\n\n        // Make active grenade follow player if held\n        if (_activeGrenade != null && IsInstanceValid(_activeGrenade))\n        {\n            _activeGrenade.GlobalPosition = GlobalPosition;\n        }\n\n        // Handle shooting input - support both automatic and semi-automatic weapons\n        // Allow shooting when not in grenade preparation\n        // In simple mode, RMB is for grenades so only LMB (shoot) should work\n        bool canShoot = _grenadeState == GrenadeState.Idle || _grenadeState == GrenadeState.TimerStarted || _grenadeState == GrenadeState.SimpleAiming;\n        if (canShoot)\n        {\n            HandleShootingInput();\n        }\n\n        // Handle reload sequence input (R-F-R)\n        HandleReloadSequenceInput();\n\n        // Handle fire mode toggle (B key for burst/auto toggle)\n        if (Input.IsActionJustPressed(\"toggle_fire_mode\"))\n        {\n            ToggleFireMode();\n        }\n    }\n\n    /// <summary>\n    /// Handles shooting input based on weapon type.\n    /// For automatic weapons: fires while held.\n    /// For semi-automatic/burst: fires on press.\n    /// Also handles bullet in chamber mechanics during reload sequence.\n    /// </summary>\n    private void HandleShootingInput()\n    {\n        if (CurrentWeapon == null)\n        {\n            // Fallback to original click-to-shoot behavior\n            if (Input.IsActionJustPressed(\"shoot\"))\n            {\n                Shoot();\n            }\n            return;\n        }\n\n        // Check if weapon is automatic (based on WeaponData)\n        bool isAutomatic = CurrentWeapon.WeaponData?.IsAutomatic ?? false;\n\n        // For AssaultRifle, also check if it's in automatic fire mode\n        if (CurrentWeapon is AssaultRifle assaultRifle)\n        {\n            isAutomatic = assaultRifle.CurrentFireMode == FireMode.Automatic;\n        }\n\n        // Determine if shooting input is active\n        bool shootInputActive = isAutomatic ? Input.IsActionPressed(\"shoot\") : Input.IsActionJustPressed(\"shoot\");\n\n        if (!shootInputActive)\n        {\n            return;\n        }\n\n        // Check if weapon is empty before trying to shoot (not in reload sequence)\n        // This notifies enemies that the player tried to shoot with no ammo\n        if (!_isReloadingSequence && CurrentWeapon.CurrentAmmo <= 0)\n        {\n            // Emit signal to notify enemies that player is vulnerable (out of ammo)\n            EmitSignal(SignalName.AmmoDepleted);\n            // The weapon will play the empty click sound\n        }\n\n        // Handle shooting based on reload sequence state\n        if (_isReloadingSequence)\n        {\n            // In reload sequence\n            if (_reloadSequenceStep == 1)\n            {\n                // Step 1 (only R pressed, waiting for F): shooting resets the combo\n                GD.Print(\"[Player] Shooting during reload step 1 - resetting reload sequence\");\n                ResetReloadSequence();\n                Shoot();\n            }\n            else if (_reloadSequenceStep == 2)\n            {\n                // Step 2 (R->F pressed, waiting for final R): try to fire chamber bullet\n                if (CurrentWeapon.CanFireChamberBullet)\n                {\n                    // Fire the chamber bullet\n                    Vector2 mousePos = GetGlobalMousePosition();\n                    Vector2 shootDirection = (mousePos - GlobalPosition).Normalized();\n\n                    if (CurrentWeapon.FireChamberBullet(shootDirection))\n                    {\n                        GD.Print(\"[Player] Fired bullet in chamber during reload\");\n                        // Note: Sound is handled by the weapon's FireChamberBullet implementation\n                    }\n                }\n                else if (CurrentWeapon.ChamberBulletFired)\n                {\n                    // Chamber bullet already fired, can't shoot until reload completes\n                    GD.Print(\"[Player] Cannot shoot - chamber bullet already fired, wait for reload to complete\");\n                    PlayEmptyClickSound();\n                }\n                else\n                {\n                    // No bullet in chamber (magazine was empty when reload started)\n                    GD.Print(\"[Player] Cannot shoot - no bullet in chamber, wait for reload to complete\");\n                    PlayEmptyClickSound();\n                }\n            }\n        }\n        else\n        {\n            // Not in reload sequence - normal shooting\n            Shoot();\n        }\n    }\n\n    /// <summary>\n    /// Plays the empty click sound when trying to shoot without ammo.\n    /// </summary>\n    private void PlayEmptyClickSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_empty_click\"))\n        {\n            audioManager.Call(\"play_empty_click\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Toggles fire mode on the current weapon (if supported).\n    /// </summary>\n    private void ToggleFireMode()\n    {\n        if (CurrentWeapon is AssaultRifle assaultRifle)\n        {\n            assaultRifle.ToggleFireMode();\n        }\n    }\n\n    /// <summary>\n    /// Updates the player model rotation to face the aim direction.\n    /// The player model (body, head, arms) rotates to follow the rifle's aim direction.\n    /// This creates the appearance of the player rotating their whole body toward the target.\n    /// TACTICAL RELOAD (Issue #437): During shotgun reload OR when RMB is held (dragging),\n    /// player model rotation is locked to allow the player to keep aiming at a specific\n    /// spot while performing reload gestures.\n    ///\n    /// FIX (Issue #437 feedback): Lock rotation as soon as RMB is pressed, not just when\n    /// reload state changes. This prevents barrel/player shift during quick one-motion\n    /// reload gestures (drag up then down without releasing RMB).\n    /// </summary>\n    private void UpdatePlayerModelRotation()\n    {\n        if (_playerModel == null)\n        {\n            return;\n        }\n\n        // TACTICAL RELOAD (Issue #437): Don't rotate player model during shotgun reload\n        // OR when dragging (RMB is held). This ensures the player freezes immediately\n        // when RMB is pressed, before any state change occurs.\n        var shotgun = GetNodeOrNull<Shotgun>(\"Shotgun\");\n        if (shotgun != null && (shotgun.ReloadState != ShotgunReloadState.NotReloading || shotgun.IsDragging))\n        {\n            // Keep current rotation locked - don't follow mouse\n            return;\n        }\n\n        // Get the aim direction from the weapon if available\n        Vector2 aimDirection;\n        if (CurrentWeapon is AssaultRifle assaultRifle)\n        {\n            aimDirection = assaultRifle.AimDirection;\n        }\n        else if (CurrentWeapon is SniperRifle sniperRifle)\n        {\n            aimDirection = sniperRifle.AimDirection;\n        }\n        else\n        {\n            // Fallback: calculate direction to mouse cursor\n            Vector2 mousePos = GetGlobalMousePosition();\n            Vector2 toMouse = mousePos - GlobalPosition;\n            if (toMouse.LengthSquared() > 0.001f)\n            {\n                aimDirection = toMouse.Normalized();\n            }\n            else\n            {\n                return; // No valid direction\n            }\n        }\n\n        // Calculate target rotation angle\n        float targetAngle = aimDirection.Angle();\n\n        // Apply rotation to the player model\n        _playerModel.Rotation = targetAngle;\n\n        // Handle sprite flipping for left/right aim\n        // When aiming left (angle > 90¬∞ or < -90¬∞), flip vertically to avoid upside-down appearance\n        bool aimingLeft = Mathf.Abs(targetAngle) > Mathf.Pi / 2;\n\n        // Flip the player model vertically when aiming left\n        if (aimingLeft)\n        {\n            _playerModel.Scale = new Vector2(PlayerModelScale, -PlayerModelScale);\n        }\n        else\n        {\n            _playerModel.Scale = new Vector2(PlayerModelScale, PlayerModelScale);\n        }\n    }\n\n    /// <summary>\n    /// Detects the equipped weapon type and applies appropriate arm positioning.\n    /// Called from _PhysicsProcess() after a few frames to ensure level scripts\n    /// have finished adding weapons to the player node.\n    /// </summary>\n    private void DetectAndApplyWeaponPose()\n    {\n        LogToFile($\"[Player] Detecting weapon pose (frame {_weaponDetectFrameCount})...\");\n        var detectedType = WeaponType.Rifle;  // Default to rifle pose\n\n        // Check for weapon children - weapons are added directly to player by level scripts\n        // Check in order of specificity: MiniUzi (SMG), Shotgun, SilencedPistol, then default to Rifle\n        var miniUzi = GetNodeOrNull<BaseWeapon>(\"MiniUzi\");\n        var shotgun = GetNodeOrNull<BaseWeapon>(\"Shotgun\");\n        var silencedPistol = GetNodeOrNull<BaseWeapon>(\"SilencedPistol\");\n\n        if (miniUzi != null)\n        {\n            detectedType = WeaponType.SMG;\n            LogToFile(\"[Player] Detected weapon: Mini UZI (SMG pose)\");\n        }\n        else if (shotgun != null)\n        {\n            detectedType = WeaponType.Shotgun;\n            LogToFile(\"[Player] Detected weapon: Shotgun (Shotgun pose)\");\n        }\n        else if (silencedPistol != null)\n        {\n            detectedType = WeaponType.Pistol;\n            LogToFile(\"[Player] Detected weapon: Silenced Pistol (Pistol pose)\");\n        }\n        else\n        {\n            // Default to rifle (AssaultRifle or no weapon)\n            detectedType = WeaponType.Rifle;\n            LogToFile(\"[Player] Detected weapon: Rifle (default pose)\");\n        }\n\n        _currentWeaponType = detectedType;\n        ApplyWeaponArmOffsets();\n    }\n\n    /// <summary>\n    /// Applies arm position offsets based on current weapon type.\n    /// Modifies base arm positions to create appropriate weapon-holding poses.\n    /// </summary>\n    private void ApplyWeaponArmOffsets()\n    {\n        // Original positions from Player.tscn: LeftArm (24, 6), RightArm (-2, 6)\n        var originalLeftArmPos = new Vector2(24, 6);\n        var originalRightArmPos = new Vector2(-2, 6);\n\n        switch (_currentWeaponType)\n        {\n            case WeaponType.SMG:\n                // SMG pose: Compact two-handed grip\n                // Left arm moves back toward body for shorter weapon\n                // Right arm moves forward slightly to meet left hand\n                _baseLeftArmPos = originalLeftArmPos + SmgLeftArmOffset;\n                _baseRightArmPos = originalRightArmPos + SmgRightArmOffset;\n                LogToFile($\"[Player] Applied SMG arm pose: Left={_baseLeftArmPos}, Right={_baseRightArmPos}\");\n                break;\n\n            case WeaponType.Shotgun:\n                // Shotgun pose: Similar to rifle but slightly tighter\n                _baseLeftArmPos = originalLeftArmPos + new Vector2(-3, 0);\n                _baseRightArmPos = originalRightArmPos + new Vector2(1, 0);\n                LogToFile($\"[Player] Applied Shotgun arm pose: Left={_baseLeftArmPos}, Right={_baseRightArmPos}\");\n                break;\n\n            case WeaponType.Pistol:\n                // Pistol pose: Compact two-handed pistol grip (Weaver/Isoceles stance)\n                // Similar to SMG but even more compact - suppressed pistol is shorter than SMG\n                // Left arm supports under the right hand (close to body)\n                // Right arm extends forward slightly for aiming\n                _baseLeftArmPos = originalLeftArmPos + new Vector2(-14, 0);  // More compact than SMG (-10)\n                _baseRightArmPos = originalRightArmPos + new Vector2(4, 0);  // Slightly more forward than SMG (3)\n                LogToFile($\"[Player] Applied Pistol arm pose: Left={_baseLeftArmPos}, Right={_baseRightArmPos}\");\n                break;\n\n            case WeaponType.Rifle:\n            default:\n                // Rifle pose: Standard extended grip (original positions)\n                _baseLeftArmPos = originalLeftArmPos;\n                _baseRightArmPos = originalRightArmPos;\n                LogToFile($\"[Player] Applied Rifle arm pose: Left={_baseLeftArmPos}, Right={_baseRightArmPos}\");\n                break;\n        }\n\n        // Apply new base positions to sprites immediately\n        if (_leftArmSprite != null)\n        {\n            _leftArmSprite.Position = _baseLeftArmPos;\n        }\n        if (_rightArmSprite != null)\n        {\n            _rightArmSprite.Position = _baseRightArmPos;\n        }\n    }\n\n    /// <summary>\n    /// Gets the normalized input direction from player input.\n    /// </summary>\n    /// <returns>Normalized direction vector.</returns>\n    private Vector2 GetInputDirection()\n    {\n        Vector2 direction = Vector2.Zero;\n        direction.X = Input.GetAxis(\"move_left\", \"move_right\");\n        direction.Y = Input.GetAxis(\"move_up\", \"move_down\");\n\n        // Normalize to prevent faster diagonal movement\n        if (direction.Length() > 1.0f)\n        {\n            direction = direction.Normalized();\n        }\n\n        return direction;\n    }\n\n    /// <summary>\n    /// Updates the walking animation based on player movement state.\n    /// Creates a natural bobbing motion for body parts during movement.\n    /// </summary>\n    /// <param name=\"delta\">Time since last frame.</param>\n    /// <param name=\"inputDirection\">Current movement input direction.</param>\n    private void UpdateWalkAnimation(float delta, Vector2 inputDirection)\n    {\n        bool isMoving = inputDirection != Vector2.Zero || Velocity.Length() > 10.0f;\n\n        if (isMoving)\n        {\n            // Accumulate animation time based on movement speed\n            float speedFactor = Velocity.Length() / MaxSpeed;\n            _walkAnimTime += delta * WalkAnimSpeed * speedFactor;\n            _isWalking = true;\n\n            // Calculate animation offsets using sine waves\n            // Body bobs up and down (frequency = 2x for double step)\n            float bodyBob = Mathf.Sin(_walkAnimTime * 2.0f) * 1.5f * WalkAnimIntensity;\n\n            // Head bobs slightly less than body (dampened)\n            float headBob = Mathf.Sin(_walkAnimTime * 2.0f) * 0.8f * WalkAnimIntensity;\n\n            // Arms swing opposite to each other (alternating)\n            float armSwing = Mathf.Sin(_walkAnimTime) * 3.0f * WalkAnimIntensity;\n\n            // Apply offsets to sprites\n            if (_bodySprite != null)\n            {\n                _bodySprite.Position = _baseBodyPos + new Vector2(0, bodyBob);\n            }\n\n            if (_headSprite != null)\n            {\n                _headSprite.Position = _baseHeadPos + new Vector2(0, headBob);\n            }\n\n            if (_leftArmSprite != null)\n            {\n                // Left arm swings forward/back (y-axis in top-down)\n                _leftArmSprite.Position = _baseLeftArmPos + new Vector2(armSwing, 0);\n            }\n\n            if (_rightArmSprite != null)\n            {\n                // Right arm swings opposite to left arm\n                _rightArmSprite.Position = _baseRightArmPos + new Vector2(-armSwing, 0);\n            }\n        }\n        else\n        {\n            // Return to idle pose smoothly\n            if (_isWalking)\n            {\n                _isWalking = false;\n                _walkAnimTime = 0.0f;\n            }\n\n            // Interpolate back to base positions\n            float lerpSpeed = 10.0f * delta;\n            if (_bodySprite != null)\n            {\n                _bodySprite.Position = _bodySprite.Position.Lerp(_baseBodyPos, lerpSpeed);\n            }\n            if (_headSprite != null)\n            {\n                _headSprite.Position = _headSprite.Position.Lerp(_baseHeadPos, lerpSpeed);\n            }\n            if (_leftArmSprite != null)\n            {\n                _leftArmSprite.Position = _leftArmSprite.Position.Lerp(_baseLeftArmPos, lerpSpeed);\n            }\n            if (_rightArmSprite != null)\n            {\n                _rightArmSprite.Position = _rightArmSprite.Position.Lerp(_baseRightArmPos, lerpSpeed);\n            }\n        }\n    }\n\n    /// <summary>\n    /// Handles the R-F-R reload sequence input.\n    /// Step 0: Press R to start sequence (eject magazine)\n    /// Step 1: Press F to continue (insert new magazine)\n    /// Step 2: Press R to complete reload instantly (chamber round)\n    ///\n    /// Bullet in chamber mechanics:\n    /// - At step 1 (R pressed): shooting resets the combo\n    /// - At step 2 (R->F pressed): if previous magazine had ammo, one chamber bullet can be fired\n    /// - After reload: if chamber bullet was fired, subtract one from new magazine\n    ///\n    /// Note: This reload sequence is skipped for weapons that use tube magazines (like Shotgun),\n    /// which have their own shell-by-shell reload mechanism via RMB drag gestures.\n    /// </summary>\n    private void HandleReloadSequenceInput()\n    {\n        if (CurrentWeapon == null)\n        {\n            return;\n        }\n\n        // Skip R-F-R reload sequence for weapons that use tube magazines (like Shotgun)\n        // These weapons have their own reload mechanism (shell-by-shell via RMB gestures)\n        // Pressing R key should be ignored for these weapons to avoid breaking ammo tracking\n        if (CurrentWeapon is Shotgun)\n        {\n            return;\n        }\n\n        // Can't reload if magazine is full (and not in reload sequence)\n        if (!_isReloadingSequence && CurrentWeapon.CurrentAmmo >= (CurrentWeapon.WeaponData?.MagazineSize ?? 0))\n        {\n            return;\n        }\n\n        // Can't reload if no reserve ammo (and not in reload sequence)\n        if (!_isReloadingSequence && CurrentWeapon.ReserveAmmo <= 0)\n        {\n            return;\n        }\n\n        // Handle R key (first and third step)\n        if (Input.IsActionJustPressed(\"reload\"))\n        {\n            if (_reloadSequenceStep == 0 || _reloadSequenceStep == 1)\n            {\n                // Check if we can start a new reload (need ammo or already in sequence)\n                if (_reloadSequenceStep == 0)\n                {\n                    // Starting fresh - check conditions\n                    if (CurrentWeapon.CurrentAmmo >= (CurrentWeapon.WeaponData?.MagazineSize ?? 0))\n                    {\n                        return; // Magazine is full\n                    }\n                    if (CurrentWeapon.ReserveAmmo <= 0)\n                    {\n                        return; // No reserve ammo\n                    }\n                }\n\n                // Start or restart reload sequence\n                // This handles both initial R press and R->R sequence (restart)\n                _isReloadingSequence = true;\n                _reloadSequenceStep = 1;\n                _ammoAtReloadStart = CurrentWeapon.CurrentAmmo;\n                GD.Print($\"[Player] Reload sequence started (R pressed) - ammo at start: {_ammoAtReloadStart} - press F next\");\n                // Start animation: Step 1 - Grab magazine from chest\n                StartReloadAnimPhase(ReloadAnimPhase.GrabMagazine, ReloadAnimGrabDuration);\n                // Play magazine out sound\n                PlayReloadMagOutSound();\n                EmitSignal(SignalName.ReloadSequenceProgress, 1, 3);\n                // Notify enemies that player has started reloading (vulnerable state)\n                EmitSignal(SignalName.ReloadStarted);\n            }\n            else if (_reloadSequenceStep == 2)\n            {\n                // Complete reload sequence - instant reload!\n                // Start animation: Step 3 - Pull bolt/charging handle (back and forth motion)\n                StartReloadAnimPhase(ReloadAnimPhase.PullBolt, ReloadAnimBoltPullDuration);\n                // Play bolt cycling sound\n                PlayM16BoltSound();\n                CompleteReloadSequence();\n            }\n        }\n\n        // Handle F key (reload_step action - second step)\n        if (Input.IsActionJustPressed(\"reload_step\"))\n        {\n            if (_reloadSequenceStep == 1)\n            {\n                // Continue to next step - set up chamber bullet\n                _reloadSequenceStep = 2;\n\n                // Set up bullet in chamber based on ammo at reload start\n                bool hadAmmoInMagazine = _ammoAtReloadStart > 0;\n                CurrentWeapon.StartReloadSequence(hadAmmoInMagazine);\n\n                GD.Print($\"[Player] Reload sequence step 2 (F pressed) - bullet in chamber: {hadAmmoInMagazine} - press R to complete\");\n                // Start animation: Step 2 - Insert magazine into rifle\n                StartReloadAnimPhase(ReloadAnimPhase.InsertMagazine, ReloadAnimInsertDuration);\n                // Play magazine in sound\n                PlayReloadMagInSound();\n                EmitSignal(SignalName.ReloadSequenceProgress, 2, 3);\n            }\n            else if (_isReloadingSequence)\n            {\n                // Wrong key pressed, reset sequence\n                GD.Print(\"[Player] Wrong key! Reload sequence reset (expected R)\");\n                // Restart animation from grab phase\n                StartReloadAnimPhase(ReloadAnimPhase.GrabMagazine, ReloadAnimGrabDuration);\n                ResetReloadSequence();\n            }\n        }\n    }\n\n    /// <summary>\n    /// Plays the magazine out sound (first reload step).\n    /// </summary>\n    private void PlayReloadMagOutSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_reload_mag_out\"))\n        {\n            audioManager.Call(\"play_reload_mag_out\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Plays the magazine in sound (second reload step).\n    /// </summary>\n    private void PlayReloadMagInSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_reload_mag_in\"))\n        {\n            audioManager.Call(\"play_reload_mag_in\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Plays the M16 bolt cycling sound (third reload step).\n    /// </summary>\n    private void PlayM16BoltSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_bolt\"))\n        {\n            audioManager.Call(\"play_m16_bolt\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Completes the reload sequence, instantly reloading the weapon.\n    /// </summary>\n    private void CompleteReloadSequence()\n    {\n        if (CurrentWeapon == null)\n        {\n            return;\n        }\n\n        // Perform instant reload\n        CurrentWeapon.InstantReload();\n\n        GD.Print(\"[Player] Reload sequence complete! Magazine refilled instantly.\");\n        EmitSignal(SignalName.ReloadSequenceProgress, 3, 3);\n        EmitSignal(SignalName.ReloadCompleted);\n\n        ResetReloadSequence();\n    }\n\n    /// <summary>\n    /// Resets the reload sequence to the beginning.\n    /// Also cancels the weapon's reload sequence state.\n    /// </summary>\n    private void ResetReloadSequence()\n    {\n        _reloadSequenceStep = 0;\n        _isReloadingSequence = false;\n        _ammoAtReloadStart = 0;\n\n        // Return arms to idle if reload animation was active\n        if (_reloadAnimPhase != ReloadAnimPhase.None)\n        {\n            StartReloadAnimPhase(ReloadAnimPhase.ReturnIdle, ReloadAnimReturnDuration);\n        }\n\n        // Cancel weapon's reload sequence state\n        CurrentWeapon?.CancelReloadSequence();\n    }\n\n    /// <summary>\n    /// Gets whether the player is currently in a reload sequence.\n    /// </summary>\n    public bool IsReloadingSequence => _isReloadingSequence;\n\n    /// <summary>\n    /// Gets the current reload sequence step (0-2).\n    /// </summary>\n    public int ReloadSequenceStep => _reloadSequenceStep;\n\n    /// <summary>\n    /// Fires a bullet towards the mouse cursor.\n    /// Uses weapon system if available, otherwise uses direct bullet spawning.\n    /// </summary>\n    private void Shoot()\n    {\n        // Calculate direction towards mouse cursor\n        Vector2 mousePos = GetGlobalMousePosition();\n        Vector2 shootDirection = (mousePos - GlobalPosition).Normalized();\n\n        // If we have a weapon equipped, use it\n        if (CurrentWeapon != null)\n        {\n            // When SniperRifle scope is active, fire towards the scope crosshair center\n            // instead of the mouse cursor (the camera is offset, so mouse != crosshair)\n            var sniperRifle = CurrentWeapon as SniperRifle;\n            if (sniperRifle != null && sniperRifle.IsScopeActive)\n            {\n                Vector2 scopeTarget = sniperRifle.GetScopeAimTarget();\n                shootDirection = (scopeTarget - GlobalPosition).Normalized();\n            }\n\n            CurrentWeapon.Fire(shootDirection);\n            return;\n        }\n\n        // Otherwise use direct bullet spawning (original behavior)\n        SpawnBullet(shootDirection);\n    }\n\n    /// <summary>\n    /// Spawns a bullet directly without using the weapon system.\n    /// Preserves the original template behavior.\n    /// </summary>\n    /// <param name=\"direction\">Direction for the bullet to travel.</param>\n    private void SpawnBullet(Vector2 direction)\n    {\n        if (BulletScene == null)\n        {\n            return;\n        }\n\n        // Create bullet instance\n        var bullet = BulletScene.Instantiate<Node2D>();\n\n        // Set bullet position with offset in shoot direction\n        bullet.GlobalPosition = GlobalPosition + direction * BulletSpawnOffset;\n\n        // Set bullet direction\n        if (bullet.HasMethod(\"SetDirection\"))\n        {\n            bullet.Call(\"SetDirection\", direction);\n        }\n        else\n        {\n            bullet.Set(\"direction\", direction);\n        }\n\n        // Set shooter ID to prevent self-damage\n        if (bullet.HasMethod(\"SetShooterId\"))\n        {\n            bullet.Call(\"SetShooterId\", GetInstanceId());\n        }\n        else\n        {\n            bullet.Set(\"shooter_id\", GetInstanceId());\n        }\n\n        // Add bullet to the scene tree\n        GetTree().CurrentScene.AddChild(bullet);\n    }\n\n    /// <summary>\n    /// Last hit direction stored for blood effect spawning (Issue #350).\n    /// </summary>\n    private Vector2 _lastHitDirection = Vector2.Right;\n\n    /// <summary>\n    /// Last caliber data stored for blood effect scaling (Issue #350).\n    /// </summary>\n    private Godot.Resource? _lastCaliberData = null;\n\n    /// <summary>\n    /// Called when hit by a projectile via hit_area.gd.\n    /// This method name follows GDScript naming convention for cross-language compatibility\n    /// with the hit detection system that uses has_method(\"on_hit\") checks.\n    /// </summary>\n    public void on_hit()\n    {\n        on_hit_with_info(Vector2.Right, null);\n    }\n\n    /// <summary>\n    /// Called when hit by a projectile with extended hit information (Issue #350).\n    /// This method name follows GDScript naming convention for cross-language compatibility\n    /// with the hit detection system that uses has_method(\"on_hit_with_info\") checks.\n    /// </summary>\n    /// <param name=\"hitDirection\">Direction the bullet was traveling.</param>\n    /// <param name=\"caliberData\">Caliber resource for effect scaling (can be null).</param>\n    public void on_hit_with_info(Vector2 hitDirection, Godot.Resource? caliberData)\n    {\n        _lastHitDirection = hitDirection;\n        _lastCaliberData = caliberData;\n        TakeDamage(1);\n    }\n\n    /// <inheritdoc/>\n    public override void TakeDamage(float amount)\n    {\n        if (HealthComponent == null || !IsAlive)\n        {\n            return;\n        }\n\n        // Check invincibility mode (F6 toggle)\n        if (_invincibilityEnabled)\n        {\n            LogToFile(\"[Player] Hit blocked by invincibility mode (C#)\");\n            ShowHitFlash(); // Still show visual feedback for debugging\n            // Spawn blood effect for visual feedback even in invincibility mode (Issue #350)\n            SpawnBloodEffect(false);\n            return;\n        }\n\n        GD.Print($\"[Player] {Name}: Taking {amount} damage. Current health: {HealthComponent.CurrentHealth}\");\n\n        // Show hit flash effect\n        ShowHitFlash();\n\n        // Determine if this hit will be lethal before applying damage\n        bool willBeFatal = HealthComponent.CurrentHealth <= amount;\n\n        // Play appropriate hit sound and spawn blood effect (Issue #350)\n        if (willBeFatal)\n        {\n            PlayHitLethalSound();\n            SpawnBloodEffect(true);\n        }\n        else\n        {\n            PlayHitNonLethalSound();\n            SpawnBloodEffect(false);\n        }\n\n        base.TakeDamage(amount);\n    }\n\n    /// <summary>\n    /// Spawns blood effect at the player's position (Issue #350).\n    /// This makes blood effects appear when the player is hit, just like for enemies.\n    /// </summary>\n    /// <param name=\"isLethal\">Whether this was a lethal hit (affects effect scale).</param>\n    private void SpawnBloodEffect(bool isLethal)\n    {\n        var impactManager = GetNodeOrNull(\"/root/ImpactEffectsManager\");\n        if (impactManager != null && impactManager.HasMethod(\"spawn_blood_effect\"))\n        {\n            LogToFile($\"[Player] Spawning blood effect at {GlobalPosition}, dir={_lastHitDirection}, lethal={isLethal} (C#)\");\n            impactManager.Call(\"spawn_blood_effect\", GlobalPosition, _lastHitDirection, _lastCaliberData, isLethal);\n        }\n        else\n        {\n            LogToFile(\"[Player] WARNING: ImpactEffectsManager not found, blood effect not spawned (C#)\");\n        }\n    }\n\n    /// <summary>\n    /// Plays the lethal hit sound when player dies.\n    /// </summary>\n    private void PlayHitLethalSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_hit_lethal\"))\n        {\n            audioManager.Call(\"play_hit_lethal\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Plays the non-lethal hit sound when player is damaged but survives.\n    /// </summary>\n    private void PlayHitNonLethalSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_hit_non_lethal\"))\n        {\n            audioManager.Call(\"play_hit_non_lethal\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Shows a brief flash effect when hit.\n    /// </summary>\n    private async void ShowHitFlash()\n    {\n        if (_playerModel == null && _sprite == null)\n        {\n            return;\n        }\n\n        SetAllSpritesModulate(HitFlashColor);\n\n        await ToSignal(GetTree().CreateTimer(HitFlashDuration), \"timeout\");\n\n        // Restore color based on current health (if still alive)\n        if (HealthComponent != null && HealthComponent.IsAlive)\n        {\n            UpdateHealthVisual();\n        }\n    }\n\n    /// <inheritdoc/>\n    public override void OnDeath()\n    {\n        base.OnDeath();\n        // Handle player death\n        GD.Print(\"Player died!\");\n    }\n\n    /// <summary>\n    /// Equips a new weapon.\n    /// </summary>\n    /// <param name=\"weapon\">The weapon to equip.</param>\n    public void EquipWeapon(BaseWeapon weapon)\n    {\n        // Unequip current weapon if any\n        if (CurrentWeapon != null && CurrentWeapon.GetParent() == this)\n        {\n            RemoveChild(CurrentWeapon);\n        }\n\n        CurrentWeapon = weapon;\n\n        // Add weapon as child if not already in scene tree\n        if (CurrentWeapon.GetParent() == null)\n        {\n            AddChild(CurrentWeapon);\n        }\n    }\n\n    /// <summary>\n    /// Unequips the current weapon.\n    /// </summary>\n    public void UnequipWeapon()\n    {\n        if (CurrentWeapon != null && CurrentWeapon.GetParent() == this)\n        {\n            RemoveChild(CurrentWeapon);\n        }\n        CurrentWeapon = null;\n    }\n\n    #region Sniper Scope System\n\n    /// <summary>\n    /// Handles sniper scope input when the SniperRifle is equipped.\n    /// RMB activates the scope for aiming beyond the viewport.\n    /// Mouse wheel adjusts zoom distance while scoped.\n    /// Returns true if the sniper scope consumed the RMB input.\n    /// </summary>\n    private bool HandleSniperScopeInput()\n    {\n        // Only handle scope when a SniperRifle is the current weapon\n        var sniperRifle = CurrentWeapon as SniperRifle;\n        if (sniperRifle == null)\n        {\n            return false;\n        }\n\n        // Handle RMB press to activate scope\n        if (Input.IsActionJustPressed(\"grenade_throw\"))\n        {\n            // Only activate scope if not already in a grenade action\n            if (_grenadeState == GrenadeState.Idle && !Input.IsActionPressed(\"grenade_prepare\"))\n            {\n                sniperRifle.ActivateScope();\n                return true;\n            }\n        }\n\n        // Handle RMB release to deactivate scope\n        if (Input.IsActionJustReleased(\"grenade_throw\") && sniperRifle.IsScopeActive)\n        {\n            sniperRifle.DeactivateScope();\n            return true;\n        }\n\n        // While scope is active, consume RMB input to prevent grenade handling\n        if (sniperRifle.IsScopeActive)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    /// <summary>\n    /// Handles mouse wheel input for scope zoom when sniper scope is active.\n    /// This is called from _UnhandledInput to capture wheel events.\n    /// </summary>\n    public override void _UnhandledInput(InputEvent @event)\n    {\n        base._UnhandledInput(@event);\n\n        var sniperRifle = CurrentWeapon as SniperRifle;\n        if (sniperRifle == null || !sniperRifle.IsScopeActive)\n        {\n            return;\n        }\n\n        if (@event is InputEventMouseButton mouseButton)\n        {\n            if (mouseButton.Pressed)\n            {\n                if (mouseButton.ButtonIndex == MouseButton.WheelUp)\n                {\n                    sniperRifle.AdjustScopeZoom(1.0f);\n                    GetViewport().SetInputAsHandled();\n                }\n                else if (mouseButton.ButtonIndex == MouseButton.WheelDown)\n                {\n                    sniperRifle.AdjustScopeZoom(-1.0f);\n                    GetViewport().SetInputAsHandled();\n                }\n            }\n        }\n    }\n\n    #endregion\n\n    #region Grenade System\n\n    /// <summary>\n    /// Handle grenade input with either simple or complex mechanic.\n    /// Simple mode (default): Hold RMB to aim with trajectory preview, release to throw.\n    /// Complex mode (experimental): G + RMB drag right ‚Üí hold G+RMB ‚Üí release G ‚Üí drag and release RMB.\n    /// </summary>\n    private void HandleGrenadeInput()\n    {\n        // Handle throw rotation animation\n        HandleThrowRotationAnimation((float)GetPhysicsProcessDeltaTime());\n\n        // Check for active grenade explosion (explodes in hand after 4 seconds)\n        if (_activeGrenade != null && !IsInstanceValid(_activeGrenade))\n        {\n            // Grenade exploded while held - return arms to idle\n            StartGrenadeAnimPhase(GrenadeAnimPhase.ReturnIdle, AnimReturnDuration);\n            ResetGrenadeState();\n            return;\n        }\n\n        // Check if complex grenade throwing is enabled (experimental setting)\n        var experimentalSettings = GetNodeOrNull(\"/root/ExperimentalSettings\");\n        bool useComplexThrowing = false;\n        if (experimentalSettings != null && experimentalSettings.HasMethod(\"is_complex_grenade_throwing\"))\n        {\n            useComplexThrowing = (bool)experimentalSettings.Call(\"is_complex_grenade_throwing\");\n        }\n\n        // Debug log once per state change to track mode (logged once when grenade action starts)\n        if (_grenadeState == GrenadeState.Idle && (Input.IsActionJustPressed(\"grenade_throw\") || Input.IsActionJustPressed(\"grenade_prepare\")))\n        {\n            LogToFile($\"[Player.Grenade] Mode check: complex={useComplexThrowing}, settings_node={experimentalSettings != null}\");\n        }\n\n        if (useComplexThrowing)\n        {\n            // Complex 3-step throwing mechanic\n            switch (_grenadeState)\n            {\n                case GrenadeState.Idle:\n                    HandleGrenadeIdleState();\n                    break;\n                case GrenadeState.TimerStarted:\n                    HandleGrenadeTimerStartedState();\n                    break;\n                case GrenadeState.WaitingForGRelease:\n                    HandleGrenadeWaitingForGReleaseState();\n                    break;\n                case GrenadeState.Aiming:\n                    HandleGrenadeAimingState();\n                    break;\n            }\n        }\n        else\n        {\n            // Simple trajectory aiming mode - uses same pin-pull mechanic (G+RMB drag)\n            // but replaces mouse-velocity throwing with trajectory-to-cursor aiming\n            switch (_grenadeState)\n            {\n                case GrenadeState.Idle:\n                    // Use same G+RMB drag mechanic as complex mode for pin pull (Step 1)\n                    HandleGrenadeIdleState();\n                    break;\n                case GrenadeState.TimerStarted:\n                    // After pin is pulled, RMB starts trajectory aiming (instead of Step 2)\n                    HandleSimpleGrenadeTimerStartedState();\n                    break;\n                case GrenadeState.SimpleAiming:\n                    // RMB held: show trajectory preview, release to throw to cursor\n                    HandleSimpleGrenadeAimingState();\n                    break;\n                default:\n                    // If we're in a complex-mode state but simple mode is now enabled,\n                    // reset to allow starting fresh (handles mode switch mid-throw)\n                    if (_grenadeState == GrenadeState.WaitingForGRelease ||\n                        _grenadeState == GrenadeState.Aiming)\n                    {\n                        LogToFile($\"[Player.Grenade] Mode mismatch: resetting from complex state {_grenadeState} to IDLE\");\n                        if (_activeGrenade != null && IsInstanceValid(_activeGrenade))\n                        {\n                            DropGrenadeAtFeet();\n                        }\n                        else\n                        {\n                            ResetGrenadeState();\n                        }\n                    }\n                    break;\n            }\n        }\n    }\n\n    /// <summary>\n    /// Handle grenade input in Idle state.\n    /// Waiting for G + RMB drag right to start timer (Step 1).\n    /// </summary>\n    private void HandleGrenadeIdleState()\n    {\n        // Start grab animation when G is first pressed (check before the is_action_pressed block)\n        if (Input.IsActionJustPressed(\"grenade_prepare\") && _currentGrenades > 0)\n        {\n            StartGrenadeAnimPhase(GrenadeAnimPhase.GrabGrenade, AnimGrabDuration);\n            LogToFile(\"[Player.Grenade] G pressed - starting grab animation\");\n        }\n\n        // Check if G key is held and player has grenades\n        if (Input.IsActionPressed(\"grenade_prepare\") && _currentGrenades > 0)\n        {\n            // Check if RMB was just pressed (start of drag)\n            if (Input.IsActionJustPressed(\"grenade_throw\"))\n            {\n                _grenadeDragStart = GetGlobalMousePosition();\n                _grenadeDragActive = true;\n                LogToFile($\"[Player.Grenade] Step 1 started: G held, RMB pressed at {_grenadeDragStart}\");\n            }\n\n            // Check if RMB was released (end of drag)\n            if (_grenadeDragActive && Input.IsActionJustReleased(\"grenade_throw\"))\n            {\n                Vector2 dragEnd = GetGlobalMousePosition();\n                Vector2 dragVector = dragEnd - _grenadeDragStart;\n\n                // Check if drag was to the right and long enough\n                if (dragVector.X > MinDragDistanceForStep1)\n                {\n                    StartGrenadeTimer();\n                    // Start pull pin animation\n                    StartGrenadeAnimPhase(GrenadeAnimPhase.PullPin, AnimPinDuration);\n                    LogToFile($\"[Player.Grenade] Step 1 complete! Drag: {dragVector}\");\n                }\n                else\n                {\n                    LogToFile($\"[Player.Grenade] Step 1 failed: drag not far enough right ({dragVector.X} < {MinDragDistanceForStep1})\");\n                }\n                _grenadeDragActive = false;\n            }\n        }\n        else\n        {\n            _grenadeDragActive = false;\n            // If G was released and we were in grab animation, return to idle\n            if (_grenadeAnimPhase == GrenadeAnimPhase.GrabGrenade)\n            {\n                StartGrenadeAnimPhase(GrenadeAnimPhase.ReturnIdle, AnimReturnDuration);\n            }\n        }\n    }\n\n    /// <summary>\n    /// Handle grenade input in TimerStarted state.\n    /// Waiting for RMB to be pressed while G is held (Step 2 part 1).\n    /// </summary>\n    private void HandleGrenadeTimerStartedState()\n    {\n        // If G is released, drop grenade at feet\n        if (!Input.IsActionPressed(\"grenade_prepare\"))\n        {\n            LogToFile(\"[Player.Grenade] G released - dropping grenade at feet\");\n            DropGrenadeAtFeet();\n            return;\n        }\n\n        // Check if RMB is pressed to enter WaitingForGRelease state\n        if (Input.IsActionJustPressed(\"grenade_throw\"))\n        {\n            _grenadeState = GrenadeState.WaitingForGRelease;\n            // Start hands approach animation\n            StartGrenadeAnimPhase(GrenadeAnimPhase.HandsApproach, AnimApproachDuration);\n            LogToFile(\"[Player.Grenade] Step 2 part 1: G+RMB held - now release G to ready the throw\");\n        }\n    }\n\n    /// <summary>\n    /// Handle grenade input in WaitingForGRelease state.\n    /// G+RMB are both held, waiting for G to be released (Step 2 part 2).\n    /// </summary>\n    private void HandleGrenadeWaitingForGReleaseState()\n    {\n        // If RMB is released before G, go back to TimerStarted\n        if (!Input.IsActionPressed(\"grenade_throw\"))\n        {\n            _grenadeState = GrenadeState.TimerStarted;\n            LogToFile(\"[Player.Grenade] RMB released before G - back to waiting for RMB\");\n            return;\n        }\n\n        // If G is released while RMB is still held, enter Aiming state\n        if (!Input.IsActionPressed(\"grenade_prepare\"))\n        {\n            _grenadeState = GrenadeState.Aiming;\n            _grenadeDragStart = GetGlobalMousePosition();\n            _prevMousePos = _grenadeDragStart;\n            // Initialize velocity tracking for realistic throwing\n            _mouseVelocityHistory.Clear();\n            _currentMouseVelocity = Vector2.Zero;\n            _totalSwingDistance = 0.0f;\n            _prevFrameTime = Time.GetTicksMsec() / 1000.0;\n            // Start transfer animation (grenade to throwing hand)\n            StartGrenadeAnimPhase(GrenadeAnimPhase.Transfer, AnimTransferDuration);\n            LogToFile(\"[Player.Grenade] Step 2 complete: G released, RMB held - now aiming (velocity-based throwing enabled)\");\n        }\n    }\n\n    /// <summary>\n    /// Handle grenade input in Aiming state.\n    /// Only RMB is held (G was released), waiting for drag and release to throw.\n    /// </summary>\n    private void HandleGrenadeAimingState()\n    {\n        // In this state, G is already released (that's how we got here)\n        // We only care about RMB\n\n        // Transition from transfer to wind-up after transfer completes\n        if (_grenadeAnimPhase == GrenadeAnimPhase.Transfer && _grenadeAnimTimer <= 0)\n        {\n            StartGrenadeAnimPhase(GrenadeAnimPhase.WindUp, 0); // Wind-up is continuous\n            LogToFile(\"[Player.Grenade.Anim] Entered wind-up phase\");\n        }\n\n        // Update wind-up intensity while in wind-up phase\n        if (_grenadeAnimPhase == GrenadeAnimPhase.WindUp)\n        {\n            UpdateWindUpIntensity();\n        }\n\n        // Request redraw for debug trajectory visualization\n        if (_debugModeEnabled)\n        {\n            QueueRedraw();\n        }\n\n        // If RMB is released, throw the grenade\n        if (Input.IsActionJustReleased(\"grenade_throw\"))\n        {\n            // Start throw animation\n            StartGrenadeAnimPhase(GrenadeAnimPhase.Throw, AnimThrowDuration);\n            Vector2 dragEnd = GetGlobalMousePosition();\n            ThrowGrenade(dragEnd);\n        }\n    }\n\n    #region Simple Grenade Throwing Mode\n\n    /// <summary>\n    /// Handle TIMER_STARTED state for simple grenade throwing mode.\n    /// After pin is pulled (G+RMB drag), wait for RMB to start trajectory aiming.\n    /// If G is released, drop grenade at feet.\n    /// </summary>\n    private void HandleSimpleGrenadeTimerStartedState()\n    {\n        // Make grenade follow player while G is held\n        if (_activeGrenade != null && IsInstanceValid(_activeGrenade))\n        {\n            _activeGrenade.GlobalPosition = GlobalPosition;\n        }\n\n        // If G is released, drop grenade at feet\n        if (!Input.IsActionPressed(\"grenade_prepare\"))\n        {\n            LogToFile(\"[Player.Grenade.Simple] G released - dropping grenade at feet\");\n            DropGrenadeAtFeet();\n            return;\n        }\n\n        // Check if RMB is pressed to enter SimpleAiming state\n        if (Input.IsActionJustPressed(\"grenade_throw\"))\n        {\n            _grenadeState = GrenadeState.SimpleAiming;\n            _isPreparingGrenade = true;\n            // Store initial mouse position for aiming\n            _aimDragStart = GetGlobalMousePosition();\n            // Start hands approach animation\n            StartGrenadeAnimPhase(GrenadeAnimPhase.HandsApproach, AnimApproachDuration);\n            LogToFile(\"[Player.Grenade.Simple] RMB pressed after pin pull - starting trajectory aiming\");\n        }\n    }\n\n    /// <summary>\n    /// Handle SIMPLE_AIMING state: RMB held, showing trajectory preview.\n    /// Cursor position = landing point. Release RMB to throw.\n    /// G can be released while RMB is held - grenade stays ready.\n    /// </summary>\n    private void HandleSimpleGrenadeAimingState()\n    {\n        // Request redraw for trajectory visualization (always show in simple mode)\n        QueueRedraw();\n\n        // Make grenade follow player\n        if (_activeGrenade != null && IsInstanceValid(_activeGrenade))\n        {\n            _activeGrenade.GlobalPosition = GlobalPosition;\n        }\n\n        // Update arm animation based on wind-up\n        UpdateSimpleWindUpAnimation();\n\n        // If animation phases need to transition\n        if (_grenadeAnimPhase == GrenadeAnimPhase.HandsApproach && _grenadeAnimTimer <= 0)\n        {\n            _grenadeAnimPhase = GrenadeAnimPhase.WindUp;\n        }\n\n        // Check for RMB release - throw the grenade!\n        if (Input.IsActionJustReleased(\"grenade_throw\"))\n        {\n            ThrowSimpleGrenade();\n        }\n\n        // Check for cancellation (if grenade was somehow destroyed)\n        if (_activeGrenade == null || !IsInstanceValid(_activeGrenade))\n        {\n            ResetGrenadeState();\n            StartGrenadeAnimPhase(GrenadeAnimPhase.ReturnIdle, AnimReturnDuration);\n        }\n    }\n\n    /// <summary>\n    /// Update wind-up animation based on distance from player to cursor.\n    /// </summary>\n    private void UpdateSimpleWindUpAnimation()\n    {\n        Vector2 currentMouse = GetGlobalMousePosition();\n        float distance = GlobalPosition.DistanceTo(currentMouse);\n\n        // Calculate wind-up intensity based on distance (0-500 pixels = 0-1 intensity)\n        const float maxDistance = 500.0f;\n        _windUpIntensity = Mathf.Clamp(distance / maxDistance, 0.0f, 1.0f);\n    }\n\n    /// <summary>\n    /// Throw the grenade in simple mode.\n    /// Direction and distance based on cursor position relative to player.\n    /// </summary>\n    private void ThrowSimpleGrenade()\n    {\n        if (_activeGrenade == null || !IsInstanceValid(_activeGrenade))\n        {\n            LogToFile(\"[Player.Grenade.Simple] Cannot throw: no active grenade\");\n            ResetGrenadeState();\n            return;\n        }\n\n        Vector2 targetPos = GetGlobalMousePosition();\n        Vector2 toTarget = targetPos - GlobalPosition;\n\n        // Calculate throw direction\n        Vector2 throwDirection = toTarget.Length() > 10.0f ? toTarget.Normalized() : new Vector2(1, 0);\n\n        // FIX for issue #398: Account for spawn offset in distance calculation\n        // The grenade starts 60 pixels ahead of the player in the throw direction,\n        // so we need to calculate distance from spawn position to target, not from player to target\n        const float spawnOffset = 60.0f;\n        Vector2 spawnPosition = GlobalPosition + throwDirection * spawnOffset;\n        float throwDistance = (targetPos - spawnPosition).Length();\n\n        // Ensure minimum throw distance\n        if (throwDistance < 10.0f) throwDistance = 10.0f;\n\n        // Get grenade's actual physics properties for accurate calculation\n        // FIX for issue #398: Use actual grenade properties instead of hardcoded values\n        float groundFriction = 300.0f; // Default\n        float maxThrowSpeed = 850.0f;  // Default\n        if (_activeGrenade.Get(\"ground_friction\").VariantType != Variant.Type.Nil)\n        {\n            groundFriction = (float)_activeGrenade.Get(\"ground_friction\");\n        }\n        if (_activeGrenade.Get(\"max_throw_speed\").VariantType != Variant.Type.Nil)\n        {\n            maxThrowSpeed = (float)_activeGrenade.Get(\"max_throw_speed\");\n        }\n\n        // Calculate throw speed needed to reach target (using physics)\n        // Distance = v^2 / (2 * friction) ‚Üí v = sqrt(2 * friction * distance)\n        // FIX for issue #428: Apply 16% compensation factor to account for:\n        // 1. Discrete time integration error from Godot's 60 FPS Euler integration (~0.8%)\n        // 2. Additional physics damping effects in Godot's RigidBody2D (~12.5%)\n        // Empirically tested: grenades travel ~86% of calculated distance without compensation.\n        // Factor of 1.16 (‚âà 1/0.86) brings actual landing position to match target cursor position.\n        const float physicsCompensationFactor = 1.16f;\n        float requiredSpeed = Mathf.Sqrt(2.0f * groundFriction * throwDistance * physicsCompensationFactor);\n\n        // Clamp to grenade's max throw speed\n        float throwSpeed = Mathf.Min(requiredSpeed, maxThrowSpeed);\n\n        // Calculate actual landing distance with clamped speed (for logging)\n        float actualDistance = (throwSpeed * throwSpeed) / (2.0f * groundFriction);\n\n        LogToFile($\"[Player.Grenade.Simple] Throwing! Target: {targetPos}, Distance: {actualDistance:F1}, Speed: {throwSpeed:F1}, Friction: {groundFriction:F1}\");\n\n        // Rotate player to face throw direction\n        RotatePlayerForThrow(throwDirection);\n\n        // Calculate safe spawn position with wall check\n        Vector2 intendedSpawnPosition = GlobalPosition + throwDirection * spawnOffset;\n        Vector2 safeSpawnPosition = GetSafeGrenadeSpawnPosition(GlobalPosition, intendedSpawnPosition, throwDirection);\n\n        // FIX for issue #398: Set grenade position to spawn point BEFORE throwing\n        // The grenade follows the player during aiming at GlobalPosition,\n        // but the distance calculation assumes it starts from spawnPosition (60px ahead).\n        // Without this fix, the grenade lands ~60px short of the target.\n        _activeGrenade.GlobalPosition = safeSpawnPosition;\n\n        // FIX for Issue #432: Mark grenade as thrown BEFORE unfreezing to avoid race condition.\n        // If MarkAsThrown() is called after unfreezing, the BodyEntered signal could fire\n        // before IsThrown is set, causing impact detection to fail.\n        var grenadeTimer = _activeGrenade.GetNodeOrNull<GrenadeTimer>(\"GrenadeTimer\");\n        if (grenadeTimer != null)\n        {\n            grenadeTimer.MarkAsThrown();\n        }\n\n        // Unfreeze and throw the grenade\n        _activeGrenade.Freeze = false;\n\n        // FIX for Issue #432: ALWAYS set velocity directly in C# as primary mechanism.\n        // GDScript methods called via Call() may silently fail in exported builds,\n        // causing grenades to fly infinitely (no velocity set) or not move at all.\n        // By setting velocity directly in C#, we guarantee the grenade moves correctly.\n        _activeGrenade.LinearVelocity = throwDirection * throwSpeed;\n        _activeGrenade.Rotation = throwDirection.Angle();\n\n        LogToFile($\"[Player.Grenade.Simple] C# set velocity directly: dir={throwDirection}, speed={throwSpeed:F1}, spawn={safeSpawnPosition}\");\n\n        // Also try to call GDScript method for any additional setup it might do\n        // (visual effects, sound, etc.), but the velocity is already set above\n        if (_activeGrenade.HasMethod(\"throw_grenade_simple\"))\n        {\n            _activeGrenade.Call(\"throw_grenade_simple\", throwDirection, throwSpeed);\n        }\n\n        // Start throw animation\n        StartGrenadeAnimPhase(GrenadeAnimPhase.Throw, AnimThrowDuration);\n\n        // Emit signal and play sound\n        EmitSignal(SignalName.GrenadeThrown);\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_grenade_throw\"))\n        {\n            audioManager.Call(\"play_grenade_throw\", GlobalPosition);\n        }\n\n        LogToFile(\"[Player.Grenade.Simple] Grenade thrown!\");\n\n        // Reset state\n        ResetGrenadeState();\n    }\n\n    #endregion\n\n    /// <summary>\n    /// Start the grenade timer (step 1 complete - pin pulled).\n    /// Creates the grenade instance and starts its 4-second fuse.\n    /// </summary>\n    private void StartGrenadeTimer()\n    {\n        if (_currentGrenades <= 0)\n        {\n            LogToFile(\"[Player.Grenade] Cannot start timer: no grenades\");\n            return;\n        }\n\n        if (GrenadeScene == null)\n        {\n            LogToFile(\"[Player.Grenade] Cannot start timer: GrenadeScene is null\");\n            return;\n        }\n\n        // Create grenade instance (held by player)\n        _activeGrenade = GrenadeScene.Instantiate<RigidBody2D>();\n        if (_activeGrenade == null)\n        {\n            LogToFile(\"[Player.Grenade] Failed to instantiate grenade scene\");\n            return;\n        }\n\n        // Add grenade to scene first (must be in tree before setting GlobalPosition)\n        GetTree().CurrentScene.AddChild(_activeGrenade);\n\n        // FIX for Issue #432 (activation position bug): Freeze the grenade IMMEDIATELY after creation.\n        // This MUST happen before setting position to prevent physics engine interference.\n        // Root cause: GDScript _ready() sets freeze=true, but GDScript doesn't run in exports!\n        // Without this fix, the physics engine can move the unfrozen grenade while player moves,\n        // causing the grenade to be thrown from the activation position instead of player's current position.\n        // See commit 60f7cae for original fix and docs/case-studies/issue-183/ for detailed analysis.\n        _activeGrenade.FreezeMode = RigidBody2D.FreezeModeEnum.Kinematic;\n        _activeGrenade.Freeze = true;\n\n        // Set position AFTER AddChild and AFTER freezing (GlobalPosition only works when node is in the scene tree)\n        _activeGrenade.GlobalPosition = GlobalPosition;\n\n        // FIX for Issue #432: Add C# GrenadeTimer component for reliable explosion handling.\n        // GDScript methods called via Call() may silently fail in exports, causing grenades\n        // to fly infinitely without exploding. This C# component provides a reliable fallback.\n        AddGrenadeTimerComponent(_activeGrenade);\n\n        // Activate the grenade timer (starts 4s countdown)\n        // Try GDScript first, but C# GrenadeTimer will handle it if this fails\n        if (_activeGrenade.HasMethod(\"activate_timer\"))\n        {\n            _activeGrenade.Call(\"activate_timer\");\n        }\n        // Also activate C# timer as reliable fallback\n        var grenadeTimer = _activeGrenade.GetNodeOrNull<GrenadeTimer>(\"GrenadeTimer\");\n        if (grenadeTimer != null)\n        {\n            grenadeTimer.ActivateTimer();\n        }\n\n        _grenadeState = GrenadeState.TimerStarted;\n\n        // Decrement grenade count now (pin is pulled) - but not on tutorial level (infinite)\n        if (!_isTutorialLevel)\n        {\n            _currentGrenades--;\n        }\n        EmitSignal(SignalName.GrenadeChanged, _currentGrenades, MaxGrenades);\n\n        // Play grenade prepare sound\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_grenade_prepare\"))\n        {\n            audioManager.Call(\"play_grenade_prepare\", GlobalPosition);\n        }\n\n        LogToFile($\"[Player.Grenade] Timer started, grenade created at {GlobalPosition}\");\n    }\n\n    /// <summary>\n    /// Add C# GrenadeTimer component to grenade for reliable explosion handling.\n    /// FIX for Issue #432: GDScript methods called via Call() may silently fail in exports.\n    /// </summary>\n    private void AddGrenadeTimerComponent(RigidBody2D grenade)\n    {\n        // Determine grenade type from scene name\n        var grenadeType = GrenadeTimer.GrenadeType.Flashbang;\n        var scenePath = grenade.SceneFilePath;\n        if (scenePath.Contains(\"Frag\", StringComparison.OrdinalIgnoreCase))\n        {\n            grenadeType = GrenadeTimer.GrenadeType.Frag;\n        }\n\n        // Create and configure the GrenadeTimer component\n        var timer = new GrenadeTimer();\n        timer.Name = \"GrenadeTimer\";\n        timer.Type = grenadeType;\n\n        // Copy relevant properties from grenade (if they exist as exported properties)\n        if (grenade.HasMeta(\"fuse_time\") || grenade.Get(\"fuse_time\").VariantType != Variant.Type.Nil)\n        {\n            timer.FuseTime = (float)grenade.Get(\"fuse_time\");\n        }\n        if (grenade.HasMeta(\"effect_radius\") || grenade.Get(\"effect_radius\").VariantType != Variant.Type.Nil)\n        {\n            timer.EffectRadius = (float)grenade.Get(\"effect_radius\");\n        }\n        if (grenade.HasMeta(\"explosion_damage\") || grenade.Get(\"explosion_damage\").VariantType != Variant.Type.Nil)\n        {\n            timer.ExplosionDamage = (int)grenade.Get(\"explosion_damage\");\n        }\n        if (grenade.HasMeta(\"blindness_duration\") || grenade.Get(\"blindness_duration\").VariantType != Variant.Type.Nil)\n        {\n            timer.BlindnessDuration = (float)grenade.Get(\"blindness_duration\");\n        }\n        if (grenade.HasMeta(\"stun_duration\") || grenade.Get(\"stun_duration\").VariantType != Variant.Type.Nil)\n        {\n            timer.StunDuration = (float)grenade.Get(\"stun_duration\");\n        }\n        // FIX for Issue #432: Copy ground_friction for C# friction handling\n        // GDScript _physics_process() may not run in exports, so we need C# to apply friction\n        if (grenade.HasMeta(\"ground_friction\") || grenade.Get(\"ground_friction\").VariantType != Variant.Type.Nil)\n        {\n            timer.GroundFriction = (float)grenade.Get(\"ground_friction\");\n        }\n\n        // FIX for Issue #432: Apply type-based defaults BEFORE adding to scene.\n        // GDScript Get() calls may fail silently in exported builds, leaving us with\n        // incorrect values (e.g., Frag grenade using Flashbang's 400 radius instead of 225).\n        timer.SetTypeBasedDefaults();\n\n        // Add the timer component to the grenade\n        grenade.AddChild(timer);\n        LogToFile($\"[Player.Grenade] Added GrenadeTimer component (type: {grenadeType})\");\n    }\n\n    /// <summary>\n    /// Drop the grenade at player's feet (when G is released before throwing).\n    /// </summary>\n    private void DropGrenadeAtFeet()\n    {\n        if (_activeGrenade != null && IsInstanceValid(_activeGrenade))\n        {\n            // Set position to current player position before unfreezing\n            _activeGrenade.GlobalPosition = GlobalPosition;\n            // Unfreeze the grenade so physics works and it can explode\n            _activeGrenade.Freeze = false;\n            // The grenade stays where it is (at player's feet)\n            LogToFile($\"[Player.Grenade] Grenade dropped at feet at {_activeGrenade.GlobalPosition} (unfrozen)\");\n        }\n        // Start return animation\n        StartGrenadeAnimPhase(GrenadeAnimPhase.ReturnIdle, AnimReturnDuration);\n        ResetGrenadeState();\n    }\n\n    /// <summary>\n    /// Reset grenade state to idle.\n    /// </summary>\n    private void ResetGrenadeState()\n    {\n        _grenadeState = GrenadeState.Idle;\n        _grenadeDragActive = false;\n        _grenadeDragStart = Vector2.Zero;\n        // Don't null out _activeGrenade - it's now an independent object in the scene\n        _activeGrenade = null;\n        // Reset wind-up intensity\n        _windUpIntensity = 0.0f;\n        // Reset velocity tracking for next throw\n        _mouseVelocityHistory.Clear();\n        _currentMouseVelocity = Vector2.Zero;\n        _totalSwingDistance = 0.0f;\n        LogToFile(\"[Player.Grenade] State reset to IDLE\");\n    }\n\n    /// <summary>\n    /// Sensitivity multiplier for throw distance calculation.\n    /// Higher value = farther throw for same drag distance.\n    /// Must match the value used in debug visualization.\n    /// </summary>\n    private const float ThrowSensitivityMultiplier = 9.0f;\n\n    /// <summary>\n    /// Throw the grenade using realistic velocity-based physics.\n    /// The throw velocity is determined by mouse velocity at release moment, not drag distance.\n    /// FIX for issue #313: Direction is now determined by MOUSE VELOCITY (how user moves the mouse)\n    /// with snapping to 4 cardinal directions to compensate for imprecise human mouse movement.\n    /// </summary>\n    /// <param name=\"dragEnd\">The end position of the drag (used for direction fallback).</param>\n    private void ThrowGrenade(Vector2 dragEnd)\n    {\n        if (_activeGrenade == null || !IsInstanceValid(_activeGrenade))\n        {\n            LogToFile(\"[Player.Grenade] Cannot throw: no active grenade\");\n            ResetGrenadeState();\n            return;\n        }\n\n        // Get the mouse velocity at moment of release (for determining throw speed AND direction)\n        Vector2 releaseVelocity = _currentMouseVelocity;\n        float velocityMagnitude = releaseVelocity.Length();\n\n        // FIX for issue #313: Use MOUSE VELOCITY DIRECTION (how the mouse is MOVING)\n        // User requirement: grenade flies in the direction the mouse is moving at release\n        // NOT toward where the mouse cursor is positioned\n        // Example: If user moves mouse DOWN, grenade flies DOWN (regardless of where cursor is)\n        Vector2 throwDirection;\n\n        if (velocityMagnitude > 10.0f)\n        {\n            // Primary direction: the direction the mouse is MOVING (velocity direction)\n            // FIX for issue #313 v4: Snap to 8 directions (4 cardinal + 4 diagonal)\n            // This compensates for imprecise human mouse movement while allowing diagonal throws\n            Vector2 rawDirection = releaseVelocity.Normalized();\n            throwDirection = SnapToOctantDirection(rawDirection);\n            LogToFile($\"[Player.Grenade] Raw direction: {rawDirection}, Snapped direction: {throwDirection}\");\n        }\n        else\n        {\n            // Fallback when mouse is not moving - use player-to-mouse as fallback direction\n            // FIX for issue #313 v4: Also snap fallback to 8 directions\n            Vector2 playerToMouse = dragEnd - GlobalPosition;\n            if (playerToMouse.Length() > 10.0f)\n            {\n                throwDirection = SnapToOctantDirection(playerToMouse.Normalized());\n            }\n            else\n            {\n                throwDirection = new Vector2(1, 0);  // Default direction (right)\n            }\n            // FIX for issue #313 v4: When velocity is 0, use a minimum throw speed\n            // This prevents grenade from getting \"stuck\" when user stops mouse before release\n            float minFallbackVelocity = 2000.0f;  // Minimum velocity to ensure grenade travels\n            velocityMagnitude = minFallbackVelocity;\n            LogToFile($\"[Player.Grenade] Fallback mode: Using minimum velocity {minFallbackVelocity:F1} px/s\");\n        }\n\n        LogToFile($\"[Player.Grenade] Throwing in mouse velocity direction! Direction: {throwDirection}, Mouse velocity: {velocityMagnitude:F1} px/s, Swing: {_totalSwingDistance:F1}\");\n\n        // Rotate player to face throw direction (prevents grenade hitting player when throwing upward)\n        RotatePlayerForThrow(throwDirection);\n\n        // Calculate intended spawn position (60px in front of player in throw direction)\n        float spawnOffset = 60.0f;\n        Vector2 intendedSpawnPosition = GlobalPosition + throwDirection * spawnOffset;\n\n        // FIXED: Raycast check to prevent spawning grenade behind/inside walls\n        // This fixes grenades passing through walls when thrown at close range (\"–≤ —É–ø–æ—Ä\")\n        Vector2 spawnPosition = GetSafeGrenadeSpawnPosition(GlobalPosition, intendedSpawnPosition, throwDirection);\n        _activeGrenade.GlobalPosition = spawnPosition;\n\n        // FIX for Issue #432: ALWAYS set velocity directly in C# as primary mechanism.\n        // GDScript methods called via Call() may silently fail in exported builds.\n        // Calculate throw speed using the same formula as GDScript\n        float multiplier = 0.5f;\n        float minSwing = 80.0f;\n        float maxSpeed = 850.0f;\n        float swingTransfer = Mathf.Clamp(_totalSwingDistance / minSwing, 0.0f, 0.65f);\n        float finalSpeed = Mathf.Min(velocityMagnitude * multiplier * (0.35f + swingTransfer), maxSpeed);\n\n        // FIX for Issue #432: Mark grenade as thrown BEFORE unfreezing to avoid race condition.\n        // If MarkAsThrown() is called after unfreezing, the BodyEntered signal could fire\n        // before IsThrown is set, causing impact detection to fail.\n        var grenadeTimer = _activeGrenade.GetNodeOrNull<GrenadeTimer>(\"GrenadeTimer\");\n        if (grenadeTimer != null)\n        {\n            grenadeTimer.MarkAsThrown();\n        }\n\n        // Unfreeze and set velocity directly\n        _activeGrenade.Freeze = false;\n        _activeGrenade.LinearVelocity = throwDirection * finalSpeed;\n        _activeGrenade.Rotation = throwDirection.Angle();\n\n        LogToFile($\"[Player.Grenade] C# set velocity directly: dir={throwDirection}, speed={finalSpeed:F1}, spawn={spawnPosition}\");\n\n        // Also try to call GDScript method for any additional setup\n        if (_activeGrenade.HasMethod(\"throw_grenade_with_direction\"))\n        {\n            _activeGrenade.Call(\"throw_grenade_with_direction\", throwDirection, velocityMagnitude, _totalSwingDistance);\n        }\n        else if (_activeGrenade.HasMethod(\"throw_grenade_velocity_based\"))\n        {\n            Vector2 directionalVelocity = throwDirection * velocityMagnitude;\n            _activeGrenade.Call(\"throw_grenade_velocity_based\", directionalVelocity, _totalSwingDistance);\n        }\n        else if (_activeGrenade.HasMethod(\"throw_grenade\"))\n        {\n            float legacyDistance = velocityMagnitude * 0.5f;\n            _activeGrenade.Call(\"throw_grenade\", throwDirection, legacyDistance);\n        }\n\n        // Emit signal\n        EmitSignal(SignalName.GrenadeThrown);\n\n        // Play grenade throw sound\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_grenade_throw\"))\n        {\n            audioManager.Call(\"play_grenade_throw\", GlobalPosition);\n        }\n\n        LogToFile($\"[Player.Grenade] Thrown! Velocity: {velocityMagnitude:F1}, Swing: {_totalSwingDistance:F1}\");\n\n        // Reset state (grenade is now independent)\n        ResetGrenadeState();\n    }\n\n    /// <summary>\n    /// Rotate player to face throw direction (with swing animation).\n    /// Prevents grenade from hitting player when throwing upward.\n    /// </summary>\n    /// <param name=\"throwDirection\">The direction of the throw.</param>\n    private void RotatePlayerForThrow(Vector2 throwDirection)\n    {\n        // Store current rotation to restore later\n        _playerRotationBeforeThrow = Rotation;\n\n        // Calculate target rotation (face throw direction)\n        _throwTargetRotation = throwDirection.Angle();\n\n        // Apply rotation immediately\n        Rotation = _throwTargetRotation;\n\n        // Start restore timer\n        _isThrowRotating = true;\n        _throwRotationRestoreTimer = ThrowRotationDuration;\n\n        LogToFile($\"[Player.Grenade] Player rotated for throw: {_playerRotationBeforeThrow} -> {_throwTargetRotation}\");\n    }\n\n    /// <summary>\n    /// Handle throw rotation animation - restore player rotation after throw.\n    /// </summary>\n    /// <param name=\"delta\">Time since last frame.</param>\n    private void HandleThrowRotationAnimation(float delta)\n    {\n        if (!_isThrowRotating)\n        {\n            return;\n        }\n\n        _throwRotationRestoreTimer -= delta;\n        if (_throwRotationRestoreTimer <= 0)\n        {\n            // Restore original rotation\n            Rotation = _playerRotationBeforeThrow;\n            _isThrowRotating = false;\n            LogToFile($\"[Player.Grenade] Player rotation restored to {_playerRotationBeforeThrow}\");\n        }\n    }\n\n    /// <summary>\n    /// Get a safe spawn position for the grenade that doesn't spawn behind/inside walls.\n    /// Uses raycast from player position to intended spawn position to detect walls.\n    /// If a wall is detected, spawns the grenade just before the wall (5px safety margin).\n    /// </summary>\n    /// <param name=\"fromPos\">The player's current position.</param>\n    /// <param name=\"intendedPos\">The intended spawn position (player + offset in throw direction).</param>\n    /// <param name=\"throwDirection\">The normalized throw direction.</param>\n    /// <returns>The safe spawn position for the grenade.</returns>\n    private Vector2 GetSafeGrenadeSpawnPosition(Vector2 fromPos, Vector2 intendedPos, Vector2 throwDirection)\n    {\n        // Get physics space state for raycasting\n        var spaceState = GetWorld2D().DirectSpaceState;\n        if (spaceState == null)\n        {\n            LogToFile(\"[Player.Grenade] Warning: Could not get DirectSpaceState for raycast\");\n            return intendedPos;\n        }\n\n        // Create raycast query from player to intended spawn position\n        // Collision mask 4 = obstacles layer (walls)\n        var query = PhysicsRayQueryParameters2D.Create(fromPos, intendedPos, 4);\n        query.Exclude = new Godot.Collections.Array<Rid> { GetRid() }; // Exclude self\n\n        var result = spaceState.IntersectRay(query);\n\n        // If no wall detected, use intended position\n        if (result.Count == 0)\n        {\n            return intendedPos;\n        }\n\n        // Wall detected! Calculate safe position (5px before the wall)\n        Vector2 wallPosition = (Vector2)result[\"position\"];\n        string colliderName = \"Unknown\";\n        if (result.ContainsKey(\"collider\"))\n        {\n            var collider = result[\"collider\"].AsGodotObject();\n            if (collider is Node node)\n            {\n                colliderName = node.Name;\n            }\n        }\n\n        float distanceToWall = fromPos.DistanceTo(wallPosition);\n        float safeDistance = Mathf.Max(distanceToWall - 5.0f, 10.0f); // At least 10px from player\n        Vector2 safePosition = fromPos + throwDirection * safeDistance;\n\n        LogToFile($\"[Player.Grenade] Wall detected at {wallPosition} (collider: {colliderName})! Adjusting spawn from {intendedPos} to {safePosition}\");\n\n        return safePosition;\n    }\n\n    /// <summary>\n    /// FIX for issue #313 v4: Snap raw mouse velocity direction to the nearest of 8 directions.\n    /// This compensates for imprecise human mouse movement while allowing diagonal throws.\n    ///\n    /// Uses 8 directions (45¬∞ sectors each):\n    /// - RIGHT (0¬∞): 0¬∞\n    /// - DOWN-RIGHT (45¬∞): 45¬∞\n    /// - DOWN (90¬∞): 90¬∞\n    /// - DOWN-LEFT (135¬∞): 135¬∞\n    /// - LEFT (180¬∞): 180¬∞\n    /// - UP-LEFT (-135¬∞): -135¬∞\n    /// - UP (-90¬∞): -90¬∞\n    /// - UP-RIGHT (-45¬∞): -45¬∞\n    /// </summary>\n    /// <param name=\"rawDirection\">The raw normalized direction from mouse velocity.</param>\n    /// <returns>The snapped direction (one of 8 unit vectors).</returns>\n    private Vector2 SnapToOctantDirection(Vector2 rawDirection)\n    {\n        float angle = rawDirection.Angle();  // Returns angle in radians (-PI to PI)\n        float sectorSize = Mathf.Pi / 4.0f;  // 45 degrees per sector (8 directions)\n        int sectorIndex = Mathf.RoundToInt(angle / sectorSize);\n        float snappedAngle = sectorIndex * sectorSize;\n        return new Vector2(Mathf.Cos(snappedAngle), Mathf.Sin(snappedAngle));\n    }\n\n    /// <summary>\n    /// Get current grenade count.\n    /// </summary>\n    public int GetCurrentGrenades()\n    {\n        return _currentGrenades;\n    }\n\n    /// <summary>\n    /// Get maximum grenade count.\n    /// </summary>\n    public int GetMaxGrenades()\n    {\n        return MaxGrenades;\n    }\n\n    /// <summary>\n    /// Add grenades to inventory (e.g., from pickup).\n    /// </summary>\n    /// <param name=\"count\">Number of grenades to add.</param>\n    public void AddGrenades(int count)\n    {\n        _currentGrenades = Mathf.Min(_currentGrenades + count, MaxGrenades);\n        EmitSignal(SignalName.GrenadeChanged, _currentGrenades, MaxGrenades);\n    }\n\n    /// <summary>\n    /// Check if player is preparing to throw a grenade.\n    /// </summary>\n    public bool IsPreparingGrenade()\n    {\n        return _grenadeState != GrenadeState.Idle;\n    }\n\n    #endregion\n\n    #region Grenade Animation Methods\n\n    /// <summary>\n    /// Start a new grenade animation phase.\n    /// </summary>\n    /// <param name=\"phase\">The GrenadeAnimPhase to transition to.</param>\n    /// <param name=\"duration\">How long this phase should last (for timed phases).</param>\n    private void StartGrenadeAnimPhase(GrenadeAnimPhase phase, float duration)\n    {\n        _grenadeAnimPhase = phase;\n        _grenadeAnimTimer = duration;\n        _grenadeAnimDuration = duration;\n\n        // Enable weapon sling when handling grenade\n        if (phase != GrenadeAnimPhase.None && phase != GrenadeAnimPhase.ReturnIdle)\n        {\n            _weaponSlung = true;\n        }\n        // RETURN_IDLE will unset _weaponSlung when animation completes\n\n        LogToFile($\"[Player.Grenade.Anim] Phase changed to: {phase} (duration: {duration:F2}s)\");\n    }\n\n    /// <summary>\n    /// Update grenade animation based on current phase.\n    /// Called every frame from _PhysicsProcess.\n    /// </summary>\n    /// <param name=\"delta\">Time since last frame.</param>\n    private void UpdateGrenadeAnimation(float delta)\n    {\n        // Early exit if no animation active\n        if (_grenadeAnimPhase == GrenadeAnimPhase.None)\n        {\n            // Restore normal z-index when not animating\n            RestoreArmZIndex();\n            return;\n        }\n\n        // Update phase timer\n        if (_grenadeAnimTimer > 0)\n        {\n            _grenadeAnimTimer -= delta;\n        }\n\n        // Calculate animation progress (0.0 to 1.0)\n        float progress = 1.0f;\n        if (_grenadeAnimDuration > 0)\n        {\n            progress = Mathf.Clamp(1.0f - (_grenadeAnimTimer / _grenadeAnimDuration), 0.0f, 1.0f);\n        }\n\n        // Calculate target positions based on current phase\n        Vector2 leftArmTarget = _baseLeftArmPos;\n        Vector2 rightArmTarget = _baseRightArmPos;\n        float leftArmRot = 0.0f;\n        float rightArmRot = 0.0f;\n        float lerpSpeed = AnimLerpSpeed * delta;\n\n        // Set arms to lower z-index during grenade operations (below weapon)\n        // This ensures arms appear below the weapon as user requested\n        SetGrenadeAnimZIndex();\n\n        switch (_grenadeAnimPhase)\n        {\n            case GrenadeAnimPhase.GrabGrenade:\n                // Left arm moves back to shoulder/chest area (away from weapon) to grab grenade\n                // Large negative X offset pulls the arm from weapon front (x=24) toward body (x~5)\n                leftArmTarget = _baseLeftArmPos + ArmLeftChest;\n                leftArmRot = Mathf.DegToRad(ArmRotGrab);\n                lerpSpeed = AnimLerpSpeedFast * delta;\n                break;\n\n            case GrenadeAnimPhase.PullPin:\n                // Left hand holds grenade at chest level, right hand pulls pin\n                leftArmTarget = _baseLeftArmPos + ArmLeftExtended;\n                leftArmRot = Mathf.DegToRad(ArmRotLeftAtChest);\n                rightArmTarget = _baseRightArmPos + ArmRightPin;\n                rightArmRot = Mathf.DegToRad(ArmRotPinPull);\n                lerpSpeed = AnimLerpSpeedFast * delta;\n                break;\n\n            case GrenadeAnimPhase.HandsApproach:\n                // Both hands at chest level, preparing for transfer\n                leftArmTarget = _baseLeftArmPos + ArmLeftExtended;\n                leftArmRot = Mathf.DegToRad(ArmRotLeftAtChest);\n                rightArmTarget = _baseRightArmPos + ArmRightApproach;\n                break;\n\n            case GrenadeAnimPhase.Transfer:\n                // Left arm drops back toward body, right hand takes grenade\n                leftArmTarget = _baseLeftArmPos + ArmLeftTransfer;\n                leftArmRot = Mathf.DegToRad(ArmRotLeftRelaxed * 0.5f);\n                rightArmTarget = _baseRightArmPos + ArmRightHold;\n                lerpSpeed = AnimLerpSpeed * delta;\n                break;\n\n            case GrenadeAnimPhase.WindUp:\n                // LEFT ARM: Fully retracted to shoulder/body area, hangs at side\n                // This is the key position - arm must be clearly NOT on the weapon\n                leftArmTarget = _baseLeftArmPos + ArmLeftRelaxed;\n                leftArmRot = Mathf.DegToRad(ArmRotLeftRelaxed);\n                // RIGHT ARM: Interpolate between min and max wind-up based on intensity\n                Vector2 windUpOffset = ArmRightWindMin.Lerp(ArmRightWindMax, _windUpIntensity);\n                rightArmTarget = _baseRightArmPos + windUpOffset;\n                float windUpRot = Mathf.Lerp(ArmRotWindMin, ArmRotWindMax, _windUpIntensity);\n                rightArmRot = Mathf.DegToRad(windUpRot);\n                lerpSpeed = AnimLerpSpeedFast * delta; // Responsive to input\n                break;\n\n            case GrenadeAnimPhase.Throw:\n                // Throwing motion - right arm swings forward, left stays at body\n                leftArmTarget = _baseLeftArmPos + ArmLeftRelaxed;\n                leftArmRot = Mathf.DegToRad(ArmRotLeftRelaxed);\n                rightArmTarget = _baseRightArmPos + ArmRightThrow;\n                rightArmRot = Mathf.DegToRad(ArmRotThrow);\n                lerpSpeed = AnimLerpSpeedFast * delta;\n\n                // When throw animation completes, transition to return\n                if (_grenadeAnimTimer <= 0)\n                {\n                    StartGrenadeAnimPhase(GrenadeAnimPhase.ReturnIdle, AnimReturnDuration);\n                }\n                break;\n\n            case GrenadeAnimPhase.ReturnIdle:\n                // Arms returning to base positions (back to holding weapon)\n                leftArmTarget = _baseLeftArmPos;\n                rightArmTarget = _baseRightArmPos;\n                lerpSpeed = AnimLerpSpeed * delta;\n\n                // When return animation completes, end animation\n                if (_grenadeAnimTimer <= 0)\n                {\n                    _grenadeAnimPhase = GrenadeAnimPhase.None;\n                    _weaponSlung = false;\n                    RestoreArmZIndex();\n                    LogToFile(\"[Player.Grenade.Anim] Animation complete, returning to normal\");\n                }\n                break;\n        }\n\n        // Apply arm positions with smooth interpolation\n        if (_leftArmSprite != null)\n        {\n            _leftArmSprite.Position = _leftArmSprite.Position.Lerp(leftArmTarget, lerpSpeed);\n            _leftArmSprite.Rotation = Mathf.Lerp(_leftArmSprite.Rotation, leftArmRot, lerpSpeed);\n        }\n\n        if (_rightArmSprite != null)\n        {\n            _rightArmSprite.Position = _rightArmSprite.Position.Lerp(rightArmTarget, lerpSpeed);\n            _rightArmSprite.Rotation = Mathf.Lerp(_rightArmSprite.Rotation, rightArmRot, lerpSpeed);\n        }\n\n        // Update weapon sling animation\n        UpdateWeaponSling(delta);\n    }\n\n    /// <summary>\n    /// Set arm z-index for grenade animation (arms below weapon).\n    /// </summary>\n    private void SetGrenadeAnimZIndex()\n    {\n        // During grenade operations, arms should appear below the weapon\n        // Weapon has z_index = 1, so set arms to 0\n        if (_leftArmSprite != null)\n        {\n            _leftArmSprite.ZIndex = 0;\n        }\n        if (_rightArmSprite != null)\n        {\n            _rightArmSprite.ZIndex = 0;\n        }\n    }\n\n    /// <summary>\n    /// Restore normal arm z-index (arms above weapon for normal aiming).\n    /// </summary>\n    private void RestoreArmZIndex()\n    {\n        // Normal state: arms at z_index 2 (between body and head)\n        if (_leftArmSprite != null)\n        {\n            _leftArmSprite.ZIndex = 2;\n        }\n        if (_rightArmSprite != null)\n        {\n            _rightArmSprite.ZIndex = 2;\n        }\n    }\n\n    /// <summary>\n    /// Update weapon sling position (lower weapon when handling grenade).\n    /// </summary>\n    /// <param name=\"delta\">Time since last frame.</param>\n    private void UpdateWeaponSling(float delta)\n    {\n        if (_weaponMount == null)\n        {\n            return;\n        }\n\n        Vector2 targetPos = _baseWeaponMountPos;\n        float targetRot = _baseWeaponMountRot;\n\n        if (_weaponSlung)\n        {\n            // Lower weapon to chest/sling position\n            targetPos = _baseWeaponMountPos + WeaponSlingOffset;\n            targetRot = _baseWeaponMountRot + WeaponSlingRotation;\n        }\n\n        float lerpSpeed = AnimLerpSpeed * delta;\n        _weaponMount.Position = _weaponMount.Position.Lerp(targetPos, lerpSpeed);\n        _weaponMount.Rotation = Mathf.Lerp(_weaponMount.Rotation, targetRot, lerpSpeed);\n    }\n\n    /// <summary>\n    /// Update wind-up intensity and track mouse velocity during aiming.\n    /// Uses velocity-based physics for realistic throwing.\n    /// </summary>\n    private void UpdateWindUpIntensity()\n    {\n        Vector2 currentMouse = GetGlobalMousePosition();\n        double currentTime = Time.GetTicksMsec() / 1000.0;\n\n        // Calculate time delta since last frame\n        double deltaTime = currentTime - _prevFrameTime;\n        if (deltaTime <= 0.0)\n        {\n            deltaTime = 0.016; // Default to ~60fps if first frame\n        }\n\n        // Calculate mouse displacement since last frame\n        Vector2 mouseDelta = currentMouse - _prevMousePos;\n\n        // Accumulate total swing distance for momentum transfer calculation\n        _totalSwingDistance += mouseDelta.Length();\n\n        // Calculate instantaneous mouse velocity (pixels per second)\n        Vector2 instantaneousVelocity = mouseDelta / (float)deltaTime;\n\n        // Add to velocity history for smoothing\n        _mouseVelocityHistory.Add(instantaneousVelocity);\n        if (_mouseVelocityHistory.Count > MouseVelocityHistorySize)\n        {\n            _mouseVelocityHistory.RemoveAt(0);\n        }\n\n        // Calculate average velocity from history (smoothed velocity)\n        Vector2 velocitySum = Vector2.Zero;\n        foreach (Vector2 vel in _mouseVelocityHistory)\n        {\n            velocitySum += vel;\n        }\n        _currentMouseVelocity = velocitySum / Math.Max(_mouseVelocityHistory.Count, 1);\n\n        // Calculate wind-up intensity based on velocity (for animation)\n        // Higher velocity = more wind-up visual effect\n        float velocityMagnitude = _currentMouseVelocity.Length();\n        // Normalize to a reasonable range (0-2000 pixels/second typical for fast mouse movement)\n        float velocityIntensity = Mathf.Clamp(velocityMagnitude / 1500.0f, 0.0f, 1.0f);\n\n        _windUpIntensity = velocityIntensity;\n\n        // Update tracking for next frame\n        _prevMousePos = currentMouse;\n        _prevFrameTime = currentTime;\n    }\n\n    #endregion\n\n    #region Reload Animation Methods\n\n    /// <summary>\n    /// Start a new reload animation phase.\n    /// </summary>\n    /// <param name=\"phase\">The ReloadAnimPhase to transition to.</param>\n    /// <param name=\"duration\">How long this phase should last.</param>\n    private void StartReloadAnimPhase(ReloadAnimPhase phase, float duration)\n    {\n        _reloadAnimPhase = phase;\n        _reloadAnimTimer = duration;\n        _reloadAnimDuration = duration;\n\n        // Reset bolt pull sub-phase when entering bolt pull phase\n        if (phase == ReloadAnimPhase.PullBolt)\n        {\n            _boltPullSubPhase = 0;\n        }\n\n        LogToFile($\"[Player.Reload.Anim] Phase changed to: {phase} (duration: {duration:F2}s)\");\n    }\n\n    /// <summary>\n    /// Set arm z-index for reload animation (arms BELOW weapon).\n    /// User feedback: animated hand should be below weapon, not above it.\n    /// </summary>\n    private void SetReloadAnimZIndex()\n    {\n        // During reload operations, arms should appear BELOW the weapon\n        // Weapon has z_index = 1, so set arms to 0\n        if (_leftArmSprite != null)\n        {\n            _leftArmSprite.ZIndex = 0;\n        }\n        if (_rightArmSprite != null)\n        {\n            _rightArmSprite.ZIndex = 0;\n        }\n    }\n\n    /// <summary>\n    /// Update reload animation based on current phase.\n    /// Called every frame from _PhysicsProcess.\n    /// </summary>\n    /// <param name=\"delta\">Time since last frame.</param>\n    private void UpdateReloadAnimation(float delta)\n    {\n        // Early exit if no animation active\n        if (_reloadAnimPhase == ReloadAnimPhase.None)\n        {\n            // Restore normal z-index when not animating\n            RestoreArmZIndex();\n            return;\n        }\n\n        // Update phase timer\n        if (_reloadAnimTimer > 0)\n        {\n            _reloadAnimTimer -= delta;\n        }\n\n        // Calculate target positions based on current phase\n        Vector2 leftArmTarget = _baseLeftArmPos;\n        Vector2 rightArmTarget = _baseRightArmPos;\n        float leftArmRot = 0.0f;\n        float rightArmRot = 0.0f;\n        float lerpSpeed = AnimLerpSpeed * delta;\n\n        // Set arms to lower z-index during reload operations (BELOW weapon)\n        // User feedback: \"animated hand should be below weapon, not above it\"\n        SetReloadAnimZIndex();\n\n        switch (_reloadAnimPhase)\n        {\n            case ReloadAnimPhase.GrabMagazine:\n                // Step 1: Left arm moves to chest to grab new magazine\n                leftArmTarget = _baseLeftArmPos + ReloadArmLeftGrab;\n                leftArmRot = Mathf.DegToRad(ReloadArmRotLeftGrab);\n                rightArmTarget = _baseRightArmPos + ReloadArmRightHold;\n                rightArmRot = Mathf.DegToRad(ReloadArmRotRightHold);\n                lerpSpeed = AnimLerpSpeedFast * delta;\n                break;\n\n            case ReloadAnimPhase.InsertMagazine:\n                // Step 2: Left arm brings magazine to weapon magwell (at middle of weapon)\n                // User feedback: \"step 2 should end at middle of weapon length, not at the end\"\n                leftArmTarget = _baseLeftArmPos + ReloadArmLeftInsert;\n                leftArmRot = Mathf.DegToRad(ReloadArmRotLeftInsert);\n                rightArmTarget = _baseRightArmPos + ReloadArmRightSteady;\n                rightArmRot = Mathf.DegToRad(ReloadArmRotRightSteady);\n                lerpSpeed = AnimLerpSpeed * delta;\n                break;\n\n            case ReloadAnimPhase.PullBolt:\n                // Step 3: Right hand traces rifle contour - back and forth motion\n                // User feedback: \"step 3 should be a movement along the rifle contour\n                // right towards and away from oneself (back and forth)\"\n                leftArmTarget = _baseLeftArmPos + ReloadArmLeftSupport;\n                leftArmRot = Mathf.DegToRad(ReloadArmRotLeftSupport);\n\n                if (_boltPullSubPhase == 0)\n                {\n                    // Sub-phase 0: Pull bolt back (toward player)\n                    rightArmTarget = _baseRightArmPos + ReloadArmRightBoltPull;\n                    rightArmRot = Mathf.DegToRad(ReloadArmRotRightBoltPull);\n                    lerpSpeed = AnimLerpSpeedFast * delta;\n\n                    // Log bolt pull progress periodically\n                    if (Engine.GetFramesDrawn() % 30 == 0)\n                    {\n                        LogToFile($\"[Player.Reload.Anim] Bolt sub-phase 0 (pull back): timer={_reloadAnimTimer:F2}s, rightArm target={rightArmTarget}\");\n                    }\n\n                    // When pull back completes, transition to return forward\n                    if (_reloadAnimTimer <= 0)\n                    {\n                        _boltPullSubPhase = 1;\n                        _reloadAnimTimer = ReloadAnimBoltReturnDuration;\n                        _reloadAnimDuration = ReloadAnimBoltReturnDuration;\n                        LogToFile($\"[Player.Reload.Anim] Bolt sub-phase transition: pull‚Üíreturn (duration: {ReloadAnimBoltReturnDuration:F2}s)\");\n                    }\n                }\n                else\n                {\n                    // Sub-phase 1: Release bolt (return forward)\n                    rightArmTarget = _baseRightArmPos + ReloadArmRightBoltReturn;\n                    rightArmRot = Mathf.DegToRad(ReloadArmRotRightBoltReturn);\n                    lerpSpeed = AnimLerpSpeedFast * delta;\n\n                    // Log bolt return progress periodically\n                    if (Engine.GetFramesDrawn() % 30 == 0)\n                    {\n                        LogToFile($\"[Player.Reload.Anim] Bolt sub-phase 1 (return): timer={_reloadAnimTimer:F2}s, rightArm target={rightArmTarget}\");\n                    }\n\n                    // When return completes, transition to return idle\n                    if (_reloadAnimTimer <= 0)\n                    {\n                        LogToFile(\"[Player.Reload.Anim] Bolt animation complete, transitioning to idle\");\n                        StartReloadAnimPhase(ReloadAnimPhase.ReturnIdle, ReloadAnimReturnDuration);\n                    }\n                }\n                break;\n\n            case ReloadAnimPhase.ReturnIdle:\n                // Arms returning to base positions\n                leftArmTarget = _baseLeftArmPos;\n                rightArmTarget = _baseRightArmPos;\n                leftArmRot = 0.0f;\n                rightArmRot = 0.0f;\n                lerpSpeed = AnimLerpSpeed * delta;\n\n                // When return animation completes, end animation and restore z-index\n                if (_reloadAnimTimer <= 0)\n                {\n                    _reloadAnimPhase = ReloadAnimPhase.None;\n                    RestoreArmZIndex();\n                    LogToFile(\"[Player.Reload.Anim] Animation complete, returning to normal\");\n                }\n                break;\n        }\n\n        // Apply arm positions with smooth interpolation\n        if (_leftArmSprite != null)\n        {\n            Vector2 oldPos = _leftArmSprite.Position;\n            _leftArmSprite.Position = _leftArmSprite.Position.Lerp(leftArmTarget, lerpSpeed);\n            _leftArmSprite.Rotation = Mathf.Lerp(_leftArmSprite.Rotation, leftArmRot, lerpSpeed);\n\n            // Log arm position changes periodically (every 60 frames = ~1 second)\n            if (Engine.GetFramesDrawn() % 60 == 0)\n            {\n                LogToFile($\"[Player.Reload.Anim] LeftArm: pos={_leftArmSprite.Position}, target={leftArmTarget}, base={_baseLeftArmPos}\");\n            }\n        }\n        else if (Engine.GetFramesDrawn() % 60 == 0)\n        {\n            LogToFile(\"[Player.Reload.Anim] WARNING: Left arm sprite is null during animation!\");\n        }\n\n        if (_rightArmSprite != null)\n        {\n            Vector2 oldPos = _rightArmSprite.Position;\n            _rightArmSprite.Position = _rightArmSprite.Position.Lerp(rightArmTarget, lerpSpeed);\n            _rightArmSprite.Rotation = Mathf.Lerp(_rightArmSprite.Rotation, rightArmRot, lerpSpeed);\n\n            // Log arm position changes periodically (every 60 frames = ~1 second)\n            if (Engine.GetFramesDrawn() % 60 == 0)\n            {\n                LogToFile($\"[Player.Reload.Anim] RightArm: pos={_rightArmSprite.Position}, target={rightArmTarget}, base={_baseRightArmPos}\");\n            }\n        }\n        else if (Engine.GetFramesDrawn() % 60 == 0)\n        {\n            LogToFile(\"[Player.Reload.Anim] WARNING: Right arm sprite is null during animation!\");\n        }\n    }\n\n    #endregion\n\n    #region Logging\n\n    /// <summary>\n    /// Logs a message to the FileLogger (GDScript autoload) for debugging.\n    /// </summary>\n    /// <param name=\"message\">The message to log.</param>\n    private void LogToFile(string message)\n    {\n        // Print to console\n        GD.Print(message);\n\n        // Also log to FileLogger if available\n        var fileLogger = GetNodeOrNull(\"/root/FileLogger\");\n        if (fileLogger != null && fileLogger.HasMethod(\"log_info\"))\n        {\n            fileLogger.Call(\"log_info\", message);\n        }\n    }\n\n    #endregion\n\n    #region Debug Trajectory Visualization\n\n    /// <summary>\n    /// Connects to GameManager's debug_mode_toggled and invincibility_toggled signals.\n    /// </summary>\n    private void ConnectDebugModeSignal()\n    {\n        var gameManager = GetNodeOrNull(\"/root/GameManager\");\n        if (gameManager == null)\n        {\n            LogToFile(\"[Player.Debug] WARNING: GameManager not found, debug visualization disabled\");\n            return;\n        }\n\n        // Connect to debug mode signal (F7)\n        if (gameManager.HasSignal(\"debug_mode_toggled\"))\n        {\n            gameManager.Connect(\"debug_mode_toggled\", Callable.From<bool>(OnDebugModeToggled));\n\n            // Check if debug mode is already enabled\n            if (gameManager.HasMethod(\"is_debug_mode_enabled\"))\n            {\n                _debugModeEnabled = (bool)gameManager.Call(\"is_debug_mode_enabled\");\n                LogToFile($\"[Player.Debug] Connected to GameManager, debug mode: {_debugModeEnabled}\");\n            }\n        }\n        else\n        {\n            LogToFile(\"[Player.Debug] WARNING: GameManager doesn't have debug_mode_toggled signal\");\n        }\n\n        // Connect to invincibility mode signal (F6)\n        if (gameManager.HasSignal(\"invincibility_toggled\"))\n        {\n            gameManager.Connect(\"invincibility_toggled\", Callable.From<bool>(OnInvincibilityToggled));\n\n            // Check if invincibility mode is already enabled\n            if (gameManager.HasMethod(\"is_invincibility_enabled\"))\n            {\n                _invincibilityEnabled = (bool)gameManager.Call(\"is_invincibility_enabled\");\n                LogToFile($\"[Player.Debug] Connected to GameManager, invincibility mode: {_invincibilityEnabled}\");\n                UpdateInvincibilityIndicator();\n            }\n        }\n        else\n        {\n            LogToFile(\"[Player.Debug] WARNING: GameManager doesn't have invincibility_toggled signal\");\n        }\n    }\n\n    /// <summary>\n    /// Called when debug mode is toggled via F7 key.\n    /// </summary>\n    /// <param name=\"enabled\">True if debug mode is now enabled.</param>\n    private void OnDebugModeToggled(bool enabled)\n    {\n        _debugModeEnabled = enabled;\n        QueueRedraw();\n        LogToFile($\"[Player.Debug] Debug mode toggled: {(enabled ? \"ON\" : \"OFF\")}\");\n    }\n\n    /// <summary>\n    /// Called when invincibility mode is toggled via F6 key.\n    /// </summary>\n    /// <param name=\"enabled\">True if invincibility mode is now enabled.</param>\n    private void OnInvincibilityToggled(bool enabled)\n    {\n        _invincibilityEnabled = enabled;\n        UpdateInvincibilityIndicator();\n        LogToFile($\"[Player] Invincibility mode: {(enabled ? \"ON\" : \"OFF\")}\");\n    }\n\n    /// <summary>\n    /// Updates the visual indicator for invincibility mode.\n    /// Shows \"INVINCIBLE\" label when enabled, hides it when disabled.\n    /// </summary>\n    private void UpdateInvincibilityIndicator()\n    {\n        // Create label if it doesn't exist\n        if (_invincibilityLabel == null)\n        {\n            _invincibilityLabel = new Label();\n            _invincibilityLabel.Name = \"InvincibilityLabel\";\n            _invincibilityLabel.Text = \"–ë–ï–°–°–ú–ï–†–¢–ò–ï\";\n            _invincibilityLabel.HorizontalAlignment = HorizontalAlignment.Center;\n            _invincibilityLabel.VerticalAlignment = VerticalAlignment.Center;\n\n            // Position above the player\n            _invincibilityLabel.Position = new Vector2(-60, -80);\n            _invincibilityLabel.Size = new Vector2(120, 30);\n\n            // Style: bright yellow/gold color with outline for visibility\n            _invincibilityLabel.AddThemeColorOverride(\"font_color\", new Color(1.0f, 0.9f, 0.2f, 1.0f));\n            _invincibilityLabel.AddThemeColorOverride(\"font_outline_color\", new Color(0.0f, 0.0f, 0.0f, 1.0f));\n            _invincibilityLabel.AddThemeFontSizeOverride(\"font_size\", 14);\n            _invincibilityLabel.AddThemeConstantOverride(\"outline_size\", 3);\n\n            AddChild(_invincibilityLabel);\n        }\n\n        // Show/hide based on invincibility state\n        _invincibilityLabel.Visible = _invincibilityEnabled;\n    }\n\n    /// <summary>\n    /// Override _Draw to visualize grenade trajectory.\n    /// In simple mode: Always shows trajectory preview (semi-transparent arc).\n    /// In complex mode: Only shows when debug mode is enabled (F7).\n    /// </summary>\n    public override void _Draw()\n    {\n        // Determine if we should draw trajectory\n        bool isSimpleAiming = _grenadeState == GrenadeState.SimpleAiming;\n        bool isComplexAiming = _grenadeState == GrenadeState.Aiming;\n\n        // In simple mode: always show trajectory\n        // In complex mode: only show if debug mode is enabled\n        if (!isSimpleAiming && !(isComplexAiming && _debugModeEnabled))\n        {\n            return;\n        }\n\n        // Use different colors for simple mode (more subtle) vs debug mode (bright)\n        Color colorTrajectory;\n        Color colorLanding;\n        Color colorRadius;\n        float lineWidth;\n\n        if (isSimpleAiming)\n        {\n            // Semi-transparent colors for simple mode\n            colorTrajectory = new Color(1.0f, 1.0f, 1.0f, 0.4f); // White semi-transparent\n            colorLanding = new Color(1.0f, 0.8f, 0.2f, 0.6f); // Yellow-orange\n            colorRadius = new Color(1.0f, 0.5f, 0.0f, 0.2f); // Effect radius\n            lineWidth = 2.0f;\n        }\n        else\n        {\n            // Bright colors for debug mode\n            colorTrajectory = new Color(1.0f, 0.8f, 0.2f, 0.9f);\n            colorLanding = new Color(1.0f, 0.3f, 0.1f, 0.9f);\n            colorRadius = new Color(1.0f, 0.5f, 0.0f, 0.3f);\n            lineWidth = 3.0f;\n        }\n\n        // Calculate throw parameters\n        Vector2 currentMousePos = GetGlobalMousePosition();\n        Vector2 throwDirection;\n        float throwSpeed;\n        float landingDistance;\n        const float SpawnOffset = 60.0f;\n\n        // Get grenade's actual physics properties for accurate visualization\n        // FIX for issue #398: Use actual grenade properties instead of hardcoded values\n        float groundFriction = 300.0f; // Default\n        float maxThrowSpeed = 850.0f;  // Default\n        if (_activeGrenade != null && IsInstanceValid(_activeGrenade))\n        {\n            if (_activeGrenade.Get(\"ground_friction\").VariantType != Variant.Type.Nil)\n            {\n                groundFriction = (float)_activeGrenade.Get(\"ground_friction\");\n            }\n            if (_activeGrenade.Get(\"max_throw_speed\").VariantType != Variant.Type.Nil)\n            {\n                maxThrowSpeed = (float)_activeGrenade.Get(\"max_throw_speed\");\n            }\n        }\n\n        if (isSimpleAiming)\n        {\n            // Simple mode: direction and distance based on cursor position\n            Vector2 toTarget = currentMousePos - GlobalPosition;\n            throwDirection = toTarget.Length() > 10.0f ? toTarget.Normalized() : new Vector2(1, 0);\n\n            // FIX for issue #398: Account for spawn offset in distance calculation\n            // The grenade starts 60 pixels ahead of the player\n            Vector2 spawnPos = GlobalPosition + throwDirection * SpawnOffset;\n            float throwDistance = (currentMousePos - spawnPos).Length();\n            if (throwDistance < 10.0f) throwDistance = 10.0f;\n\n            // Calculate throw speed needed to reach target\n            float requiredSpeed = Mathf.Sqrt(2.0f * groundFriction * throwDistance);\n            throwSpeed = Mathf.Min(requiredSpeed, maxThrowSpeed);\n\n            // Calculate actual landing distance with clamped speed\n            landingDistance = (throwSpeed * throwSpeed) / (2.0f * groundFriction);\n        }\n        else\n        {\n            // Complex mode: direction based on mouse velocity\n            Vector2 releaseVelocity = _currentMouseVelocity;\n            float velocityMagnitude = releaseVelocity.Length();\n            Vector2 dragVector = currentMousePos - _grenadeDragStart;\n\n            if (velocityMagnitude > 10.0f)\n            {\n                throwDirection = SnapToOctantDirection(releaseVelocity.Normalized());\n            }\n            else if (dragVector.Length() > 5.0f)\n            {\n                throwDirection = SnapToOctantDirection(dragVector.Normalized());\n            }\n            else\n            {\n                throwDirection = new Vector2(1, 0);\n            }\n\n            // Calculate velocity-based throw speed\n            const float GrenadeMass = 0.36f;\n            const float MouseVelocityMultiplier = 1.5f;\n            const float MinSwingDistance = 180.0f;\n            const float MinThrowSpeed = 100.0f;\n            const float MaxThrowSpeed = 2500.0f;\n\n            float massRatio = GrenadeMass / 0.4f;\n            float adjustedMinSwing = MinSwingDistance * massRatio;\n            float transferEfficiency = Mathf.Clamp(_totalSwingDistance / adjustedMinSwing, 0.0f, 1.0f);\n            float massMultiplier = 1.0f / Mathf.Sqrt(massRatio);\n\n            throwSpeed = velocityMagnitude * MouseVelocityMultiplier * transferEfficiency * massMultiplier;\n            throwSpeed = Mathf.Clamp(throwSpeed, MinThrowSpeed, MaxThrowSpeed);\n\n            if (velocityMagnitude < 10.0f)\n            {\n                throwSpeed = MinThrowSpeed * 0.5f;\n            }\n\n            landingDistance = (throwSpeed * throwSpeed) / (2.0f * groundFriction);\n        }\n\n        // Calculate spawn and landing positions\n        Vector2 spawnPosition = GlobalPosition + throwDirection * SpawnOffset;\n        Vector2 landingPosition = spawnPosition + throwDirection * landingDistance;\n\n        // Convert to local coordinates for drawing\n        Vector2 localStart = ToLocal(spawnPosition);\n        Vector2 localEnd = ToLocal(landingPosition);\n\n        // Draw trajectory line with dashes\n        DrawTrajectoryLine(localStart, localEnd, colorTrajectory, lineWidth);\n\n        // Draw landing point indicator (circle with X)\n        DrawLandingIndicator(localEnd, colorLanding, 12.0f);\n\n        // Draw effect radius circle at landing position\n        float effectRadius = GetGrenadeEffectRadius();\n        DrawCircleOutline(localEnd, effectRadius, colorRadius, 2.0f);\n\n        // In complex mode, also draw velocity direction arrow\n        if (isComplexAiming)\n        {\n            Vector2 localPlayerCenter = Vector2.Zero;\n            Vector2 arrowEnd = localPlayerCenter + throwDirection * 40.0f;\n            DrawArrow(localPlayerCenter, arrowEnd, new Color(0.2f, 1.0f, 0.2f, 0.7f), 2.0f);\n        }\n    }\n\n    /// <summary>\n    /// Get the effect radius of the current grenade type.\n    /// FIX for Issue #432: Use type-based defaults when GDScript Call() fails in exports.\n    /// </summary>\n    private float GetGrenadeEffectRadius()\n    {\n        if (_activeGrenade != null && IsInstanceValid(_activeGrenade))\n        {\n            // Try to call GDScript method first\n            if (_activeGrenade.HasMethod(\"_get_effect_radius\"))\n            {\n                var result = _activeGrenade.Call(\"_get_effect_radius\");\n                if (result.VariantType != Variant.Type.Nil)\n                {\n                    return (float)result;\n                }\n            }\n\n            // Try to read effect_radius property directly\n            if (_activeGrenade.Get(\"effect_radius\").VariantType != Variant.Type.Nil)\n            {\n                return (float)_activeGrenade.Get(\"effect_radius\");\n            }\n\n            // FIX for Issue #432: Use type-based defaults matching scene files\n            // GDScript property access may fail silently in exported builds\n            var script = _activeGrenade.GetScript();\n            if (script.Obj != null)\n            {\n                string scriptPath = ((Script)script.Obj).ResourcePath;\n                if (scriptPath.Contains(\"frag_grenade\"))\n                {\n                    return 225.0f;  // FragGrenade.tscn default\n                }\n            }\n        }\n        // Default: Flashbang effect radius (FlashbangGrenade.tscn)\n        return 400.0f;\n    }\n\n    /// <summary>\n    /// Draw a circle outline at the specified position.\n    /// </summary>\n    private void DrawCircleOutline(Vector2 position, float radius, Color color, float width)\n    {\n        const int segments = 32;\n        var points = new List<Vector2>();\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            points.Add(position + new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * radius);\n        }\n        for (int i = 0; i < points.Count - 1; i++)\n        {\n            DrawLine(points[i], points[i + 1], color, width);\n        }\n    }\n\n    /// <summary>\n    /// Draw a dashed trajectory line from start to end.\n    /// </summary>\n    private void DrawTrajectoryLine(Vector2 start, Vector2 end, Color color, float width)\n    {\n        Vector2 direction = (end - start).Normalized();\n        float totalLength = start.DistanceTo(end);\n        const float DashLength = 15.0f;\n        const float GapLength = 8.0f;\n\n        float currentPos = 0.0f;\n        while (currentPos < totalLength)\n        {\n            float dashEnd = Mathf.Min(currentPos + DashLength, totalLength);\n            Vector2 dashStart = start + direction * currentPos;\n            Vector2 dashEndPos = start + direction * dashEnd;\n            DrawLine(dashStart, dashEndPos, color, width);\n            currentPos = dashEnd + GapLength;\n        }\n    }\n\n    /// <summary>\n    /// Draw a landing indicator (circle with X) at the target position.\n    /// </summary>\n    private void DrawLandingIndicator(Vector2 position, Color color, float radius)\n    {\n        // Draw outer circle\n        const int CirclePoints = 24;\n        Vector2[] circlePoints = new Vector2[CirclePoints + 1];\n        for (int i = 0; i <= CirclePoints; i++)\n        {\n            float angle = i * Mathf.Tau / CirclePoints;\n            circlePoints[i] = position + new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * radius;\n        }\n        for (int i = 0; i < CirclePoints; i++)\n        {\n            DrawLine(circlePoints[i], circlePoints[i + 1], color, 2.0f);\n        }\n\n        // Draw X inside\n        float xSize = radius * 0.6f;\n        DrawLine(position + new Vector2(-xSize, -xSize), position + new Vector2(xSize, xSize), color, 2.0f);\n        DrawLine(position + new Vector2(-xSize, xSize), position + new Vector2(xSize, -xSize), color, 2.0f);\n    }\n\n    /// <summary>\n    /// Draw an arrow from start to end with an arrowhead.\n    /// </summary>\n    private void DrawArrow(Vector2 start, Vector2 end, Color color, float width)\n    {\n        // Draw main line\n        DrawLine(start, end, color, width);\n\n        // Draw arrowhead\n        Vector2 direction = (end - start).Normalized();\n        float arrowSize = 8.0f;\n        float arrowAngle = Mathf.Pi / 6.0f; // 30 degrees\n\n        Vector2 arrowLeft = end - direction.Rotated(arrowAngle) * arrowSize;\n        Vector2 arrowRight = end - direction.Rotated(-arrowAngle) * arrowSize;\n\n        DrawLine(end, arrowLeft, color, width);\n        DrawLine(end, arrowRight, color, width);\n    }\n\n    #endregion\n}\n",
    "structuredPatch": [
      {
        "oldStart": 1974,
        "oldLines": 6,
        "newStart": 1974,
        "newLines": 11,
        "lines": [
          "                 }",
          "             }",
          "         }",
          "+        // Handle mouse movement for scope fine-tuning (closer/further by ~1/3 viewport)",
          "+        else if (@event is InputEventMouseMotion mouseMotion)",
          "+        {",
          "+            sniperRifle.AdjustScopeFineTune(mouseMotion.Relative);",
          "+        }",
          "     }",
          " ",
          "     #endregion"
        ]
      }
    ],
    "userModified": false,
    "replaceAll": false
  }
}
[2026-02-06T20:58:09.786Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01Nh4sGHmomQd2pR6K8nF73v",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now let me update the zoom label to also show the fine-tune offset:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 760,
      "cache_read_input_tokens": 62994,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 760
      },
      "output_tokens": 6,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "ce1c9f5a-cd11-4c64-8623-a247548e4fdb"
}
[2026-02-06T20:58:12.108Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01Nh4sGHmomQd2pR6K8nF73v",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01V98tdFNrhKEazXkNJCaunJ",
        "name": "Edit",
        "input": {
          "replace_all": false,
          "file_path": "/tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs",
          "old_string": "        // Update zoom label\n        var zoomLabel = _scopeCrosshair.GetNodeOrNull<Label>(\"ZoomLabel\");\n        if (zoomLabel != null)\n        {\n            zoomLabel.Text = $\"{_scopeZoomDistance:F1}x\";\n        }",
          "new_string": "        // Update zoom label showing effective zoom distance\n        var zoomLabel = _scopeCrosshair.GetNodeOrNull<Label>(\"ZoomLabel\");\n        if (zoomLabel != null)\n        {\n            zoomLabel.Text = $\"{EffectiveScopeZoomDistance:F1}x\";\n        }"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 760,
      "cache_read_input_tokens": 62994,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 760
      },
      "output_tokens": 6,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "b09cd3d5-d3f5-46c4-87b2-62462f52f477"
}
[2026-02-06T20:58:12.113Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01V98tdFNrhKEazXkNJCaunJ",
        "type": "tool_result",
        "content": "The file /tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs has been updated successfully."
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "7b2a8391-41b3-4ba7-8ed7-ec9bcbeadc80",
  "tool_use_result": {
    "filePath": "/tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SniperRifle.cs",
    "oldString": "        // Update zoom label\n        var zoomLabel = _scopeCrosshair.GetNodeOrNull<Label>(\"ZoomLabel\");\n        if (zoomLabel != null)\n        {\n            zoomLabel.Text = $\"{_scopeZoomDistance:F1}x\";\n        }",
    "newString": "        // Update zoom label showing effective zoom distance\n        var zoomLabel = _scopeCrosshair.GetNodeOrNull<Label>(\"ZoomLabel\");\n        if (zoomLabel != null)\n        {\n            zoomLabel.Text = $\"{EffectiveScopeZoomDistance:F1}x\";\n        }",
    "originalFile": "using Godot;\nusing GodotTopDownTemplate.AbstractClasses;\nusing GodotTopDownTemplate.Projectiles;\n\nnamespace GodotTopDownTemplate.Weapons;\n\n/// <summary>\n/// Bolt-action charging state for the ASVK sniper rifle.\n/// Before each shot, the player must complete a 4-step bolt-action sequence:\n/// Down (pull bolt back) ‚Üí Left (open bolt) ‚Üí Down (close bolt) ‚Üí Up (chamber round)\n/// </summary>\npublic enum BoltActionStep\n{\n    /// <summary>\n    /// Bolt is ready - weapon can fire. After firing, transitions to NeedsBoltCycle.\n    /// </summary>\n    Ready,\n\n    /// <summary>\n    /// Just fired - needs bolt cycling before next shot.\n    /// Waiting for Down arrow (pull bolt back).\n    /// </summary>\n    NeedsBoltCycle,\n\n    /// <summary>\n    /// Step 1 complete (bolt pulled back). Waiting for Left arrow (open bolt).\n    /// </summary>\n    WaitOpenBolt,\n\n    /// <summary>\n    /// Step 2 complete (bolt opened). Waiting for Down arrow (close bolt).\n    /// </summary>\n    WaitCloseBolt,\n\n    /// <summary>\n    /// Step 3 complete (bolt closed). Waiting for Up arrow (chamber round).\n    /// </summary>\n    WaitChamberRound\n}\n\n/// <summary>\n/// ASVK sniper rifle - heavy anti-materiel bolt-action rifle.\n/// Features:\n/// - 12.7x108mm ammunition dealing 50 damage per shot\n/// - Penetrates through 2 walls and through enemies\n/// - Instant bullet speed with smoky dissipating tracer trail\n/// - Very high turn sensitivity\n/// - 5-round magazine with M16-style swap reload\n/// - Single-shot bolt-action with manual charging sequence (Down‚ÜíLeft‚ÜíDown‚ÜíUp)\n/// - Red laser sight for aiming\n/// Reference: ASVK (–ê–°–í–ö) anti-materiel sniper rifle\n/// </summary>\npublic partial class SniperRifle : BaseWeapon\n{\n    // =========================================================================\n    // Bolt-Action State\n    // =========================================================================\n\n    /// <summary>\n    /// Current bolt-action charging step.\n    /// </summary>\n    private BoltActionStep _boltStep = BoltActionStep.Ready;\n\n    /// <summary>\n    /// Whether the bolt action is ready to fire (chambered).\n    /// Initially true so first shot can be fired immediately.\n    /// </summary>\n    public bool IsBoltReady => _boltStep == BoltActionStep.Ready;\n\n    /// <summary>\n    /// Whether the weapon needs bolt cycling before it can fire again.\n    /// </summary>\n    public bool NeedsBoltCycle => _boltStep != BoltActionStep.Ready;\n\n    /// <summary>\n    /// Signal emitted when bolt-action step changes.\n    /// </summary>\n    [Signal]\n    public delegate void BoltStepChangedEventHandler(int step, int totalSteps);\n\n    // =========================================================================\n    // Smoky Tracer Trail\n    // =========================================================================\n\n    /// <summary>\n    /// Scene for the smoky tracer trail effect.\n    /// Created programmatically as a Line2D with smoke-like appearance.\n    /// </summary>\n    private Line2D? _lastTracerTrail;\n\n    // =========================================================================\n    // Laser Sight Configuration\n    // =========================================================================\n\n    /// <summary>\n    /// Whether the laser sight is enabled.\n    /// </summary>\n    [Export]\n    public bool LaserSightEnabled { get; set; } = true;\n\n    /// <summary>\n    /// Maximum length of the laser sight in pixels.\n    /// </summary>\n    [Export]\n    public float LaserSightLength { get; set; } = 500.0f;\n\n    /// <summary>\n    /// Color of the laser sight (red for sniper).\n    /// </summary>\n    [Export]\n    public Color LaserSightColor { get; set; } = new Color(1.0f, 0.0f, 0.0f, 0.5f);\n\n    /// <summary>\n    /// Width of the laser sight line.\n    /// </summary>\n    [Export]\n    public float LaserSightWidth { get; set; } = 2.0f;\n\n    /// <summary>\n    /// Reference to the Line2D node for the laser sight.\n    /// </summary>\n    private Line2D? _laserSight;\n\n    /// <summary>\n    /// Reference to the Sprite2D node for the rifle visual.\n    /// </summary>\n    private Sprite2D? _rifleSprite;\n\n    /// <summary>\n    /// Current aim direction based on laser sight.\n    /// </summary>\n    private Vector2 _aimDirection = Vector2.Right;\n\n    /// <summary>\n    /// Current aim angle in radians.\n    /// </summary>\n    private float _currentAimAngle = 0.0f;\n\n    /// <summary>\n    /// Whether the aim angle has been initialized.\n    /// </summary>\n    private bool _aimAngleInitialized = false;\n\n    /// <summary>\n    /// Current recoil offset angle in radians.\n    /// Heavy sniper recoil.\n    /// </summary>\n    private float _recoilOffset = 0.0f;\n\n    /// <summary>\n    /// Time since the last shot was fired, used for recoil recovery.\n    /// </summary>\n    private float _timeSinceLastShot = 0.0f;\n\n    /// <summary>\n    /// Time in seconds before recoil starts recovering.\n    /// Long delay for heavy sniper.\n    /// </summary>\n    private const float RecoilRecoveryDelay = 0.5f;\n\n    /// <summary>\n    /// Speed at which recoil recovers (radians per second).\n    /// </summary>\n    private const float RecoilRecoverySpeed = 3.0f;\n\n    /// <summary>\n    /// Maximum recoil offset in radians (about 15 degrees).\n    /// </summary>\n    private const float MaxRecoilOffset = 0.26f;\n\n    /// <summary>\n    /// Recoil amount per shot in radians.\n    /// Heavy kick for 12.7mm.\n    /// </summary>\n    private const float RecoilPerShot = 0.15f;\n\n    /// <summary>\n    /// Number of walls this bullet can penetrate through.\n    /// The bullet continues flying after penetrating walls.\n    /// </summary>\n    private const int MaxWallPenetrations = 2;\n\n    public override void _Ready()\n    {\n        base._Ready();\n\n        // Get the rifle sprite for visual representation\n        _rifleSprite = GetNodeOrNull<Sprite2D>(\"RifleSprite\");\n\n        if (_rifleSprite != null)\n        {\n            var texture = _rifleSprite.Texture;\n            GD.Print($\"[SniperRifle] RifleSprite found: visible={_rifleSprite.Visible}, z_index={_rifleSprite.ZIndex}, texture={(texture != null ? \"loaded\" : \"NULL\")}\");\n        }\n        else\n        {\n            GD.PrintErr(\"[SniperRifle] WARNING: RifleSprite node not found!\");\n        }\n\n        // Check for Power Fantasy mode blue laser\n        var difficultyManager = GetNodeOrNull(\"/root/DifficultyManager\");\n        if (difficultyManager != null)\n        {\n            var shouldForceBlueLaser = difficultyManager.Call(\"should_force_blue_laser_sight\");\n            if (shouldForceBlueLaser.AsBool())\n            {\n                var blueColorVariant = difficultyManager.Call(\"get_power_fantasy_laser_color\");\n                LaserSightColor = blueColorVariant.AsColor();\n                GD.Print($\"[SniperRifle] Power Fantasy mode: laser color set to blue {LaserSightColor}\");\n            }\n        }\n\n        // Get or create the laser sight Line2D\n        _laserSight = GetNodeOrNull<Line2D>(\"LaserSight\");\n\n        if (_laserSight == null && LaserSightEnabled)\n        {\n            CreateLaserSight();\n        }\n        else if (_laserSight != null)\n        {\n            _laserSight.Width = LaserSightWidth;\n            _laserSight.DefaultColor = LaserSightColor;\n            _laserSight.BeginCapMode = Line2D.LineCapMode.Round;\n            _laserSight.EndCapMode = Line2D.LineCapMode.Round;\n\n            if (_laserSight.GetPointCount() < 2)\n            {\n                _laserSight.ClearPoints();\n                _laserSight.AddPoint(Vector2.Zero);\n                _laserSight.AddPoint(Vector2.Right * LaserSightLength);\n            }\n        }\n\n        UpdateLaserSightVisibility();\n        GD.Print(\"[SniperRifle] ASVK initialized - bolt ready, laser sight enabled\");\n    }\n\n    public override void _ExitTree()\n    {\n        // Clean up scope overlay when weapon is removed from scene tree\n        if (_isScopeActive)\n        {\n            DeactivateScope();\n        }\n        base._ExitTree();\n    }\n\n    public override void _Process(double delta)\n    {\n        base._Process(delta);\n\n        // Update time since last shot for recoil recovery\n        _timeSinceLastShot += (float)delta;\n\n        // Recover recoil after delay\n        if (_timeSinceLastShot >= RecoilRecoveryDelay && _recoilOffset != 0)\n        {\n            float recoveryAmount = RecoilRecoverySpeed * (float)delta;\n            _recoilOffset = Mathf.MoveToward(_recoilOffset, 0, recoveryAmount);\n        }\n\n        // Always update aim direction and rifle sprite rotation\n        UpdateAimDirection();\n\n        // Update laser sight to point towards mouse (with recoil offset)\n        if (LaserSightEnabled && _laserSight != null)\n        {\n            UpdateLaserSight();\n        }\n\n        // Handle bolt-action input\n        HandleBoltActionInput();\n\n        // Update scope system (sway, camera offset, overlay)\n        UpdateScope((float)delta);\n    }\n\n    // =========================================================================\n    // Bolt-Action Charging Mechanics\n    // =========================================================================\n\n    /// <summary>\n    /// Handles the bolt-action charging input sequence.\n    /// Sequence: Down (pull bolt) ‚Üí Left (open bolt) ‚Üí Down (close bolt) ‚Üí Up (chamber round)\n    /// Uses the arrow keys / WASD movement input actions.\n    /// </summary>\n    private void HandleBoltActionInput()\n    {\n        switch (_boltStep)\n        {\n            case BoltActionStep.NeedsBoltCycle:\n                // Step 1: Down arrow - pull bolt back\n                if (Input.IsActionJustPressed(\"move_down\"))\n                {\n                    _boltStep = BoltActionStep.WaitOpenBolt;\n                    EmitSignal(SignalName.BoltStepChanged, 1, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 1/4: Bolt pulled back\");\n                }\n                break;\n\n            case BoltActionStep.WaitOpenBolt:\n                // Step 2: Left arrow - open bolt\n                if (Input.IsActionJustPressed(\"move_left\"))\n                {\n                    _boltStep = BoltActionStep.WaitCloseBolt;\n                    EmitSignal(SignalName.BoltStepChanged, 2, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 2/4: Bolt opened\");\n                }\n                break;\n\n            case BoltActionStep.WaitCloseBolt:\n                // Step 3: Down arrow - close bolt\n                if (Input.IsActionJustPressed(\"move_down\"))\n                {\n                    _boltStep = BoltActionStep.WaitChamberRound;\n                    EmitSignal(SignalName.BoltStepChanged, 3, 4);\n                    PlayBoltSound();\n                    GD.Print(\"[SniperRifle] Bolt step 3/4: Bolt closed\");\n                }\n                break;\n\n            case BoltActionStep.WaitChamberRound:\n                // Step 4: Up arrow - chamber round\n                if (Input.IsActionJustPressed(\"move_up\"))\n                {\n                    _boltStep = BoltActionStep.Ready;\n                    EmitSignal(SignalName.BoltStepChanged, 4, 4);\n                    PlayBoltChamberSound();\n                    GD.Print(\"[SniperRifle] Bolt step 4/4: Round chambered - READY TO FIRE\");\n                }\n                break;\n\n            case BoltActionStep.Ready:\n                // Already ready, no bolt action needed\n                break;\n        }\n    }\n\n    /// <summary>\n    /// Plays the bolt manipulation sound.\n    /// </summary>\n    private void PlayBoltSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_bolt\"))\n        {\n            audioManager.Call(\"play_m16_bolt\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Plays the bolt chamber/ready sound.\n    /// </summary>\n    private void PlayBoltChamberSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_bolt\"))\n        {\n            audioManager.Call(\"play_m16_bolt\", GlobalPosition);\n        }\n    }\n\n    // =========================================================================\n    // Aiming and Laser Sight\n    // =========================================================================\n\n    /// <summary>\n    /// Updates the aim direction and rifle sprite rotation.\n    /// </summary>\n    private void UpdateAimDirection()\n    {\n        Vector2 mousePos = GetGlobalMousePosition();\n        Vector2 toMouse = mousePos - GlobalPosition;\n        float targetAngle = toMouse.Angle();\n\n        if (!_aimAngleInitialized)\n        {\n            _currentAimAngle = targetAngle;\n            _aimAngleInitialized = true;\n        }\n\n        Vector2 direction;\n\n        // Apply sensitivity for the sniper rifle\n        if (WeaponData != null && WeaponData.Sensitivity > 0)\n        {\n            float angleDiff = Mathf.Wrap(targetAngle - _currentAimAngle, -Mathf.Pi, Mathf.Pi);\n            float rotationSpeed = WeaponData.Sensitivity * 10.0f;\n            float delta = (float)GetProcessDeltaTime();\n            float maxRotation = rotationSpeed * delta;\n            float actualRotation = Mathf.Clamp(angleDiff, -maxRotation, maxRotation);\n            _currentAimAngle += actualRotation;\n            direction = new Vector2(Mathf.Cos(_currentAimAngle), Mathf.Sin(_currentAimAngle));\n        }\n        else\n        {\n            if (toMouse.LengthSquared() > 0.001f)\n            {\n                direction = toMouse.Normalized();\n                _currentAimAngle = targetAngle;\n            }\n            else\n            {\n                direction = _aimDirection;\n            }\n        }\n\n        _aimDirection = direction;\n        UpdateRifleSpriteRotation(direction);\n    }\n\n    /// <summary>\n    /// Creates the laser sight Line2D programmatically.\n    /// </summary>\n    private void CreateLaserSight()\n    {\n        _laserSight = new Line2D\n        {\n            Name = \"LaserSight\",\n            Width = LaserSightWidth,\n            DefaultColor = LaserSightColor,\n            BeginCapMode = Line2D.LineCapMode.Round,\n            EndCapMode = Line2D.LineCapMode.Round\n        };\n\n        _laserSight.AddPoint(Vector2.Zero);\n        _laserSight.AddPoint(Vector2.Right * LaserSightLength);\n\n        AddChild(_laserSight);\n    }\n\n    /// <summary>\n    /// Updates the laser sight visualization with recoil offset.\n    /// Uses raycasting to stop at obstacles.\n    /// </summary>\n    private void UpdateLaserSight()\n    {\n        if (_laserSight == null)\n        {\n            return;\n        }\n\n        Vector2 laserDirection = _aimDirection.Rotated(_recoilOffset);\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float maxLaserLength = viewportSize.Length();\n\n        Vector2 endPoint = laserDirection * maxLaserLength;\n\n        var spaceState = GetWorld2D().DirectSpaceState;\n        var query = PhysicsRayQueryParameters2D.Create(\n            GlobalPosition,\n            GlobalPosition + endPoint,\n            4 // Collision mask for obstacles (layer 3 = value 4)\n        );\n\n        var result = spaceState.IntersectRay(query);\n\n        if (result.Count > 0)\n        {\n            Vector2 hitPosition = (Vector2)result[\"position\"];\n            endPoint = hitPosition - GlobalPosition;\n        }\n\n        _laserSight.SetPointPosition(0, Vector2.Zero);\n        _laserSight.SetPointPosition(1, endPoint);\n    }\n\n    /// <summary>\n    /// Updates the visibility of the laser sight.\n    /// </summary>\n    private void UpdateLaserSightVisibility()\n    {\n        if (_laserSight != null)\n        {\n            _laserSight.Visible = LaserSightEnabled;\n        }\n    }\n\n    /// <summary>\n    /// Updates the rifle sprite rotation to match aim direction.\n    /// </summary>\n    private void UpdateRifleSpriteRotation(Vector2 direction)\n    {\n        if (_rifleSprite == null)\n        {\n            return;\n        }\n\n        float angle = direction.Angle();\n        _rifleSprite.Rotation = angle;\n\n        bool aimingLeft = Mathf.Abs(angle) > Mathf.Pi / 2;\n        _rifleSprite.FlipV = aimingLeft;\n    }\n\n    /// <summary>\n    /// Enables or disables the laser sight.\n    /// </summary>\n    public void SetLaserSightEnabled(bool enabled)\n    {\n        LaserSightEnabled = enabled;\n        UpdateLaserSightVisibility();\n    }\n\n    // =========================================================================\n    // Firing\n    // =========================================================================\n\n    /// <summary>\n    /// Fires the sniper rifle. Only fires if bolt is ready.\n    /// After firing, transitions to NeedsBoltCycle state.\n    /// </summary>\n    public override bool Fire(Vector2 direction)\n    {\n        // Check for empty magazine\n        if (CurrentAmmo <= 0)\n        {\n            PlayEmptyClickSound();\n            return false;\n        }\n\n        // Check if bolt is ready\n        if (!IsBoltReady)\n        {\n            // Play a click to indicate bolt not cycled\n            PlayEmptyClickSound();\n            return false;\n        }\n\n        // Check standard fire conditions\n        if (!CanFire || WeaponData == null || BulletScene == null)\n        {\n            return false;\n        }\n\n        // Apply recoil to aim direction\n        Vector2 spreadDirection = ApplyRecoil(_aimDirection);\n        bool result = base.Fire(spreadDirection);\n\n        if (result)\n        {\n            // Transition to needs bolt cycle\n            _boltStep = BoltActionStep.NeedsBoltCycle;\n            EmitSignal(SignalName.BoltStepChanged, 0, 4);\n\n            // Play sniper shot sound\n            PlaySniperShotSound();\n            // Emit gunshot sound for enemy detection\n            EmitGunshotSound();\n            // Play shell casing with delay\n            PlayShellCasingDelayed();\n            // Trigger heavy screen shake\n            TriggerScreenShake(spreadDirection);\n\n            // Spawn smoky tracer trail\n            SpawnSmokyTracer(GlobalPosition, spreadDirection);\n\n            GD.Print(\"[SniperRifle] FIRED! Bolt needs cycling. Ammo remaining: \" + CurrentAmmo);\n        }\n\n        return result;\n    }\n\n    /// <summary>\n    /// Override SpawnBullet to configure the SniperBullet for sniper behavior:\n    /// - Very high damage (50)\n    /// - Passes through enemies (doesn't destroy on hit)\n    /// - Penetrates through 2 walls (wall-count based, not distance-based)\n    /// </summary>\n    protected override void SpawnBullet(Vector2 direction)\n    {\n        if (BulletScene == null)\n        {\n            return;\n        }\n\n        // Check bullet spawn path\n        var (isBlocked, hitPosition, hitNormal) = CheckBulletSpawnPath(direction);\n\n        Vector2 spawnPosition;\n        if (isBlocked)\n        {\n            spawnPosition = GlobalPosition + direction * 2.0f;\n            GD.Print(\"[SniperRifle] Point-blank shot: spawning for penetration\");\n        }\n        else\n        {\n            spawnPosition = GlobalPosition + direction * BulletSpawnOffset;\n        }\n\n        var bulletNode = BulletScene.Instantiate<Node2D>();\n        bulletNode.GlobalPosition = spawnPosition;\n\n        // Try to cast to C# SniperBullet for direct property access\n        var sniperBullet = bulletNode as SniperBullet;\n\n        if (sniperBullet != null)\n        {\n            // SniperBullet - set properties directly\n            sniperBullet.Direction = direction;\n            if (WeaponData != null)\n            {\n                sniperBullet.Speed = WeaponData.BulletSpeed;\n                sniperBullet.Damage = WeaponData.Damage;\n            }\n            var owner = GetParent();\n            if (owner != null)\n            {\n                sniperBullet.ShooterId = owner.GetInstanceId();\n            }\n            sniperBullet.ShooterPosition = GlobalPosition;\n            sniperBullet.MaxWallPenetrations = MaxWallPenetrations;\n            GD.Print($\"[SniperRifle] Spawned SniperBullet: Damage={sniperBullet.Damage}, Speed={sniperBullet.Speed}, MaxWallPen={MaxWallPenetrations}\");\n        }\n        else\n        {\n            // Fallback for any bullet type\n            if (bulletNode.HasMethod(\"SetDirection\"))\n            {\n                bulletNode.Call(\"SetDirection\", direction);\n            }\n            else\n            {\n                bulletNode.Set(\"Direction\", direction);\n                bulletNode.Set(\"direction\", direction);\n            }\n\n            if (WeaponData != null)\n            {\n                bulletNode.Set(\"Speed\", WeaponData.BulletSpeed);\n                bulletNode.Set(\"speed\", WeaponData.BulletSpeed);\n                bulletNode.Set(\"Damage\", WeaponData.Damage);\n                bulletNode.Set(\"damage\", WeaponData.Damage);\n            }\n\n            var owner = GetParent();\n            if (owner != null)\n            {\n                bulletNode.Set(\"ShooterId\", owner.GetInstanceId());\n                bulletNode.Set(\"shooter_id\", owner.GetInstanceId());\n            }\n\n            bulletNode.Set(\"ShooterPosition\", GlobalPosition);\n            bulletNode.Set(\"shooter_position\", GlobalPosition);\n        }\n\n        GetTree().CurrentScene.AddChild(bulletNode);\n\n        // Spawn muzzle flash effect - large flash for 12.7mm\n        SpawnMuzzleFlash(spawnPosition, direction, WeaponData?.Caliber);\n\n        // Spawn casing\n        SpawnCasing(direction, WeaponData?.Caliber);\n    }\n\n    // =========================================================================\n    // Smoky Tracer Trail\n    // =========================================================================\n\n    /// <summary>\n    /// Spawns a smoky dissipating tracer trail from the fire position\n    /// in the shooting direction across the entire map.\n    /// The tracer is an instant visual effect (like a contrail from a plane)\n    /// that fades out over time.\n    /// </summary>\n    private void SpawnSmokyTracer(Vector2 fromPosition, Vector2 direction)\n    {\n        // Calculate tracer end point - extend to edge of map (very far)\n        float tracerLength = 5000.0f; // Far enough to reach any map edge\n        Vector2 endPosition = fromPosition + direction * tracerLength;\n\n        // Create the tracer as a Line2D with smoke-like appearance\n        var tracer = new Line2D\n        {\n            Name = \"SniperTracer\",\n            Width = 6.0f,\n            DefaultColor = new Color(0.8f, 0.8f, 0.8f, 0.7f),\n            BeginCapMode = Line2D.LineCapMode.Round,\n            EndCapMode = Line2D.LineCapMode.Round,\n            TopLevel = true,\n            Position = Vector2.Zero,\n            ZIndex = -1 // Behind other elements\n        };\n\n        // Set up width curve - wider at start, tapers to narrower at end\n        var widthCurve = new Curve();\n        widthCurve.AddPoint(new Vector2(0.0f, 1.0f));\n        widthCurve.AddPoint(new Vector2(0.3f, 0.8f));\n        widthCurve.AddPoint(new Vector2(1.0f, 0.3f));\n        tracer.WidthCurve = widthCurve;\n\n        // Set up gradient - smoky white/gray that fades out\n        var gradient = new Gradient();\n        gradient.SetColor(0, new Color(0.9f, 0.9f, 0.85f, 0.8f));\n        gradient.AddPoint(0.5f, new Color(0.7f, 0.7f, 0.65f, 0.5f));\n        gradient.SetColor(gradient.GetPointCount() - 1, new Color(0.5f, 0.5f, 0.5f, 0.2f));\n        tracer.Gradient = gradient;\n\n        // Add the tracer line points (using global coordinates since TopLevel=true)\n        tracer.AddPoint(fromPosition + direction * BulletSpawnOffset);\n        tracer.AddPoint(endPosition);\n\n        // Add to scene\n        GetTree().CurrentScene.AddChild(tracer);\n\n        // Start the fade-out animation\n        FadeOutTracer(tracer);\n    }\n\n    /// <summary>\n    /// Animates the tracer trail fading out and dissipating over time.\n    /// The tracer gradually becomes more transparent and wider (simulating smoke dissipation).\n    /// </summary>\n    private async void FadeOutTracer(Line2D tracer)\n    {\n        float fadeDuration = 2.0f;\n        float elapsed = 0.0f;\n\n        float initialWidth = tracer.Width;\n\n        while (elapsed < fadeDuration && IsInstanceValid(tracer))\n        {\n            elapsed += (float)GetProcessDeltaTime();\n            float progress = elapsed / fadeDuration;\n\n            // Fade the alpha\n            float alpha = Mathf.Lerp(0.7f, 0.0f, progress);\n            tracer.DefaultColor = new Color(0.8f, 0.8f, 0.8f, alpha);\n\n            // Widen slightly to simulate smoke dissipation\n            tracer.Width = initialWidth + progress * 4.0f;\n\n            // Update gradient alpha\n            var gradient = new Gradient();\n            gradient.SetColor(0, new Color(0.9f, 0.9f, 0.85f, alpha));\n            gradient.AddPoint(0.5f, new Color(0.7f, 0.7f, 0.65f, alpha * 0.6f));\n            gradient.SetColor(gradient.GetPointCount() - 1, new Color(0.5f, 0.5f, 0.5f, alpha * 0.3f));\n            tracer.Gradient = gradient;\n\n            await ToSignal(GetTree(), \"process_frame\");\n        }\n\n        // Remove the tracer after fade completes\n        if (IsInstanceValid(tracer))\n        {\n            tracer.QueueFree();\n        }\n    }\n\n    // =========================================================================\n    // Sound and Effects\n    // =========================================================================\n\n    /// <summary>\n    /// Plays the sniper shot sound via AudioManager.\n    /// </summary>\n    private void PlaySniperShotSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        // Use M16 shot as a placeholder sound for the sniper\n        if (audioManager != null && audioManager.HasMethod(\"play_m16_shot\"))\n        {\n            audioManager.Call(\"play_m16_shot\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Plays the empty gun click sound.\n    /// </summary>\n    private void PlayEmptyClickSound()\n    {\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_empty_click\"))\n        {\n            audioManager.Call(\"play_empty_click\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Emits gunshot sound for enemy detection via SoundPropagation.\n    /// Very loud for the 12.7mm round.\n    /// </summary>\n    private void EmitGunshotSound()\n    {\n        var soundPropagation = GetNodeOrNull(\"/root/SoundPropagation\");\n        if (soundPropagation != null && soundPropagation.HasMethod(\"emit_sound\"))\n        {\n            float loudness = WeaponData?.Loudness ?? 3000.0f;\n            soundPropagation.Call(\"emit_sound\", 0, GlobalPosition, 0, this, loudness);\n        }\n    }\n\n    /// <summary>\n    /// Plays shell casing sound with a delay.\n    /// </summary>\n    private async void PlayShellCasingDelayed()\n    {\n        await ToSignal(GetTree().CreateTimer(0.2), \"timeout\");\n        var audioManager = GetNodeOrNull(\"/root/AudioManager\");\n        if (audioManager != null && audioManager.HasMethod(\"play_shell_rifle\"))\n        {\n            audioManager.Call(\"play_shell_rifle\", GlobalPosition);\n        }\n    }\n\n    /// <summary>\n    /// Applies recoil to shooting direction.\n    /// </summary>\n    private Vector2 ApplyRecoil(Vector2 direction)\n    {\n        // Apply current recoil offset\n        Vector2 result = direction.Rotated(_recoilOffset);\n\n        // Add strong recoil for next shot (heavy 12.7mm kick)\n        float recoilDirection = (float)GD.RandRange(-1.0, 1.0);\n        _recoilOffset += recoilDirection * RecoilPerShot;\n        _recoilOffset = Mathf.Clamp(_recoilOffset, -MaxRecoilOffset, MaxRecoilOffset);\n\n        _timeSinceLastShot = 0;\n\n        return result;\n    }\n\n    /// <summary>\n    /// Triggers screen shake from sniper shot.\n    /// Heavy shake for 12.7mm round.\n    /// </summary>\n    private void TriggerScreenShake(Vector2 shootDirection)\n    {\n        if (WeaponData == null || WeaponData.ScreenShakeIntensity <= 0)\n        {\n            return;\n        }\n\n        var screenShakeManager = GetNodeOrNull(\"/root/ScreenShakeManager\");\n        if (screenShakeManager == null || !screenShakeManager.HasMethod(\"add_shake\"))\n        {\n            return;\n        }\n\n        // Heavy shake for sniper\n        float fireRate = WeaponData.FireRate;\n        float shakeIntensity;\n        if (fireRate > 0)\n        {\n            shakeIntensity = WeaponData.ScreenShakeIntensity / fireRate * 10.0f;\n        }\n        else\n        {\n            shakeIntensity = WeaponData.ScreenShakeIntensity;\n        }\n\n        float recoveryTime = WeaponData.ScreenShakeMinRecoveryTime;\n\n        screenShakeManager.Call(\"add_shake\", shootDirection, shakeIntensity, recoveryTime);\n    }\n\n    /// <summary>\n    /// Fires the bullet in the chamber during reload sequence.\n    /// </summary>\n    public override bool FireChamberBullet(Vector2 direction)\n    {\n        // Sniper rifle doesn't support chamber bullet during reload\n        // (bolt-action requires full cycle)\n        return false;\n    }\n\n    /// <summary>\n    /// Gets the current aim direction.\n    /// </summary>\n    public Vector2 AimDirection => _aimDirection;\n\n    /// <summary>\n    /// Gets the current bolt-action step.\n    /// </summary>\n    public BoltActionStep CurrentBoltStep => _boltStep;\n\n    /// <summary>\n    /// Resets the bolt to ready state (e.g., after reload with a new magazine).\n    /// </summary>\n    public void ResetBolt()\n    {\n        _boltStep = BoltActionStep.Ready;\n        EmitSignal(SignalName.BoltStepChanged, 4, 4);\n        GD.Print(\"[SniperRifle] Bolt reset to ready state\");\n    }\n\n    // =========================================================================\n    // Scope / Aiming System (RMB)\n    // =========================================================================\n\n    /// <summary>\n    /// Whether the scope is currently active (RMB held).\n    /// </summary>\n    private bool _isScopeActive = false;\n\n    /// <summary>\n    /// Whether the scope is active (read-only property for external access).\n    /// </summary>\n    public bool IsScopeActive => _isScopeActive;\n\n    /// <summary>\n    /// Signal emitted when scope state changes.\n    /// </summary>\n    [Signal]\n    public delegate void ScopeStateChangedEventHandler(bool isActive);\n\n    /// <summary>\n    /// Current scope zoom distance multiplier (how far beyond viewport the player can see).\n    /// 1.0 = one viewport distance, 2.0 = two viewport distances.\n    /// Controlled by mouse wheel while scoping.\n    /// </summary>\n    private float _scopeZoomDistance = 1.5f;\n\n    /// <summary>\n    /// Minimum scope zoom distance (viewport multiplier).\n    /// Set to 1.0 so the scope always looks beyond the normal viewport.\n    /// </summary>\n    private const float MinScopeZoomDistance = 1.0f;\n\n    /// <summary>\n    /// Maximum scope zoom distance (viewport multiplier).\n    /// </summary>\n    private const float MaxScopeZoomDistance = 3.0f;\n\n    /// <summary>\n    /// Step size for mouse wheel zoom adjustment.\n    /// </summary>\n    private const float ScopeZoomStep = 0.25f;\n\n    /// <summary>\n    /// Base sway amplitude in pixels at 1 viewport distance.\n    /// </summary>\n    private const float BaseScopeSwayAmplitude = 8.0f;\n\n    /// <summary>\n    /// Speed of the sway oscillation.\n    /// </summary>\n    private const float ScopeSwaySpeed = 2.5f;\n\n    /// <summary>\n    /// Maximum range (in viewport fraction) that the player can fine-tune the scope\n    /// distance via mouse movement while scoped. About 1/3 of the viewport.\n    /// </summary>\n    private const float ScopeMouseFineTuneRange = 0.33f;\n\n    /// <summary>\n    /// Current mouse fine-tune offset applied to scope distance.\n    /// Ranges from -ScopeMouseFineTuneRange to +ScopeMouseFineTuneRange (viewport fraction).\n    /// Positive = further, negative = closer.\n    /// </summary>\n    private float _scopeMouseFineTuneOffset = 0.0f;\n\n    /// <summary>\n    /// Current scope sway time accumulator.\n    /// </summary>\n    private float _scopeSwayTime = 0.0f;\n\n    /// <summary>\n    /// Current scope sway offset in pixels (applied to camera).\n    /// </summary>\n    private Vector2 _scopeSwayOffset = Vector2.Zero;\n\n    /// <summary>\n    /// Reference to the scope overlay CanvasLayer (created when scope activates).\n    /// </summary>\n    private CanvasLayer? _scopeOverlay = null;\n\n    /// <summary>\n    /// Reference to the scope crosshair control node.\n    /// </summary>\n    private Control? _scopeCrosshair = null;\n\n    /// <summary>\n    /// Reference to the scope darkening background.\n    /// </summary>\n    private ColorRect? _scopeBackground = null;\n\n    /// <summary>\n    /// Cached reference to the player's Camera2D node.\n    /// </summary>\n    private Camera2D? _playerCamera = null;\n\n    /// <summary>\n    /// Original camera offset before scoping (to restore on exit).\n    /// </summary>\n    private Vector2 _originalCameraOffset = Vector2.Zero;\n\n    /// <summary>\n    /// Gets the effective scope zoom distance including mouse fine-tune offset.\n    /// </summary>\n    private float EffectiveScopeZoomDistance => _scopeZoomDistance + _scopeMouseFineTuneOffset;\n\n    /// <summary>\n    /// Gets the current camera offset for scope aiming.\n    /// Called by the player or level scripts to position the camera.\n    /// </summary>\n    public Vector2 GetScopeCameraOffset()\n    {\n        if (!_isScopeActive)\n        {\n            return Vector2.Zero;\n        }\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return Vector2.Zero;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float baseDistance = viewportSize.Length() * 0.5f;\n\n        // Camera offset = aim direction * (zoom distance + mouse fine-tune) * viewport size + sway\n        Vector2 offset = _aimDirection * baseDistance * EffectiveScopeZoomDistance + _scopeSwayOffset;\n\n        return offset;\n    }\n\n    /// <summary>\n    /// Gets the world-space position that the scope crosshair center is aiming at.\n    /// Used to direct bullets to the crosshair center.\n    /// </summary>\n    public Vector2 GetScopeAimTarget()\n    {\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return GlobalPosition + _aimDirection * 1000.0f;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n        float baseDistance = viewportSize.Length() * 0.5f;\n\n        // The scope aim target is the player's position offset by the scope camera offset\n        // (without sway, so bullets go to the true center, not the swaying crosshair)\n        Vector2 aimTarget = GlobalPosition + _aimDirection * baseDistance * EffectiveScopeZoomDistance;\n\n        return aimTarget;\n    }\n\n    /// <summary>\n    /// Activates the scope (called when RMB is pressed).\n    /// </summary>\n    public void ActivateScope()\n    {\n        if (_isScopeActive)\n        {\n            return;\n        }\n\n        _isScopeActive = true;\n        _scopeSwayTime = 0.0f;\n        _scopeMouseFineTuneOffset = 0.0f;\n\n        // Find and cache the player's Camera2D\n        FindPlayerCamera();\n\n        // Store original camera offset\n        if (_playerCamera != null)\n        {\n            _originalCameraOffset = _playerCamera.Offset;\n        }\n\n        // Create the scope overlay\n        CreateScopeOverlay();\n\n        EmitSignal(SignalName.ScopeStateChanged, true);\n        GD.Print($\"[SniperRifle] Scope activated. Zoom distance: {_scopeZoomDistance:F1}x\");\n    }\n\n    /// <summary>\n    /// Deactivates the scope (called when RMB is released).\n    /// </summary>\n    public void DeactivateScope()\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        _isScopeActive = false;\n\n        // Restore original camera offset\n        if (_playerCamera != null)\n        {\n            _playerCamera.Offset = _originalCameraOffset;\n        }\n\n        // Remove scope overlay\n        RemoveScopeOverlay();\n\n        EmitSignal(SignalName.ScopeStateChanged, false);\n        GD.Print(\"[SniperRifle] Scope deactivated.\");\n    }\n\n    /// <summary>\n    /// Adjusts the scope zoom distance (called on mouse wheel while scoping).\n    /// </summary>\n    public void AdjustScopeZoom(float direction)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        _scopeZoomDistance += direction * ScopeZoomStep;\n        _scopeZoomDistance = Mathf.Clamp(_scopeZoomDistance, MinScopeZoomDistance, MaxScopeZoomDistance);\n\n        // Reset fine-tune offset when zoom changes to avoid going out of range\n        _scopeMouseFineTuneOffset = Mathf.Clamp(_scopeMouseFineTuneOffset,\n            -ScopeMouseFineTuneRange, ScopeMouseFineTuneRange);\n\n        GD.Print($\"[SniperRifle] Scope zoom adjusted: {_scopeZoomDistance:F2}x (fine-tune: {_scopeMouseFineTuneOffset:F2})\");\n    }\n\n    /// <summary>\n    /// Adjusts the scope fine-tune offset based on mouse movement along the aim direction.\n    /// Allows the player to look slightly closer or further (about 1/3 viewport range).\n    /// Called from Player.cs when mouse moves while scoped.\n    /// </summary>\n    public void AdjustScopeFineTune(Vector2 mouseMotion)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        // Project mouse motion onto the aim direction to get forward/backward movement\n        // Moving mouse in the aim direction = further, opposite = closer\n        float projection = mouseMotion.Dot(_aimDirection);\n\n        // Scale the projection: mouse sensitivity for scope fine-tuning\n        // A moderate movement across the screen should give the full range\n        float sensitivity = 0.002f;\n        _scopeMouseFineTuneOffset += projection * sensitivity;\n        _scopeMouseFineTuneOffset = Mathf.Clamp(_scopeMouseFineTuneOffset,\n            -ScopeMouseFineTuneRange, ScopeMouseFineTuneRange);\n    }\n\n    /// <summary>\n    /// Finds the player's Camera2D node by traversing up to the parent (player).\n    /// </summary>\n    private void FindPlayerCamera()\n    {\n        if (_playerCamera != null)\n        {\n            return;\n        }\n\n        var parent = GetParent();\n        if (parent != null)\n        {\n            _playerCamera = parent.GetNodeOrNull<Camera2D>(\"Camera2D\");\n        }\n    }\n\n    /// <summary>\n    /// Updates the scope system each frame (called from _Process).\n    /// </summary>\n    private void UpdateScope(float delta)\n    {\n        if (!_isScopeActive)\n        {\n            return;\n        }\n\n        // Update sway (scales with effective distance including fine-tune offset)\n        _scopeSwayTime += delta;\n        float swayAmplitude = BaseScopeSwayAmplitude * EffectiveScopeZoomDistance;\n\n        // Use two sine waves at different frequencies for natural-looking sway\n        float swayX = Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 1.0f) * swayAmplitude\n                    + Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 2.3f) * swayAmplitude * 0.3f;\n        float swayY = Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 1.4f) * swayAmplitude\n                    + Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 0.7f) * swayAmplitude * 0.4f;\n\n        _scopeSwayOffset = new Vector2(swayX, swayY);\n\n        // Update camera offset for scope view\n        if (_playerCamera != null)\n        {\n            _playerCamera.Offset = _originalCameraOffset + GetScopeCameraOffset();\n        }\n\n        // Update scope overlay crosshair position with sway\n        UpdateScopeOverlayPosition();\n    }\n\n    /// <summary>\n    /// Creates the scope overlay UI with crosshair and darkened edges.\n    /// </summary>\n    private void CreateScopeOverlay()\n    {\n        RemoveScopeOverlay();\n\n        _scopeOverlay = new CanvasLayer\n        {\n            Name = \"ScopeOverlay\",\n            Layer = 10\n        };\n\n        Viewport? viewport = GetViewport();\n        Vector2 viewportSize = viewport?.GetVisibleRect().Size ?? new Vector2(1280, 720);\n\n        // Dark background with circular cutout effect (vignette)\n        _scopeBackground = new ColorRect\n        {\n            Name = \"ScopeBackground\",\n            Color = new Color(0.0f, 0.0f, 0.0f, 0.5f),\n            Size = viewportSize,\n            Position = Vector2.Zero,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        _scopeOverlay.AddChild(_scopeBackground);\n\n        // Create the crosshair as a Control node\n        _scopeCrosshair = new Control\n        {\n            Name = \"ScopeCrosshair\",\n            Position = viewportSize / 2,\n            Size = Vector2.Zero,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        _scopeOverlay.AddChild(_scopeCrosshair);\n\n        // Add crosshair lines - based on the reference image from the issue\n        // The scope has a classic crosshair with circle and mil-dots\n\n        // Outer circle\n        float circleRadius = Mathf.Min(viewportSize.X, viewportSize.Y) * 0.35f;\n        int segments = 64;\n        var outerCircle = new Line2D\n        {\n            Name = \"OuterCircle\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f),\n            Antialiased = true\n        };\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            outerCircle.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * circleRadius);\n        }\n        _scopeCrosshair.AddChild(outerCircle);\n\n        // Inner thin circle\n        float innerRadius = circleRadius * 0.05f;\n        var innerCircle = new Line2D\n        {\n            Name = \"InnerCircle\",\n            Width = 1.5f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f),\n            Antialiased = true\n        };\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            innerCircle.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * innerRadius);\n        }\n        _scopeCrosshair.AddChild(innerCircle);\n\n        // Horizontal crosshair line (left)\n        var hLineLeft = new Line2D\n        {\n            Name = \"HLineLeft\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        hLineLeft.AddPoint(new Vector2(-circleRadius, 0));\n        hLineLeft.AddPoint(new Vector2(-innerRadius, 0));\n        _scopeCrosshair.AddChild(hLineLeft);\n\n        // Horizontal crosshair line (right)\n        var hLineRight = new Line2D\n        {\n            Name = \"HLineRight\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        hLineRight.AddPoint(new Vector2(innerRadius, 0));\n        hLineRight.AddPoint(new Vector2(circleRadius, 0));\n        _scopeCrosshair.AddChild(hLineRight);\n\n        // Vertical crosshair line (top)\n        var vLineTop = new Line2D\n        {\n            Name = \"VLineTop\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        vLineTop.AddPoint(new Vector2(0, -circleRadius));\n        vLineTop.AddPoint(new Vector2(0, -innerRadius));\n        _scopeCrosshair.AddChild(vLineTop);\n\n        // Vertical crosshair line (bottom) with mil-dots\n        var vLineBottom = new Line2D\n        {\n            Name = \"VLineBottom\",\n            Width = 2.0f,\n            DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.9f)\n        };\n        vLineBottom.AddPoint(new Vector2(0, innerRadius));\n        vLineBottom.AddPoint(new Vector2(0, circleRadius));\n        _scopeCrosshair.AddChild(vLineBottom);\n\n        // Add mil-dot markers on the bottom crosshair (range estimation)\n        float dotSpacing = circleRadius * 0.15f;\n        for (int i = 1; i <= 4; i++)\n        {\n            float dotY = dotSpacing * i;\n            var dot = new Line2D\n            {\n                Name = $\"MilDot_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            float dotWidth = 4.0f - i * 0.5f; // Dots get smaller further from center\n            dot.AddPoint(new Vector2(-dotWidth, dotY));\n            dot.AddPoint(new Vector2(dotWidth, dotY));\n            _scopeCrosshair.AddChild(dot);\n        }\n\n        // Add mil-dot markers on horizontal lines\n        for (int i = 1; i <= 3; i++)\n        {\n            float dotX = dotSpacing * i;\n            // Right side dots\n            var dotRight = new Line2D\n            {\n                Name = $\"HMilDotRight_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            float dotHeight = 4.0f - i * 0.5f;\n            dotRight.AddPoint(new Vector2(dotX, -dotHeight));\n            dotRight.AddPoint(new Vector2(dotX, dotHeight));\n            _scopeCrosshair.AddChild(dotRight);\n\n            // Left side dots\n            var dotLeft = new Line2D\n            {\n                Name = $\"HMilDotLeft_{i}\",\n                Width = 3.0f,\n                DefaultColor = new Color(0.0f, 0.0f, 0.0f, 0.8f)\n            };\n            dotLeft.AddPoint(new Vector2(-dotX, -dotHeight));\n            dotLeft.AddPoint(new Vector2(-dotX, dotHeight));\n            _scopeCrosshair.AddChild(dotLeft);\n        }\n\n        // Add thick outer ring to mask edges (simulate scope tube)\n        var scopeRing = new Line2D\n        {\n            Name = \"ScopeRing\",\n            Width = 6.0f,\n            DefaultColor = new Color(0.1f, 0.1f, 0.1f, 0.95f),\n            Antialiased = true\n        };\n        float ringRadius = circleRadius + 3.0f;\n        for (int i = 0; i <= segments; i++)\n        {\n            float angle = (float)i / segments * Mathf.Tau;\n            scopeRing.AddPoint(new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * ringRadius);\n        }\n        _scopeCrosshair.AddChild(scopeRing);\n\n        // Zoom distance indicator text\n        var zoomLabel = new Label\n        {\n            Name = \"ZoomLabel\",\n            Position = new Vector2(circleRadius * 0.5f, circleRadius * 0.7f),\n            Text = $\"{_scopeZoomDistance:F1}x\",\n            HorizontalAlignment = HorizontalAlignment.Center,\n            MouseFilter = Control.MouseFilterEnum.Ignore\n        };\n        zoomLabel.AddThemeColorOverride(\"font_color\", new Color(0.0f, 0.0f, 0.0f, 0.6f));\n        zoomLabel.AddThemeFontSizeOverride(\"font_size\", 12);\n        _scopeCrosshair.AddChild(zoomLabel);\n\n        GetTree().CurrentScene.AddChild(_scopeOverlay);\n    }\n\n    /// <summary>\n    /// Updates the scope overlay crosshair position with sway applied.\n    /// </summary>\n    private void UpdateScopeOverlayPosition()\n    {\n        if (_scopeCrosshair == null || _scopeOverlay == null)\n        {\n            return;\n        }\n\n        Viewport? viewport = GetViewport();\n        if (viewport == null)\n        {\n            return;\n        }\n\n        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n\n        // Crosshair stays centered but sways\n        _scopeCrosshair.Position = viewportSize / 2 + _scopeSwayOffset;\n\n        // Update zoom label\n        var zoomLabel = _scopeCrosshair.GetNodeOrNull<Label>(\"ZoomLabel\");\n        if (zoomLabel != null)\n        {\n            zoomLabel.Text = $\"{_scopeZoomDistance:F1}x\";\n        }\n    }\n\n    /// <summary>\n    /// Removes the scope overlay from the scene.\n    /// </summary>\n    private void RemoveScopeOverlay()\n    {\n        if (_scopeOverlay != null && IsInstanceValid(_scopeOverlay))\n        {\n            _scopeOverlay.QueueFree();\n            _scopeOverlay = null;\n            _scopeCrosshair = null;\n            _scopeBackground = null;\n        }\n    }\n}\n",
    "structuredPatch": [
      {
        "oldStart": 1412,
        "oldLines": 11,
        "newStart": 1412,
        "newLines": 11,
        "lines": [
          "         // Crosshair stays centered but sways",
          "         _scopeCrosshair.Position = viewportSize / 2 + _scopeSwayOffset;",
          " ",
          "-        // Update zoom label",
          "+        // Update zoom label showing effective zoom distance",
          "         var zoomLabel = _scopeCrosshair.GetNodeOrNull<Label>(\"ZoomLabel\");",
          "         if (zoomLabel != null)",
          "         {",
          "-            zoomLabel.Text = $\"{_scopeZoomDistance:F1}x\";",
          "+            zoomLabel.Text = $\"{EffectiveScopeZoomDistance:F1}x\";",
          "         }",
          "     }",
          " "
        ]
      }
    ],
    "userModified": false,
    "replaceAll": false
  }
}
[2026-02-06T20:58:14.996Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01DrUXKHRieVM5rx3MjV9HRz",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now let me verify the changes look correct by reading the modified files to review."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 611,
      "cache_read_input_tokens": 63754,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 611
      },
      "output_tokens": 2,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "6d6dd78d-39e6-4f12-b6ba-b5de02339ae0"
}
[2026-02-06T20:58:18.613Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01DrUXKHRieVM5rx3MjV9HRz",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01KnPPmEd1TmUoysTgaYxxdC",
        "name": "TodoWrite",
        "input": {
          "todos": [
            {
              "content": "Read and understand current SniperRifle.cs scope implementation",
              "status": "completed",
              "activeForm": "Reading SniperRifle.cs scope implementation"
            },
            {
              "content": "Read and understand Player.cs scope input handling",
              "status": "completed",
              "activeForm": "Reading Player.cs scope input handling"
            },
            {
              "content": "Fix #1: Allow slight movement (~1/3 viewport) closer/further while scoped via mouse movement",
              "status": "completed",
              "activeForm": "Implementing scope movement closer/further"
            },
            {
              "content": "Fix #2: Make bullets fly to the center of the crosshair (scope aim point)",
              "status": "completed",
              "activeForm": "Fixing bullet aim direction to match crosshair center"
            },
            {
              "content": "Fix #3: Move minimum scope distance half a viewport further (0.5 -> 1.0)",
              "status": "completed",
              "activeForm": "Increasing minimum scope distance by half viewport"
            },
            {
              "content": "Verify changes compile and review final code",
              "status": "in_progress",
              "activeForm": "Verifying changes compile and reviewing code"
            },
            {
              "content": "Commit, push, and update PR description",
              "status": "pending",
              "activeForm": "Committing and pushing changes"
            }
          ]
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 611,
      "cache_read_input_tokens": 63754,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 611
      },
      "output_tokens": 2,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "3ab85711-39cb-4db6-8c4f-b5099a750c95"
}
[2026-02-06T20:58:18.627Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01KnPPmEd1TmUoysTgaYxxdC",
        "type": "tool_result",
        "content": "Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "5443357b-4ce7-432a-a01b-e1963fd48b45",
  "tool_use_result": {
    "oldTodos": [
      {
        "content": "Read and understand current SniperRifle.cs scope implementation",
        "status": "completed",
        "activeForm": "Reading SniperRifle.cs scope implementation"
      },
      {
        "content": "Read and understand Player.cs scope input handling",
        "status": "completed",
        "activeForm": "Reading Player.cs scope input handling"
      },
      {
        "content": "Fix #1: Allow slight movement (~1/3 viewport) closer/further while scoped via mouse movement",
        "status": "in_progress",
        "activeForm": "Implementing scope movement closer/further"
      },
      {
        "content": "Fix #2: Make bullets fly to the center of the crosshair (scope aim point)",
        "status": "pending",
        "activeForm": "Fixing bullet aim direction to match crosshair center"
      },
      {
        "content": "Fix #3: Move minimum scope distance half a viewport further (0.5 -> 1.0)",
        "status": "pending",
        "activeForm": "Increasing minimum scope distance by half viewport"
      },
      {
        "content": "Test all changes locally and verify no regressions",
        "status": "pending",
        "activeForm": "Testing changes locally"
      },
      {
        "content": "Commit, push, and update PR description",
        "status": "pending",
        "activeForm": "Committing and pushing changes"
      }
    ],
    "newTodos": [
      {
        "content": "Read and understand current SniperRifle.cs scope implementation",
        "status": "completed",
        "activeForm": "Reading SniperRifle.cs scope implementation"
      },
      {
        "content": "Read and understand Player.cs scope input handling",
        "status": "completed",
        "activeForm": "Reading Player.cs scope input handling"
      },
      {
        "content": "Fix #1: Allow slight movement (~1/3 viewport) closer/further while scoped via mouse movement",
        "status": "completed",
        "activeForm": "Implementing scope movement closer/further"
      },
      {
        "content": "Fix #2: Make bullets fly to the center of the crosshair (scope aim point)",
        "status": "completed",
        "activeForm": "Fixing bullet aim direction to match crosshair center"
      },
      {
        "content": "Fix #3: Move minimum scope distance half a viewport further (0.5 -> 1.0)",
        "status": "completed",
        "activeForm": "Increasing minimum scope distance by half viewport"
      },
      {
        "content": "Verify changes compile and review final code",
        "status": "in_progress",
        "activeForm": "Verifying changes compile and reviewing code"
      },
      {
        "content": "Commit, push, and update PR description",
        "status": "pending",
        "activeForm": "Committing and pushing changes"
      }
    ]
  }
}
[2026-02-06T20:58:21.094Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01DEgBkH9V26GAVNY7bgggbn",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Let me verify the diff and check for any issues."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 401,
      "cache_read_input_tokens": 64365,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 401
      },
      "output_tokens": 3,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "7415572a-6750-42b1-bf5c-615408b2e15d"
}
[2026-02-06T20:58:21.837Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01DEgBkH9V26GAVNY7bgggbn",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_014YC8UDBiMo2D25VZYi9ZaS",
        "name": "Bash",
        "input": {
          "command": "git diff",
          "description": "Show full diff of changes"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 401,
      "cache_read_input_tokens": 64365,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 401
      },
      "output_tokens": 3,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "687088c0-be71-4b73-8a0e-487364407cc0"
}
[2026-02-06T20:58:21.928Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_014YC8UDBiMo2D25VZYi9ZaS",
        "type": "tool_result",
        "content": "diff --git a/Scripts/Characters/Player.cs b/Scripts/Characters/Player.cs\nindex f75b96a..f15814e 100644\n--- a/Scripts/Characters/Player.cs\n+++ b/Scripts/Characters/Player.cs\n@@ -1661,6 +1661,15 @@ public partial class Player : BaseCharacter\n         // If we have a weapon equipped, use it\n         if (CurrentWeapon != null)\n         {\n+            // When SniperRifle scope is active, fire towards the scope crosshair center\n+            // instead of the mouse cursor (the camera is offset, so mouse != crosshair)\n+            var sniperRifle = CurrentWeapon as SniperRifle;\n+            if (sniperRifle != null && sniperRifle.IsScopeActive)\n+            {\n+                Vector2 scopeTarget = sniperRifle.GetScopeAimTarget();\n+                shootDirection = (scopeTarget - GlobalPosition).Normalized();\n+            }\n+\n             CurrentWeapon.Fire(shootDirection);\n             return;\n         }\n@@ -1965,6 +1974,11 @@ public partial class Player : BaseCharacter\n                 }\n             }\n         }\n+        // Handle mouse movement for scope fine-tuning (closer/further by ~1/3 viewport)\n+        else if (@event is InputEventMouseMotion mouseMotion)\n+        {\n+            sniperRifle.AdjustScopeFineTune(mouseMotion.Relative);\n+        }\n     }\n \n     #endregion\ndiff --git a/Scripts/Weapons/SniperRifle.cs b/Scripts/Weapons/SniperRifle.cs\nindex bfe145d..19e8ef4 100644\n--- a/Scripts/Weapons/SniperRifle.cs\n+++ b/Scripts/Weapons/SniperRifle.cs\n@@ -920,12 +920,13 @@ public partial class SniperRifle : BaseWeapon\n     /// 1.0 = one viewport distance, 2.0 = two viewport distances.\n     /// Controlled by mouse wheel while scoping.\n     /// </summary>\n-    private float _scopeZoomDistance = 1.0f;\n+    private float _scopeZoomDistance = 1.5f;\n \n     /// <summary>\n     /// Minimum scope zoom distance (viewport multiplier).\n+    /// Set to 1.0 so the scope always looks beyond the normal viewport.\n     /// </summary>\n-    private const float MinScopeZoomDistance = 0.5f;\n+    private const float MinScopeZoomDistance = 1.0f;\n \n     /// <summary>\n     /// Maximum scope zoom distance (viewport multiplier).\n@@ -947,6 +948,19 @@ public partial class SniperRifle : BaseWeapon\n     /// </summary>\n     private const float ScopeSwaySpeed = 2.5f;\n \n+    /// <summary>\n+    /// Maximum range (in viewport fraction) that the player can fine-tune the scope\n+    /// distance via mouse movement while scoped. About 1/3 of the viewport.\n+    /// </summary>\n+    private const float ScopeMouseFineTuneRange = 0.33f;\n+\n+    /// <summary>\n+    /// Current mouse fine-tune offset applied to scope distance.\n+    /// Ranges from -ScopeMouseFineTuneRange to +ScopeMouseFineTuneRange (viewport fraction).\n+    /// Positive = further, negative = closer.\n+    /// </summary>\n+    private float _scopeMouseFineTuneOffset = 0.0f;\n+\n     /// <summary>\n     /// Current scope sway time accumulator.\n     /// </summary>\n@@ -982,6 +996,11 @@ public partial class SniperRifle : BaseWeapon\n     /// </summary>\n     private Vector2 _originalCameraOffset = Vector2.Zero;\n \n+    /// <summary>\n+    /// Gets the effective scope zoom distance including mouse fine-tune offset.\n+    /// </summary>\n+    private float EffectiveScopeZoomDistance => _scopeZoomDistance + _scopeMouseFineTuneOffset;\n+\n     /// <summary>\n     /// Gets the current camera offset for scope aiming.\n     /// Called by the player or level scripts to position the camera.\n@@ -1002,12 +1021,34 @@ public partial class SniperRifle : BaseWeapon\n         Vector2 viewportSize = viewport.GetVisibleRect().Size;\n         float baseDistance = viewportSize.Length() * 0.5f;\n \n-        // Camera offset = aim direction * zoom distance * viewport size + sway\n-        Vector2 offset = _aimDirection * baseDistance * _scopeZoomDistance + _scopeSwayOffset;\n+        // Camera offset = aim direction * (zoom distance + mouse fine-tune) * viewport size + sway\n+        Vector2 offset = _aimDirection * baseDistance * EffectiveScopeZoomDistance + _scopeSwayOffset;\n \n         return offset;\n     }\n \n+    /// <summary>\n+    /// Gets the world-space position that the scope crosshair center is aiming at.\n+    /// Used to direct bullets to the crosshair center.\n+    /// </summary>\n+    public Vector2 GetScopeAimTarget()\n+    {\n+        Viewport? viewport = GetViewport();\n+        if (viewport == null)\n+        {\n+            return GlobalPosition + _aimDirection * 1000.0f;\n+        }\n+\n+        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n+        float baseDistance = viewportSize.Length() * 0.5f;\n+\n+        // The scope aim target is the player's position offset by the scope camera offset\n+        // (without sway, so bullets go to the true center, not the swaying crosshair)\n+        Vector2 aimTarget = GlobalPosition + _aimDirection * baseDistance * EffectiveScopeZoomDistance;\n+\n+        return aimTarget;\n+    }\n+\n     /// <summary>\n     /// Activates the scope (called when RMB is pressed).\n     /// </summary>\n@@ -1020,6 +1061,7 @@ public partial class SniperRifle : BaseWeapon\n \n         _isScopeActive = true;\n         _scopeSwayTime = 0.0f;\n+        _scopeMouseFineTuneOffset = 0.0f;\n \n         // Find and cache the player's Camera2D\n         FindPlayerCamera();\n@@ -1075,7 +1117,35 @@ public partial class SniperRifle : BaseWeapon\n         _scopeZoomDistance += direction * ScopeZoomStep;\n         _scopeZoomDistance = Mathf.Clamp(_scopeZoomDistance, MinScopeZoomDistance, MaxScopeZoomDistance);\n \n-        GD.Print($\"[SniperRifle] Scope zoom adjusted: {_scopeZoomDistance:F2}x\");\n+        // Reset fine-tune offset when zoom changes to avoid going out of range\n+        _scopeMouseFineTuneOffset = Mathf.Clamp(_scopeMouseFineTuneOffset,\n+            -ScopeMouseFineTuneRange, ScopeMouseFineTuneRange);\n+\n+        GD.Print($\"[SniperRifle] Scope zoom adjusted: {_scopeZoomDistance:F2}x (fine-tune: {_scopeMouseFineTuneOffset:F2})\");\n+    }\n+\n+    /// <summary>\n+    /// Adjusts the scope fine-tune offset based on mouse movement along the aim direction.\n+    /// Allows the player to look slightly closer or further (about 1/3 viewport range).\n+    /// Called from Player.cs when mouse moves while scoped.\n+    /// </summary>\n+    public void AdjustScopeFineTune(Vector2 mouseMotion)\n+    {\n+        if (!_isScopeActive)\n+        {\n+            return;\n+        }\n+\n+        // Project mouse motion onto the aim direction to get forward/backward movement\n+        // Moving mouse in the aim direction = further, opposite = closer\n+        float projection = mouseMotion.Dot(_aimDirection);\n+\n+        // Scale the projection: mouse sensitivity for scope fine-tuning\n+        // A moderate movement across the screen should give the full range\n+        float sensitivity = 0.002f;\n+        _scopeMouseFineTuneOffset += projection * sensitivity;\n+        _scopeMouseFineTuneOffset = Mathf.Clamp(_scopeMouseFineTuneOffset,\n+            -ScopeMouseFineTuneRange, ScopeMouseFineTuneRange);\n     }\n \n     /// <summary>\n@@ -1105,9 +1175,9 @@ public partial class SniperRifle : BaseWeapon\n             return;\n         }\n \n-        // Update sway\n+        // Update sway (scales with effective distance including fine-tune offset)\n         _scopeSwayTime += delta;\n-        float swayAmplitude = BaseScopeSwayAmplitude * _scopeZoomDistance;\n+        float swayAmplitude = BaseScopeSwayAmplitude * EffectiveScopeZoomDistance;\n \n         // Use two sine waves at different frequencies for natural-looking sway\n         float swayX = Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 1.0f) * swayAmplitude\n@@ -1342,11 +1412,11 @@ public partial class SniperRifle : BaseWeapon\n         // Crosshair stays centered but sways\n         _scopeCrosshair.Position = viewportSize / 2 + _scopeSwayOffset;\n \n-        // Update zoom label\n+        // Update zoom label showing effective zoom distance\n         var zoomLabel = _scopeCrosshair.GetNodeOrNull<Label>(\"ZoomLabel\");\n         if (zoomLabel != null)\n         {\n-            zoomLabel.Text = $\"{_scopeZoomDistance:F1}x\";\n+            zoomLabel.Text = $\"{EffectiveScopeZoomDistance:F1}x\";\n         }\n     }",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "e8c19558-c1e5-413e-93d0-3bb2b9d32060",
  "tool_use_result": {
    "stdout": "diff --git a/Scripts/Characters/Player.cs b/Scripts/Characters/Player.cs\nindex f75b96a..f15814e 100644\n--- a/Scripts/Characters/Player.cs\n+++ b/Scripts/Characters/Player.cs\n@@ -1661,6 +1661,15 @@ public partial class Player : BaseCharacter\n         // If we have a weapon equipped, use it\n         if (CurrentWeapon != null)\n         {\n+            // When SniperRifle scope is active, fire towards the scope crosshair center\n+            // instead of the mouse cursor (the camera is offset, so mouse != crosshair)\n+            var sniperRifle = CurrentWeapon as SniperRifle;\n+            if (sniperRifle != null && sniperRifle.IsScopeActive)\n+            {\n+                Vector2 scopeTarget = sniperRifle.GetScopeAimTarget();\n+                shootDirection = (scopeTarget - GlobalPosition).Normalized();\n+            }\n+\n             CurrentWeapon.Fire(shootDirection);\n             return;\n         }\n@@ -1965,6 +1974,11 @@ public partial class Player : BaseCharacter\n                 }\n             }\n         }\n+        // Handle mouse movement for scope fine-tuning (closer/further by ~1/3 viewport)\n+        else if (@event is InputEventMouseMotion mouseMotion)\n+        {\n+            sniperRifle.AdjustScopeFineTune(mouseMotion.Relative);\n+        }\n     }\n \n     #endregion\ndiff --git a/Scripts/Weapons/SniperRifle.cs b/Scripts/Weapons/SniperRifle.cs\nindex bfe145d..19e8ef4 100644\n--- a/Scripts/Weapons/SniperRifle.cs\n+++ b/Scripts/Weapons/SniperRifle.cs\n@@ -920,12 +920,13 @@ public partial class SniperRifle : BaseWeapon\n     /// 1.0 = one viewport distance, 2.0 = two viewport distances.\n     /// Controlled by mouse wheel while scoping.\n     /// </summary>\n-    private float _scopeZoomDistance = 1.0f;\n+    private float _scopeZoomDistance = 1.5f;\n \n     /// <summary>\n     /// Minimum scope zoom distance (viewport multiplier).\n+    /// Set to 1.0 so the scope always looks beyond the normal viewport.\n     /// </summary>\n-    private const float MinScopeZoomDistance = 0.5f;\n+    private const float MinScopeZoomDistance = 1.0f;\n \n     /// <summary>\n     /// Maximum scope zoom distance (viewport multiplier).\n@@ -947,6 +948,19 @@ public partial class SniperRifle : BaseWeapon\n     /// </summary>\n     private const float ScopeSwaySpeed = 2.5f;\n \n+    /// <summary>\n+    /// Maximum range (in viewport fraction) that the player can fine-tune the scope\n+    /// distance via mouse movement while scoped. About 1/3 of the viewport.\n+    /// </summary>\n+    private const float ScopeMouseFineTuneRange = 0.33f;\n+\n+    /// <summary>\n+    /// Current mouse fine-tune offset applied to scope distance.\n+    /// Ranges from -ScopeMouseFineTuneRange to +ScopeMouseFineTuneRange (viewport fraction).\n+    /// Positive = further, negative = closer.\n+    /// </summary>\n+    private float _scopeMouseFineTuneOffset = 0.0f;\n+\n     /// <summary>\n     /// Current scope sway time accumulator.\n     /// </summary>\n@@ -982,6 +996,11 @@ public partial class SniperRifle : BaseWeapon\n     /// </summary>\n     private Vector2 _originalCameraOffset = Vector2.Zero;\n \n+    /// <summary>\n+    /// Gets the effective scope zoom distance including mouse fine-tune offset.\n+    /// </summary>\n+    private float EffectiveScopeZoomDistance => _scopeZoomDistance + _scopeMouseFineTuneOffset;\n+\n     /// <summary>\n     /// Gets the current camera offset for scope aiming.\n     /// Called by the player or level scripts to position the camera.\n@@ -1002,12 +1021,34 @@ public partial class SniperRifle : BaseWeapon\n         Vector2 viewportSize = viewport.GetVisibleRect().Size;\n         float baseDistance = viewportSize.Length() * 0.5f;\n \n-        // Camera offset = aim direction * zoom distance * viewport size + sway\n-        Vector2 offset = _aimDirection * baseDistance * _scopeZoomDistance + _scopeSwayOffset;\n+        // Camera offset = aim direction * (zoom distance + mouse fine-tune) * viewport size + sway\n+        Vector2 offset = _aimDirection * baseDistance * EffectiveScopeZoomDistance + _scopeSwayOffset;\n \n         return offset;\n     }\n \n+    /// <summary>\n+    /// Gets the world-space position that the scope crosshair center is aiming at.\n+    /// Used to direct bullets to the crosshair center.\n+    /// </summary>\n+    public Vector2 GetScopeAimTarget()\n+    {\n+        Viewport? viewport = GetViewport();\n+        if (viewport == null)\n+        {\n+            return GlobalPosition + _aimDirection * 1000.0f;\n+        }\n+\n+        Vector2 viewportSize = viewport.GetVisibleRect().Size;\n+        float baseDistance = viewportSize.Length() * 0.5f;\n+\n+        // The scope aim target is the player's position offset by the scope camera offset\n+        // (without sway, so bullets go to the true center, not the swaying crosshair)\n+        Vector2 aimTarget = GlobalPosition + _aimDirection * baseDistance * EffectiveScopeZoomDistance;\n+\n+        return aimTarget;\n+    }\n+\n     /// <summary>\n     /// Activates the scope (called when RMB is pressed).\n     /// </summary>\n@@ -1020,6 +1061,7 @@ public partial class SniperRifle : BaseWeapon\n \n         _isScopeActive = true;\n         _scopeSwayTime = 0.0f;\n+        _scopeMouseFineTuneOffset = 0.0f;\n \n         // Find and cache the player's Camera2D\n         FindPlayerCamera();\n@@ -1075,7 +1117,35 @@ public partial class SniperRifle : BaseWeapon\n         _scopeZoomDistance += direction * ScopeZoomStep;\n         _scopeZoomDistance = Mathf.Clamp(_scopeZoomDistance, MinScopeZoomDistance, MaxScopeZoomDistance);\n \n-        GD.Print($\"[SniperRifle] Scope zoom adjusted: {_scopeZoomDistance:F2}x\");\n+        // Reset fine-tune offset when zoom changes to avoid going out of range\n+        _scopeMouseFineTuneOffset = Mathf.Clamp(_scopeMouseFineTuneOffset,\n+            -ScopeMouseFineTuneRange, ScopeMouseFineTuneRange);\n+\n+        GD.Print($\"[SniperRifle] Scope zoom adjusted: {_scopeZoomDistance:F2}x (fine-tune: {_scopeMouseFineTuneOffset:F2})\");\n+    }\n+\n+    /// <summary>\n+    /// Adjusts the scope fine-tune offset based on mouse movement along the aim direction.\n+    /// Allows the player to look slightly closer or further (about 1/3 viewport range).\n+    /// Called from Player.cs when mouse moves while scoped.\n+    /// </summary>\n+    public void AdjustScopeFineTune(Vector2 mouseMotion)\n+    {\n+        if (!_isScopeActive)\n+        {\n+            return;\n+        }\n+\n+        // Project mouse motion onto the aim direction to get forward/backward movement\n+        // Moving mouse in the aim direction = further, opposite = closer\n+        float projection = mouseMotion.Dot(_aimDirection);\n+\n+        // Scale the projection: mouse sensitivity for scope fine-tuning\n+        // A moderate movement across the screen should give the full range\n+        float sensitivity = 0.002f;\n+        _scopeMouseFineTuneOffset += projection * sensitivity;\n+        _scopeMouseFineTuneOffset = Mathf.Clamp(_scopeMouseFineTuneOffset,\n+            -ScopeMouseFineTuneRange, ScopeMouseFineTuneRange);\n     }\n \n     /// <summary>\n@@ -1105,9 +1175,9 @@ public partial class SniperRifle : BaseWeapon\n             return;\n         }\n \n-        // Update sway\n+        // Update sway (scales with effective distance including fine-tune offset)\n         _scopeSwayTime += delta;\n-        float swayAmplitude = BaseScopeSwayAmplitude * _scopeZoomDistance;\n+        float swayAmplitude = BaseScopeSwayAmplitude * EffectiveScopeZoomDistance;\n \n         // Use two sine waves at different frequencies for natural-looking sway\n         float swayX = Mathf.Sin(_scopeSwayTime * ScopeSwaySpeed * 1.0f) * swayAmplitude\n@@ -1342,11 +1412,11 @@ public partial class SniperRifle : BaseWeapon\n         // Crosshair stays centered but sways\n         _scopeCrosshair.Position = viewportSize / 2 + _scopeSwayOffset;\n \n-        // Update zoom label\n+        // Update zoom label showing effective zoom distance\n         var zoomLabel = _scopeCrosshair.GetNodeOrNull<Label>(\"ZoomLabel\");\n         if (zoomLabel != null)\n         {\n-            zoomLabel.Text = $\"{_scopeZoomDistance:F1}x\";\n+            zoomLabel.Text = $\"{EffectiveScopeZoomDistance:F1}x\";\n         }\n     }",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-02-06T20:58:24.808Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_017KgpxMyrnzAUcjNc8YQUXL",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "The diff looks clean and correct. Let me also check if there's a build system available to verify compilation."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 2711,
      "cache_read_input_tokens": 64766,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 2711
      },
      "output_tokens": 1,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "568b4610-6f5f-4b88-a7f8-210a0930e645"
}
[2026-02-06T20:58:25.130Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_017KgpxMyrnzAUcjNc8YQUXL",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01C4VKtYE81uS3U1uDEra2Vz",
        "name": "Glob",
        "input": {
          "pattern": "*.csproj"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 2711,
      "cache_read_input_tokens": 64766,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 2711
      },
      "output_tokens": 1,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "be34001b-ec7e-4eb1-94cd-065e150079fa"
}
[2026-02-06T20:58:25.346Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01C4VKtYE81uS3U1uDEra2Vz",
        "type": "tool_result",
        "content": "/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "9fcff1ad-857a-470e-8ef8-2626520e7486",
  "tool_use_result": {
    "filenames": [
      "/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj"
    ],
    "durationMs": 19,
    "numFiles": 1,
    "truncated": false
  }
}
[2026-02-06T20:58:25.349Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_017KgpxMyrnzAUcjNc8YQUXL",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01C9VDBzeQw6KnovtBBP3rHx",
        "name": "Glob",
        "input": {
          "pattern": "*.sln"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 2711,
      "cache_read_input_tokens": 64766,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 2711
      },
      "output_tokens": 1,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "05761462-0fb7-47ad-a02c-6be3c8d143bd"
}
[2026-02-06T20:58:25.377Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01C9VDBzeQw6KnovtBBP3rHx",
        "type": "tool_result",
        "content": "/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.sln"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "49e4a7d2-f18a-4673-a7bc-bbba20107852",
  "tool_use_result": {
    "filenames": [
      "/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.sln"
    ],
    "durationMs": 25,
    "numFiles": 1,
    "truncated": false
  }
}
[2026-02-06T20:58:28.569Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01Xe3LGS71Vc2ZeohP4XjTEK",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01F72ZJrwx3HhvNMGC2xJ2q8",
        "name": "Bash",
        "input": {
          "command": "which dotnet 2>/dev/null && dotnet --version 2>/dev/null || echo \"dotnet not available\"",
          "description": "Check if dotnet is available"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 223,
      "cache_read_input_tokens": 67477,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 223
      },
      "output_tokens": 26,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "5133aed6-c857-4812-b10e-c404e54c4fc8"
}
[2026-02-06T20:58:30.269Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01F72ZJrwx3HhvNMGC2xJ2q8",
        "type": "tool_result",
        "content": "/usr/bin/dotnet\n8.0.123",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "a058c1cd-8bb2-423d-9e6b-dab53d35ef92",
  "tool_use_result": {
    "stdout": "/usr/bin/dotnet\n8.0.123",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-02-06T20:58:33.327Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01KGabT3ZrvGZBs2H4FTi2Eq",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01MvSjGRwwgYDeVpgnpt1H5Q",
        "name": "Bash",
        "input": {
          "command": "dotnet build 2>&1 | tail -30",
          "description": "Build the project to check for compilation errors"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 125,
      "cache_read_input_tokens": 67700,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 125
      },
      "output_tokens": 25,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "c49af057-3391-4079-9510-6cff09c440d8"
}
[2026-02-06T20:58:38.059Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01MvSjGRwwgYDeVpgnpt1H5Q",
        "type": "tool_result",
        "content": "/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/SniperBullet.cs(217,45): warning CS0618: 'TileMap' is obsolete: 'Use multiple 'TileMapLayer' nodes instead. To convert a TileMap to a set of TileMapLayer nodes, open the TileMap bottom panel with the node selected, click the toolbox icon in the top-right corner and choose 'Extract TileMap layers as individual TileMapLayer nodes'.' [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/SniperBullet.cs(393,99): warning CS8625: Cannot convert null literal to non-nullable reference type. [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/ShotgunPellet.cs(211,21): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/ShotgunPellet.cs(287,45): warning CS0618: 'TileMap' is obsolete: 'Use multiple 'TileMapLayer' nodes instead. To convert a TileMap to a set of TileMapLayer nodes, open the TileMap bottom panel with the node selected, click the toolbox icon in the top-right corner and choose 'Extract TileMap layers as individual TileMapLayer nodes'.' [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/ShotgunPellet.cs(328,99): warning CS8625: Cannot convert null literal to non-nullable reference type. [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/ShotgunPellet.cs(452,17): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/ShotgunPellet.cs(462,17): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/ShotgunPellet.cs(472,13): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/ShotgunPellet.cs(480,17): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/ShotgunPellet.cs(490,13): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/ShotgunPellet.cs(497,17): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SilencedPistol.cs(741,94): warning CS8625: Cannot convert null literal to non-nullable reference type. [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/ShotgunPellet.cs(599,13): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(327,21): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(462,45): warning CS0618: 'TileMap' is obsolete: 'Use multiple 'TileMapLayer' nodes instead. To convert a TileMap to a set of TileMapLayer nodes, open the TileMap bottom panel with the node selected, click the toolbox icon in the top-right corner and choose 'Extract TileMap layers as individual TileMapLayer nodes'.' [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(561,99): warning CS8625: Cannot convert null literal to non-nullable reference type. [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(772,17): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(783,17): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(796,13): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(804,13): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(812,17): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(956,13): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(1014,13): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(1141,13): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(1265,93): warning CS8625: Cannot convert null literal to non-nullable reference type. [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(1284,109): warning CS8625: Cannot convert null literal to non-nullable reference type. [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n    34 Warning(s)\n    0 Error(s)\n\nTime Elapsed 00:00:03.83",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "96313f2e-81fe-4b35-9b30-330a97a9f3fa",
  "tool_use_result": {
    "stdout": "/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/SniperBullet.cs(217,45): warning CS0618: 'TileMap' is obsolete: 'Use multiple 'TileMapLayer' nodes instead. To convert a TileMap to a set of TileMapLayer nodes, open the TileMap bottom panel with the node selected, click the toolbox icon in the top-right corner and choose 'Extract TileMap layers as individual TileMapLayer nodes'.' [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/SniperBullet.cs(393,99): warning CS8625: Cannot convert null literal to non-nullable reference type. [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/ShotgunPellet.cs(211,21): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/ShotgunPellet.cs(287,45): warning CS0618: 'TileMap' is obsolete: 'Use multiple 'TileMapLayer' nodes instead. To convert a TileMap to a set of TileMapLayer nodes, open the TileMap bottom panel with the node selected, click the toolbox icon in the top-right corner and choose 'Extract TileMap layers as individual TileMapLayer nodes'.' [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/ShotgunPellet.cs(328,99): warning CS8625: Cannot convert null literal to non-nullable reference type. [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/ShotgunPellet.cs(452,17): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/ShotgunPellet.cs(462,17): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/ShotgunPellet.cs(472,13): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/ShotgunPellet.cs(480,17): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/ShotgunPellet.cs(490,13): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/ShotgunPellet.cs(497,17): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Weapons/SilencedPistol.cs(741,94): warning CS8625: Cannot convert null literal to non-nullable reference type. [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/ShotgunPellet.cs(599,13): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(327,21): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(462,45): warning CS0618: 'TileMap' is obsolete: 'Use multiple 'TileMapLayer' nodes instead. To convert a TileMap to a set of TileMapLayer nodes, open the TileMap bottom panel with the node selected, click the toolbox icon in the top-right corner and choose 'Extract TileMap layers as individual TileMapLayer nodes'.' [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(561,99): warning CS8625: Cannot convert null literal to non-nullable reference type. [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(772,17): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(783,17): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(796,13): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(804,13): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(812,17): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(956,13): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(1014,13): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(1141,13): warning CS0162: Unreachable code detected [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(1265,93): warning CS8625: Cannot convert null literal to non-nullable reference type. [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n/tmp/gh-issue-solver-1770411323361/Scripts/Projectiles/Bullet.cs(1284,109): warning CS8625: Cannot convert null literal to non-nullable reference type. [/tmp/gh-issue-solver-1770411323361/GodotTopDownTemplate.csproj]\n    34 Warning(s)\n    0 Error(s)\n\nTime Elapsed 00:00:03.83",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-02-06T20:58:41.638Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01AETRxBD1GUsSriTXBCgCBy",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Build succeeded with 0 errors. The warnings are all pre-existing (not from my changes). Let me now commit and push."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 2230,
      "cache_read_input_tokens": 67825,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 2230
      },
      "output_tokens": 1,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "4116787d-1382-46b3-ab39-17063d0c9af7"
}
[2026-02-06T20:58:47.272Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01AETRxBD1GUsSriTXBCgCBy",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01BcXQhPiMroWG36ZXoe4B59",
        "name": "TodoWrite",
        "input": {
          "todos": [
            {
              "content": "Read and understand current SniperRifle.cs scope implementation",
              "status": "completed",
              "activeForm": "Reading SniperRifle.cs scope implementation"
            },
            {
              "content": "Read and understand Player.cs scope input handling",
              "status": "completed",
              "activeForm": "Reading Player.cs scope input handling"
            },
            {
              "content": "Fix #1: Allow slight movement (~1/3 viewport) closer/further while scoped via mouse movement",
              "status": "completed",
              "activeForm": "Implementing scope movement closer/further"
            },
            {
              "content": "Fix #2: Make bullets fly to the center of the crosshair (scope aim point)",
              "status": "completed",
              "activeForm": "Fixing bullet aim direction to match crosshair center"
            },
            {
              "content": "Fix #3: Move minimum scope distance half a viewport further (0.5 -> 1.0)",
              "status": "completed",
              "activeForm": "Increasing minimum scope distance by half viewport"
            },
            {
              "content": "Verify changes compile and review final code",
              "status": "completed",
              "activeForm": "Verifying changes compile and reviewing code"
            },
            {
              "content": "Commit, push, and update PR description",
              "status": "in_progress",
              "activeForm": "Committing and pushing changes"
            }
          ]
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 2230,
      "cache_read_input_tokens": 67825,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 2230
      },
      "output_tokens": 1,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "a42f322b-77c1-4ad6-9775-7afda5a3c5d3"
}
[2026-02-06T20:58:47.274Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01BcXQhPiMroWG36ZXoe4B59",
        "type": "tool_result",
        "content": "Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "0ad164e8-ee87-452a-8461-e22ae3b36bf8",
  "tool_use_result": {
    "oldTodos": [
      {
        "content": "Read and understand current SniperRifle.cs scope implementation",
        "status": "completed",
        "activeForm": "Reading SniperRifle.cs scope implementation"
      },
      {
        "content": "Read and understand Player.cs scope input handling",
        "status": "completed",
        "activeForm": "Reading Player.cs scope input handling"
      },
      {
        "content": "Fix #1: Allow slight movement (~1/3 viewport) closer/further while scoped via mouse movement",
        "status": "completed",
        "activeForm": "Implementing scope movement closer/further"
      },
      {
        "content": "Fix #2: Make bullets fly to the center of the crosshair (scope aim point)",
        "status": "completed",
        "activeForm": "Fixing bullet aim direction to match crosshair center"
      },
      {
        "content": "Fix #3: Move minimum scope distance half a viewport further (0.5 -> 1.0)",
        "status": "completed",
        "activeForm": "Increasing minimum scope distance by half viewport"
      },
      {
        "content": "Verify changes compile and review final code",
        "status": "in_progress",
        "activeForm": "Verifying changes compile and reviewing code"
      },
      {
        "content": "Commit, push, and update PR description",
        "status": "pending",
        "activeForm": "Committing and pushing changes"
      }
    ],
    "newTodos": [
      {
        "content": "Read and understand current SniperRifle.cs scope implementation",
        "status": "completed",
        "activeForm": "Reading SniperRifle.cs scope implementation"
      },
      {
        "content": "Read and understand Player.cs scope input handling",
        "status": "completed",
        "activeForm": "Reading Player.cs scope input handling"
      },
      {
        "content": "Fix #1: Allow slight movement (~1/3 viewport) closer/further while scoped via mouse movement",
        "status": "completed",
        "activeForm": "Implementing scope movement closer/further"
      },
      {
        "content": "Fix #2: Make bullets fly to the center of the crosshair (scope aim point)",
        "status": "completed",
        "activeForm": "Fixing bullet aim direction to match crosshair center"
      },
      {
        "content": "Fix #3: Move minimum scope distance half a viewport further (0.5 -> 1.0)",
        "status": "completed",
        "activeForm": "Increasing minimum scope distance by half viewport"
      },
      {
        "content": "Verify changes compile and review final code",
        "status": "completed",
        "activeForm": "Verifying changes compile and reviewing code"
      },
      {
        "content": "Commit, push, and update PR description",
        "status": "in_progress",
        "activeForm": "Committing and pushing changes"
      }
    ]
  }
}
[2026-02-06T20:58:55.289Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01HNPNDFS22zoCvyr2wfnDpo",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01KbT9hHvDEx96mBfa4t69Jr",
        "name": "Bash",
        "input": {
          "command": "git add Scripts/Weapons/SniperRifle.cs Scripts/Characters/Player.cs && git commit -m \"$(cat <<'EOF'\nfix: scope improvements - bullet aim, mouse fine-tune, min distance\n\nAddress PR feedback from repository owner:\n\n1. Mouse fine-tune: While scoped, mouse movement along aim direction\n   adjusts view distance by ~1/3 viewport (closer/further)\n2. Bullet direction: When scoped, bullets now fire toward the scope\n   crosshair center (world-space aim target) instead of mouse cursor\n3. Minimum distance: Scope now starts at 1.0x viewport distance\n   (was 0.5x), default zoom set to 1.5x, ensuring scope always\n   looks beyond the normal viewport\n\nCo-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>\nEOF\n)\"",
          "description": "Commit the scope fixes"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 413,
      "cache_read_input_tokens": 70055,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 413
      },
      "output_tokens": 25,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "97b82f7e-82d5-4804-9767-9b8755762a54"
}
[2026-02-06T20:58:57.151Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01KbT9hHvDEx96mBfa4t69Jr",
        "type": "tool_result",
        "content": "[issue-520-2af4a666a08c c1fa0e7] fix: scope improvements - bullet aim, mouse fine-tune, min distance\n 2 files changed, 93 insertions(+), 9 deletions(-)",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "73c8550a-cfc6-4df8-b5f9-9e3fd40cf19c",
  "tool_use_result": {
    "stdout": "[issue-520-2af4a666a08c c1fa0e7] fix: scope improvements - bullet aim, mouse fine-tune, min distance\n 2 files changed, 93 insertions(+), 9 deletions(-)",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-02-06T20:58:59.993Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01YQunqdK6zx7g2kQmGMpTpL",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01SaShQ3i9F1G39mMfVXcucT",
        "name": "Bash",
        "input": {
          "command": "git push origin issue-520-2af4a666a08c",
          "description": "Push changes to remote"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 345,
      "cache_read_input_tokens": 70468,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 345
      },
      "output_tokens": 25,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "72600330-6623-496a-a757-1fb35a657a8e"
}
[2026-02-06T20:59:01.537Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01SaShQ3i9F1G39mMfVXcucT",
        "type": "tool_result",
        "content": "To https://github.com/konard/Jhon-Crow-godot-topdown-MVP.git\n   bcb21ec..c1fa0e7  issue-520-2af4a666a08c -> issue-520-2af4a666a08c",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "d6729c37-7c03-4a3d-8245-6b6aa62ae58e",
  "tool_use_result": {
    "stdout": "To https://github.com/konard/Jhon-Crow-godot-topdown-MVP.git\n   bcb21ec..c1fa0e7  issue-520-2af4a666a08c -> issue-520-2af4a666a08c",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-02-06T20:59:04.162Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01RrUPqfjmjueXtTT7aZxn5E",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now let me update the PR description to reflect the new changes."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 163,
      "cache_read_input_tokens": 70813,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 163
      },
      "output_tokens": 4,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "f9bf3d9b-4a9c-4810-9260-599562a23b4c"
}
[2026-02-06T20:59:36.384Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01RrUPqfjmjueXtTT7aZxn5E",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01B6bAp6LcYpkvKnGrSaiwWY",
        "name": "Bash",
        "input": {
          "command": "gh pr edit 528 --repo Jhon-Crow/godot-topdown-MVP --body \"$(cat <<'EOF'\n## Summary\n\nImplements the scoping/aiming feature for the ASVK sniper rifle as requested in the additional requirement of #520 ([comment](https://github.com/Jhon-Crow/godot-topdown-MVP/issues/520#issuecomment-3861795686)).\n\n### Features Implemented\n\n- **RMB scope activation**: Hold RMB to enter scope view, release to exit\n- **Scope crosshair overlay**: Classic sniper scope with circle, crosshair lines, and mil-dot markers (based on reference image from issue)\n- **Camera offset**: When scoped, the camera moves beyond the viewport in the player's aim direction, allowing the player to see and aim further\n- **Mouse wheel zoom**: While scoped, scroll wheel adjusts zoom distance (1.0x to 3.0x viewport multiplier)\n- **Mouse fine-tune movement**: While scoped, mouse movement along aim direction adjusts view distance by ~1/3 viewport (closer/further)\n- **Bullets fire to crosshair center**: When scoped, bullets fire toward the scope aim point (world-space crosshair center), not the mouse cursor\n- **Scope sway**: The crosshair and camera sway based on distance from player ‚Äî at 1 viewport distance the sway is moderate, at 2x distance the sway is 2x stronger\n- **Darkened viewport**: Semi-transparent overlay when scoped for immersive feel\n- **Zoom distance indicator**: Shows current effective zoom level in the scope HUD\n\n### Changes addressing PR feedback\n\n| Feedback | Fix |\n|----------|-----|\n| 1. Allow slight (~1/3 viewport) movement closer/further while scoped | Mouse movement along aim direction fine-tunes scope distance (¬±0.33 viewport fraction) via `AdjustScopeFineTune()` |\n| 2. Bullets should fly to center of crosshair | `Shoot()` in Player.cs now uses `GetScopeAimTarget()` when scope is active, directing bullets to the world-space crosshair center |\n| 3. Minimum scope distance should be half a viewport further | `MinScopeZoomDistance` increased from 0.5 to 1.0, default zoom set to 1.5x |\n\n### Technical Details\n\n| File | Change |\n|------|--------|\n| `Scripts/Weapons/SniperRifle.cs` | Added scope state management, crosshair overlay creation, camera offset calculation, sway mechanics, zoom control, mouse fine-tune, `GetScopeAimTarget()` for bullet direction |\n| `Scripts/Characters/Player.cs` | Added `HandleSniperScopeInput()` for RMB scope activation when SniperRifle equipped; added `_UnhandledInput()` for mouse wheel zoom and mouse motion fine-tuning; `Shoot()` now fires toward scope aim target when scoped |\n| `scripts/ui/armory_menu.gd` | Updated ASVK description to mention scope feature |\n\n### How It Works\n\n1. **Scope activation**: When ASVK is equipped, RMB activates scope instead of grenades (grenades still work with G+RMB when not scoping)\n2. **Camera offset**: `Camera2D.Offset` is adjusted to move the view in the aim direction by `aimDirection * viewportHalfDiagonal * effectiveZoomDistance`\n3. **Scope sway**: Two overlapping sine waves create natural-feeling scope sway that scales linearly with zoom distance\n4. **Mouse fine-tune**: Mouse motion is projected onto the aim direction to adjust scope distance by up to ¬±1/3 viewport\n5. **Bullet aim**: When scoped, bullets fire toward `GetScopeAimTarget()` which returns the world position at the scope crosshair center (without sway)\n6. **Crosshair overlay**: A `CanvasLayer` with programmatically drawn `Line2D` elements creates the scope reticle (outer circle, crosshair lines, mil-dots, scope ring)\n7. **Cleanup**: Scope properly deactivates on weapon removal via `_ExitTree()`\n\n### Scope Sway Formula\n\n```\nswayAmplitude = BaseScopeSwayAmplitude √ó effectiveZoomDistance\nswayX = sin(t √ó speed √ó 1.0) √ó amplitude + sin(t √ó speed √ó 2.3) √ó amplitude √ó 0.3\nswayY = sin(t √ó speed √ó 1.4) √ó amplitude + sin(t √ó speed √ó 0.7) √ó amplitude √ó 0.4\n```\n\nAt 1 viewport distance: ~8px sway. At 2 viewports: ~16px sway (2x stronger, as specified in the issue).\n\n## Test Plan\n\n- [ ] Equip ASVK from armory menu\n- [ ] Hold RMB to activate scope ‚Äî verify crosshair overlay appears with circle, lines, and mil-dots\n- [ ] Verify camera moves in aim direction beyond normal viewport (minimum 1.0x viewport distance)\n- [ ] Move mouse while scoped ‚Äî verify view distance adjusts slightly (closer/further, ~1/3 viewport range)\n- [ ] Scroll mouse wheel up while scoped ‚Äî verify zoom increases (camera moves further)\n- [ ] Scroll mouse wheel down ‚Äî verify zoom decreases (minimum 1.0x, not below)\n- [ ] Fire while scoped (LMB) ‚Äî verify bullet flies to the center of the crosshair, not to the mouse cursor\n- [ ] Verify scope sway is visible and increases at higher zoom levels\n- [ ] Release RMB ‚Äî verify scope deactivates and camera returns to normal\n- [ ] Verify bolt-action sequence still works while scoped\n- [ ] Verify grenades still work when NOT scoped (G+RMB for grenade prep)\n- [ ] Verify other weapons (M16, etc.) are unaffected ‚Äî RMB should still work for grenades\n- [ ] Test in all levels: TestTier, BuildingLevel, CastleLevel, TutorialLevel\n\nFixes #520\n\nü§ñ Generated with [Claude Code](https://claude.com/claude-code)\nEOF\n)\"",
          "description": "Update PR description with feedback fixes"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 163,
      "cache_read_input_tokens": 70813,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 163
      },
      "output_tokens": 4,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "3db1da8c-c154-4627-a841-3d8e24f4151a"
}
[2026-02-06T20:59:38.769Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01B6bAp6LcYpkvKnGrSaiwWY",
        "type": "tool_result",
        "content": "https://github.com/Jhon-Crow/godot-topdown-MVP/pull/528",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "023b97da-34ea-404b-b70a-eb55d4ff08be",
  "tool_use_result": {
    "stdout": "https://github.com/Jhon-Crow/godot-topdown-MVP/pull/528",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-02-06T20:59:41.422Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01DVjmMbEcqTMCPdEJg3FAC8",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now let me mark the PR as ready and leave a comment summarizing the changes."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 1606,
      "cache_read_input_tokens": 70976,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 1606
      },
      "output_tokens": 3,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "387c81a2-3289-4e19-ae8a-7074ffba4f96"
}
[2026-02-06T20:59:42.046Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01DVjmMbEcqTMCPdEJg3FAC8",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01FJhmwYuMsnQfSvvqBpHJ75",
        "name": "Bash",
        "input": {
          "command": "gh pr ready 528 --repo Jhon-Crow/godot-topdown-MVP",
          "description": "Mark PR as ready for review"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 1606,
      "cache_read_input_tokens": 70976,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 1606
      },
      "output_tokens": 3,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "99799e2d-ec0f-4bb2-bde6-9d28b556c15a"
}
[2026-02-06T20:59:43.591Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01FJhmwYuMsnQfSvvqBpHJ75",
        "type": "tool_result",
        "content": "‚úì Pull request Jhon-Crow/godot-topdown-MVP#528 is marked as \"ready for review\"",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "8c59040b-5ca8-420c-b8b5-6a086581172c",
  "tool_use_result": {
    "stdout": "‚úì Pull request Jhon-Crow/godot-topdown-MVP#528 is marked as \"ready for review\"",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-02-06T20:59:52.580Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_015Gsb3jLEZiJbyASvmMLTch",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01ApzfuNd7VDBVvVTr3mBaaf",
        "name": "Bash",
        "input": {
          "command": "gh pr comment 528 --repo Jhon-Crow/godot-topdown-MVP --body \"$(cat <<'EOF'\n## Feedback addressed\n\nAll 3 items from the feedback have been implemented:\n\n### 1. Mouse fine-tune movement in scope mode\nWhile scoped, moving the mouse along the aim direction adjusts the view distance by approximately ¬±1/3 viewport. This allows slight closer/further adjustment without using the scroll wheel.\n\n**Implementation**: `AdjustScopeFineTune()` projects mouse motion onto the aim direction and adjusts `_scopeMouseFineTuneOffset` (clamped to ¬±0.33).\n\n### 2. Bullets fly to crosshair center\nPreviously `Shoot()` used the mouse cursor position to calculate bullet direction. With the camera offset from scoping, this meant bullets didn't go where the crosshair was pointing.\n\n**Fix**: When the SniperRifle scope is active, `Shoot()` now calls `GetScopeAimTarget()` to get the world-space position that the crosshair center represents, and fires the bullet toward that point.\n\n### 3. Minimum scope distance increased\n- `MinScopeZoomDistance`: `0.5` ‚Üí `1.0` (always looks beyond normal viewport)\n- Default zoom: `1.0` ‚Üí `1.5` (starts at a comfortable distance)\n\nBuild passes with 0 errors.\nEOF\n)\"",
          "description": "Comment on PR with feedback summary"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 155,
      "cache_read_input_tokens": 72582,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 155
      },
      "output_tokens": 25,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "bdaa532f-6087-4403-b3d4-9343b4820fa3"
}
[2026-02-06T20:59:54.103Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01ApzfuNd7VDBVvVTr3mBaaf",
        "type": "tool_result",
        "content": "https://github.com/Jhon-Crow/godot-topdown-MVP/pull/528#issuecomment-3862547631",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "c0243405-02fa-4e3e-8bc7-5ea765ab66b8",
  "tool_use_result": {
    "stdout": "https://github.com/Jhon-Crow/godot-topdown-MVP/pull/528#issuecomment-3862547631",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-02-06T20:59:58.913Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01Jrqi4fAMy7FUGZRQyQ69Ap",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01FfModsfqUrcDjUumDGKFgy",
        "name": "TodoWrite",
        "input": {
          "todos": [
            {
              "content": "Read and understand current SniperRifle.cs scope implementation",
              "status": "completed",
              "activeForm": "Reading SniperRifle.cs scope implementation"
            },
            {
              "content": "Read and understand Player.cs scope input handling",
              "status": "completed",
              "activeForm": "Reading Player.cs scope input handling"
            },
            {
              "content": "Fix #1: Allow slight movement (~1/3 viewport) closer/further while scoped via mouse movement",
              "status": "completed",
              "activeForm": "Implementing scope movement closer/further"
            },
            {
              "content": "Fix #2: Make bullets fly to the center of the crosshair (scope aim point)",
              "status": "completed",
              "activeForm": "Fixing bullet aim direction to match crosshair center"
            },
            {
              "content": "Fix #3: Move minimum scope distance half a viewport further (0.5 -> 1.0)",
              "status": "completed",
              "activeForm": "Increasing minimum scope distance by half viewport"
            },
            {
              "content": "Verify changes compile and review final code",
              "status": "completed",
              "activeForm": "Verifying changes compile and reviewing code"
            },
            {
              "content": "Commit, push, and update PR description",
              "status": "completed",
              "activeForm": "Committing and pushing changes"
            }
          ]
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 452,
      "cache_read_input_tokens": 72737,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 452
      },
      "output_tokens": 25,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "42d7a1f3-28ba-48b8-abf8-83eaee660202"
}
[2026-02-06T20:59:58.915Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01FfModsfqUrcDjUumDGKFgy",
        "type": "tool_result",
        "content": "Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "c4dac7b2-f8bf-4b67-9318-59b0a59b1445",
  "tool_use_result": {
    "oldTodos": [
      {
        "content": "Read and understand current SniperRifle.cs scope implementation",
        "status": "completed",
        "activeForm": "Reading SniperRifle.cs scope implementation"
      },
      {
        "content": "Read and understand Player.cs scope input handling",
        "status": "completed",
        "activeForm": "Reading Player.cs scope input handling"
      },
      {
        "content": "Fix #1: Allow slight movement (~1/3 viewport) closer/further while scoped via mouse movement",
        "status": "completed",
        "activeForm": "Implementing scope movement closer/further"
      },
      {
        "content": "Fix #2: Make bullets fly to the center of the crosshair (scope aim point)",
        "status": "completed",
        "activeForm": "Fixing bullet aim direction to match crosshair center"
      },
      {
        "content": "Fix #3: Move minimum scope distance half a viewport further (0.5 -> 1.0)",
        "status": "completed",
        "activeForm": "Increasing minimum scope distance by half viewport"
      },
      {
        "content": "Verify changes compile and review final code",
        "status": "completed",
        "activeForm": "Verifying changes compile and reviewing code"
      },
      {
        "content": "Commit, push, and update PR description",
        "status": "in_progress",
        "activeForm": "Committing and pushing changes"
      }
    ],
    "newTodos": [
      {
        "content": "Read and understand current SniperRifle.cs scope implementation",
        "status": "completed",
        "activeForm": "Reading SniperRifle.cs scope implementation"
      },
      {
        "content": "Read and understand Player.cs scope input handling",
        "status": "completed",
        "activeForm": "Reading Player.cs scope input handling"
      },
      {
        "content": "Fix #1: Allow slight movement (~1/3 viewport) closer/further while scoped via mouse movement",
        "status": "completed",
        "activeForm": "Implementing scope movement closer/further"
      },
      {
        "content": "Fix #2: Make bullets fly to the center of the crosshair (scope aim point)",
        "status": "completed",
        "activeForm": "Fixing bullet aim direction to match crosshair center"
      },
      {
        "content": "Fix #3: Move minimum scope distance half a viewport further (0.5 -> 1.0)",
        "status": "completed",
        "activeForm": "Increasing minimum scope distance by half viewport"
      },
      {
        "content": "Verify changes compile and review final code",
        "status": "completed",
        "activeForm": "Verifying changes compile and reviewing code"
      },
      {
        "content": "Commit, push, and update PR description",
        "status": "completed",
        "activeForm": "Committing and pushing changes"
      }
    ]
  }
}
[2026-02-06T21:00:05.324Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-6",
    "id": "msg_01GedWQEW9G8wHTayj8JgBHa",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "All feedback items have been addressed. Here's a summary of what was done:\n\n**PR**: https://github.com/Jhon-Crow/godot-topdown-MVP/pull/528\n\n### Changes made (commit `c1fa0e7`):\n\n1. **Mouse fine-tune movement** (feedback #1): While scoped, mouse movement along the aim direction adjusts the scope distance by ¬±1/3 viewport. This allows the player to look slightly closer or further without using the scroll wheel.\n\n2. **Bullets fire to crosshair center** (feedback #2): `Shoot()` in `Player.cs` now detects when the SniperRifle scope is active and calculates the bullet direction toward `GetScopeAimTarget()` ‚Äî the world-space position at the crosshair center ‚Äî instead of the mouse cursor position (which is wrong because the camera is offset when scoped).\n\n3. **Minimum scope distance increased** (feedback #3): `MinScopeZoomDistance` changed from `0.5` to `1.0` and default zoom from `1.0` to `1.5`, ensuring the scope always looks beyond the normal viewport as intended.\n\nBuild compiles with 0 errors (34 pre-existing warnings unchanged)."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 382,
      "cache_read_input_tokens": 73189,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 0,
        "ephemeral_1h_input_tokens": 382
      },
      "output_tokens": 1,
      "service_tier": "standard",
      "inference_geo": "not_available"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "uuid": "f57f36b3-ba33-498f-a70e-6ce7643d09c7"
}
[2026-02-06T21:00:05.359Z] [INFO] {
  "type": "result",
  "subtype": "success",
  "is_error": false,
  "duration_ms": 260660,
  "duration_api_ms": 277856,
  "num_turns": 44,
  "result": "All feedback items have been addressed. Here's a summary of what was done:\n\n**PR**: https://github.com/Jhon-Crow/godot-topdown-MVP/pull/528\n\n### Changes made (commit `c1fa0e7`):\n\n1. **Mouse fine-tune movement** (feedback #1): While scoped, mouse movement along the aim direction adjusts the scope distance by ¬±1/3 viewport. This allows the player to look slightly closer or further without using the scroll wheel.\n\n2. **Bullets fire to crosshair center** (feedback #2): `Shoot()` in `Player.cs` now detects when the SniperRifle scope is active and calculates the bullet direction toward `GetScopeAimTarget()` ‚Äî the world-space position at the crosshair center ‚Äî instead of the mouse cursor position (which is wrong because the camera is offset when scoped).\n\n3. **Minimum scope distance increased** (feedback #3): `MinScopeZoomDistance` changed from `0.5` to `1.0` and default zoom from `1.0` to `1.5`, ensuring the scope always looks beyond the normal viewport as intended.\n\nBuild compiles with 0 errors (34 pre-existing warnings unchanged).",
  "stop_reason": null,
  "session_id": "72695659-de5b-4772-8d20-a0317ff84485",
  "total_cost_usd": 1.6993544999999999,
  "usage": {
    "input_tokens": 36,
    "cache_creation_input_tokens": 54726,
    "cache_read_input_tokens": 2015874,
    "output_tokens": 12263,
    "server_tool_use": {
      "web_search_requests": 0,
      "web_fetch_requests": 0
    },
    "service_tier": "standard",
    "cache_creation": {
      "ephemeral_1h_input_tokens": 54726,
      "ephemeral_5m_input_tokens": 0
    }
  },
  "modelUsage": {
    "claude-haiku-4-5-20251001": {
      "inputTokens": 39080,
      "outputTokens": 709,
      "cacheReadInputTokens": 0,
      "cacheCreationInputTokens": 0,
      "webSearchRequests": 0,
      "costUSD": 0.042625,
      "contextWindow": 200000,
      "maxOutputTokens": 64000
    },
    "claude-opus-4-6": {
      "inputTokens": 36,
      "outputTokens": 12263,
      "cacheReadInputTokens": 2015874,
      "cacheCreationInputTokens": 54726,
      "webSearchRequests": 0,
      "costUSD": 1.6567294999999997,
      "contextWindow": 200000,
      "maxOutputTokens": 32000
    }
  },
  "permission_denials": [],
  "uuid": "29675114-28f4-4d6d-b67d-58d76fe3efa2"
}
[2026-02-06T21:00:05.361Z] [INFO] üí∞ Anthropic official cost captured from success result: $1.699354
[2026-02-06T21:00:06.315Z] [INFO] 

‚úÖ Claude command completed
[2026-02-06T21:00:06.317Z] [INFO] üìä Total messages: 0, Tool uses: 0
[2026-02-06T21:00:06.429Z] [INFO] 
üí∞ Token Usage Summary:
[2026-02-06T21:00:06.436Z] [INFO] 
   üìä Claude Opus 4.6:
[2026-02-06T21:00:06.438Z] [INFO]       Model ID: claude-opus-4-6
[2026-02-06T21:00:06.439Z] [INFO]       Provider: Anthropic
[2026-02-06T21:00:06.439Z] [INFO]       Context window: 200 000 tokens
[2026-02-06T21:00:06.439Z] [INFO]       Max output: 128 000 tokens
[2026-02-06T21:00:06.446Z] [INFO]       Input modalities: text, image, pdf
[2026-02-06T21:00:06.447Z] [INFO]       Output modalities: text
[2026-02-06T21:00:06.447Z] [INFO]       Knowledge cutoff: 2025-05
[2026-02-06T21:00:06.447Z] [INFO]       Released: 2026-02-05
[2026-02-06T21:00:06.447Z] [INFO]       Capabilities: Attachments, Reasoning, Temperature, Tool calls
[2026-02-06T21:00:06.447Z] [INFO]       Open weights: No
[2026-02-06T21:00:06.448Z] [INFO] 
[2026-02-06T21:00:06.448Z] [INFO]       Usage:
[2026-02-06T21:00:06.448Z] [INFO]         Input tokens: 72
[2026-02-06T21:00:06.448Z] [INFO]         Cache creation tokens: 139 403
[2026-02-06T21:00:06.448Z] [INFO]         Cache read tokens: 3 600 473
[2026-02-06T21:00:06.448Z] [INFO]         Output tokens: 475
[2026-02-06T21:00:06.448Z] [INFO] 
[2026-02-06T21:00:06.449Z] [INFO]       Cost Calculation (USD):
[2026-02-06T21:00:06.449Z] [INFO]         Input: 72 tokens √ó $5/M = $0.000360
[2026-02-06T21:00:06.449Z] [INFO]         Cache write: 139 403 tokens √ó $6.25/M = $0.871269
[2026-02-06T21:00:06.449Z] [INFO]         Cache read: 3 600 473 tokens √ó $0.5/M = $1.800237
[2026-02-06T21:00:06.449Z] [INFO]         Output: 475 tokens √ó $25/M = $0.011875
[2026-02-06T21:00:06.449Z] [INFO]         ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
[2026-02-06T21:00:06.449Z] [INFO]         Total: $2.683740
[2026-02-06T21:00:06.450Z] [INFO] 
      üìä Token Budget Statistics:
[2026-02-06T21:00:06.450Z] [INFO]         Context window:
[2026-02-06T21:00:06.450Z] [INFO]           Used: 3 739 948 tokens
[2026-02-06T21:00:06.451Z] [INFO]           Limit: 200 000 tokens
[2026-02-06T21:00:06.451Z] [INFO]           Ratio: 18.6997 (1869.97%)
[2026-02-06T21:00:06.451Z] [INFO]         Output tokens:
[2026-02-06T21:00:06.451Z] [INFO]           Used: 475 tokens
[2026-02-06T21:00:06.451Z] [INFO]           Limit: 128 000 tokens
[2026-02-06T21:00:06.452Z] [INFO]           Ratio: 0.0037 (0.37%)
[2026-02-06T21:00:06.452Z] [INFO]         Total session tokens: 139 950
[2026-02-06T21:00:06.452Z] [INFO] 
   üí∞ Cost estimation:
[2026-02-06T21:00:06.452Z] [INFO]       Public pricing estimate: $2.683740 USD
[2026-02-06T21:00:06.452Z] [INFO]       Calculated by Anthropic: $1.699354 USD
[2026-02-06T21:00:06.452Z] [INFO]       Difference:              $-0.984386 (-36.68%)
[2026-02-06T21:00:06.453Z] [INFO]       Total tokens: 139 950
[2026-02-06T21:00:06.453Z] [INFO] 
üí° To continue this session in Claude Code interactive mode:

[2026-02-06T21:00:06.454Z] [INFO]    (cd "/tmp/gh-issue-solver-1770411323361" && claude --resume 72695659-de5b-4772-8d20-a0317ff84485 --model opus)

[2026-02-06T21:00:06.457Z] [INFO] 
üîç Checking for uncommitted changes...
[2026-02-06T21:00:06.535Z] [INFO] ‚úÖ No uncommitted changes found
[2026-02-06T21:00:06.536Z] [INFO]    No initial commit hash from session, attempting to detect from branch...
[2026-02-06T21:00:06.537Z] [INFO]    Attempting to detect CLAUDE.md or .gitkeep commit from branch structure...
[2026-02-06T21:00:06.660Z] [INFO]    Neither CLAUDE.md nor .gitkeep exists in current branch
[2026-02-06T21:00:06.661Z] [INFO]    Could not safely detect initial commit to revert
[2026-02-06T21:00:06.662Z] [INFO] 
=== Session Summary ===
[2026-02-06T21:00:06.662Z] [INFO] ‚úÖ Session ID: 72695659-de5b-4772-8d20-a0317ff84485
[2026-02-06T21:00:06.662Z] [INFO] ‚úÖ Complete log file: /home/hive/72695659-de5b-4772-8d20-a0317ff84485.log
[2026-02-06T21:00:06.663Z] [INFO] 
[2026-02-06T21:00:06.664Z] [INFO] üí° To continue this session in Claude Code interactive mode:
[2026-02-06T21:00:06.665Z] [INFO] 
[2026-02-06T21:00:06.665Z] [INFO]    (cd "/tmp/gh-issue-solver-1770411323361" && claude --resume 72695659-de5b-4772-8d20-a0317ff84485 --model opus)
[2026-02-06T21:00:06.666Z] [INFO] 
[2026-02-06T21:00:06.667Z] [INFO] 
üîç Searching for created pull requests or comments...
[2026-02-06T21:00:07.041Z] [INFO] 
üîç Checking for pull requests from branch issue-520-2af4a666a08c...
[2026-02-06T21:00:07.447Z] [INFO]   ‚úÖ Found pull request #528: "feat: add ASVK scope/aiming system (RMB)"
[2026-02-06T21:00:07.884Z] [INFO]   ‚úÖ PR body already contains issue reference
[2026-02-06T21:00:07.885Z] [INFO]   ‚úÖ PR is already ready for review
[2026-02-06T21:00:07.886Z] [INFO] 
üìé Uploading solution draft log to Pull Request...
[2026-02-06T21:00:08.031Z] [INFO]   üí∞ Calculated cost: $2.683740
